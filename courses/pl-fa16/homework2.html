<!DOCTYPE html>
<html>

  <head>
    
    <meta charset="utf-8">
    <title>Homework 2</title>

    <link rel="stylesheet" href="alt.css" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,800,700' rel='stylesheet' type='text/css'>

    <script src="autoscroll.js"></script>
    
    <style>

      hr { margin-top: 50px; }

        code,tt,pre {
          font-size: 130%;
        }
	
        div.lect {
	  padding-top: 0;
       	  padding-left: 3em;
	  margin-top:0;
        }
    	p.ann { 
    	  padding-left: 3em;
    	  text-indent: -3em; 
    	}
	p.ann_ctd{
	  padding-left: 3em;
        }
    	span.hdr {
   	  padding-right: 1em
    	}

	.hidden {
	  visibility: hidden;
        }

        tt.code {
           background: #e6e6e6;
        }

	pre.code {
	   border: 1px solid #c6c6c6;
	border-radius: 5px;
	padding: 10px;
	font-size:100%;
	}

/* from
    http://www.456bereastreet.com/archive/201105/styling_ordered_list_numbers/
 */

ol {
    counter-reset:li; /* Initiate a counter */
    margin-left:0; /* Remove the default left margin */
    padding-left:0; /* Remove the default left padding */
    padding-top:1em;
}
ol > li {
    position:relative; /* Create a positioning context */
    margin:0 0 6px 2em; /* Give each list item a left margin to make
    room for the numbers */
    padding:4px 8px; /* Add some spacing around the content */
    list-style:none; /* Disable the normal item numbering */
    /*border-top:2px solid #666;
    background:#f6f6f6; */
}
ol > li:before {
    counter-increment:li; /* Increment the counter by 1 */
    /* Position and style the number */
    position:absolute;
    top:-2px;
    left:-2em;
    -moz-box-sizing:border-box;
    -webkit-box-sizing:border-box;
    box-sizing:border-box;
    width:2em;
    /* Some space between the number and the content in browsers that
    support
       generated content but not positioning it (Camino 2 is one
    example) */
    margin-right:8px;
    padding:4px;
/*    border-top:2px solid #666;
    color:#fff;
    background:#666; 
    font-weight:bold; */
/*    font-family:"Helvetica Neue", Arial, sans-serif;
    text-align:center; */
}

ol.letter > li:before {
    content:"(" counter(li,lower-alpha) ")"; /* Use the counter as content */
}

ol.number > li:before {
    content:"(" counter(li,decimal) ")"; /* Use the counter as content */
}

li ol,
li ul {margin-top:6px;}

li > p { margin-top:0;}

    </style>

  </head>


  <body>

    <div class="navbar">

      <div class="home">
	<a href="../../index.html"><img src="../../home.png" style="height: 1.6em;"></a>
      </div>

      <ul>
	<li><a href="index.html"><b>Programming Languages FA16</b></a></li> 
	<li class="hidden"><a class="scrollto" href="#announcements">Announcements</a></li>
	<li class="hidden"><a class="scrollto" href="#info">Course Info</a></li>
	<li class="hidden"><a class="scrollto" href="#lectures">Lectures</a></li>
	<li class="hidden"><a class="scrollto" href="#homeworks">Homeworks</a></li>
      </ul>
    </div>


    <!-- padding -->
    <div id="top" style="height: 7em;"></div>
    
    <h1 class="clear">Homework 2</h1>
    
    <p class="subtitle">Due date: Monday, Sep 19 (11:59:59pm)</p>


    <p><b>Note on integrity:</b> This homework is meant to be done in teams of two. 
    You may discuss problems with fellow students, but
    all work must be entirely that of your team, and should not be from any
    other course, present, past, or future. If you use a solution from
    another source you must cite it &mdash; this includes when that source
      is someone else helping you.</p>

    <p>Every source file you submit should begin with a block comment
      that lists <span style="text-decoration:underline;">the members of your team</span>, your <span style="text-decoration:underline;">email addresses</span>, and any <span style="text-decoration:underline;">remarks</span> that you
      wish to make to the instructor.</p>

    <p>All programming is to be done in Python 2.7.</p>

    <p>Feel free to define helper functions if you need them.</p>

    <p>Please code your answers by modifying the
      file <a href="homework2.py"><tt>homework2.py</tt></a>
      provided.</p>

    <p>Questions marked <b>Extra</b> are optional. You do not have to
    do them. But will give you more practice and sometimes more
      insight into what is going on. Plus some of them are fun.</p>

    <p>Electronic submission instructions:</p>

    <ul>
      <li>Send an email with your file <tt>homework2.py</tt> as an attachment to <tt>pl.fa16.olin@gmail.com</tt> with subject <i>Homework 2 submission</i>. Only one email per team, please.</li>
    </ul>

    <hr>
    
    <ol class="number">

      <li> <p><b>Multiple Bindings</b></p>

	<ol class="letter">

	  <li><p>Modify the implementation of <tt class="code">ELet</tt> so it can
	      handle multiple <i>simultaneous bindings</i> instead of a
	      single one. For instance, using an extension of the
	      surface syntax I used in class, we could write
<pre>
  let (x = 10, y = 20, z = 30)
    (x+y)*z
</pre>
which should evaluate to 900, and
<pre>
  let (a = 5, b = 20)
    let (a = b, b = a)
      a - b
</pre>
which should evaluate to 15.</p>

Note this last expression is different from
<pre>
  let (a = 5)
    let (b = 20)
      let (a = b)
        let (b = a)
          a - b
</pre>  
(Why?) In particular, this one evaluates to 0.</p>

<p>For the sake of agreeing on the interface, make your revised <tt>ELet</tt>
  take two arguments:
  <ul>
    <li> A list of pairs representing the bindings, each pair of the
      form <tt>(id,exp)</tt> where <tt>id</tt> is a string
      representing the name of an identifier being bound,
      and <tt>exp</tt> the expression that identifier is bound to</li>
    <li> the expression to evaluate in the context of those bindings,
      and that will be the result of evaluating the <tt>ELet</tt>
      expression as a whole.</li>
  </ul>
    
</p>

<p>The two examples above would be written:
<pre>
  ELet([("x",EInteger(10)),
        ("y",EInteger(20)),
        ("z",EInteger(30))],
       EPrimCall("*",[EPrimCall("+",[EId("x"),EId("y")]),EId("z")]))
</pre>
and
<pre>
  ELet([("a",EInteger(5)),
        ("b",EInteger(20))],
       ELet([("a",EId("b")),
             ("b",EId("a"))],
            EPrimCall("-",[EId("a"),EId("b")])))
</pre>
  
<pre class="code">
>>> ELet([("a",EInteger(99))],EId("a")).eval(INITIAL_PRIM_DICT).value
99
>>> ELet([("a",EInteger(99)),
          ("b",EInteger(66))],EId("a")).eval(INITIAL_PRIM_DICT).value
99
>>> ELet([("a",EInteger(99)),
          ("b",EInteger(66))],EId("b")).eval(INITIAL_PRIM_DICT).value
66
>>> ELet([("a",EInteger(99))],
         ELet([("a",EInteger(66)),
               ("b",EId("a"))],
              EId("a"))).eval(INITIAL_PRIM_DICT).value
66
>>> ELet([("a",EInteger(99))],
         ELet([("a",EInteger(66)),
               ("b",EId("a"))],
              EId("b"))).eval(INITIAL_PRIM_DICT).value
99
>>> ELet([("a",EInteger(5)),
          ("b",EInteger(20))],
         ELet([("a",EId("b")),
               ("b",EId("a"))],
              EPrimCall("-",[EId("a"),EId("b")]))).eval(INITIAL_PRIM_DICT).value
15
</pre>
	  </li>

	  <li> <p>Another common local binding special form is
	      sequential bindings, sometimes written <tt>let*</tt>.
	    Intuitively, it lets you bundle
	    bindings together just like we did in the previous
	    question, except that instead of being interpreted "all at
	      once", they are interpreted one after the other.
	    </p>

	    <p>For instance, again using surface syntax similar to
	      what we used in class, we could write
<pre>
  let* (x = 10, y = 20, z = 30)
    (x+y)*z
</pre>
which would evaluate the same as if we had written
<pre>
  let (x = 10)
    let (y = 20)
      let (z = 30)
        (x+y)*z
</pre>
which of course still evaluates to 900. The expression
<pre>
  let (b = 10)
    let* (a = b, b = a)
      a - b
</pre>
would evaluate to 0, since it should be equivalent to writing
<pre>
  let (b = 10)
    let (a = b)
      let (b = a)
        a - b
</pre>
</p>

	    <p>Implement an expression node <tt>ELetS</tt> that takes
	      two arguments, just like your revised <tt>ELet</tt> from
	      last question.
  <ul>
    <li> A list of pairs representing the bindings, each pair of the
      form <tt>(id,exp)</tt> where <tt>id</tt> is a string
      representing the name of an identifier being bound,
      and <tt>exp</tt> the expression that identifier is bound to</li>
    <li> the expression to evaluate in the context of those bindings,
      and that will be the result of evaluating the <tt>ELet</tt>
      expression as a whole.</li>
  </ul>
	    </p>

  <p>Make sure you implement all the methods needed by the Expression
    interface, namely <tt>eval()</tt> and <tt>substitute()</tt>.
	    </p>
    
<pre class="code">
>>> ELetS([("a",EInteger(99))],EId("a")).eval(INITIAL_PRIM_DICT).value
99
>>> ELetS([("a",EInteger(99)),
           ("b",EInteger(66))],EId("a")).eval(INITIAL_PRIM_DICT).value
99
>>> ELetS([("a",EInteger(99)),
           ("b",EInteger(66))],EId("b")).eval(INITIAL_PRIM_DICT).value
66
>>> ELet([("a",EInteger(99))],
         ELetS([("a",EInteger(66)),
                ("b",EId("a"))],
               EId("a"))).eval(INITIAL_PRIM_DICT).value
66
>>> ELet([("a",EInteger(99))],
         ELetS([("a",EInteger(66)),
                ("b",EId("a"))],
               EId("b"))).eval(INITIAL_PRIM_DICT).value
66
>>> ELetS([("a",EInteger(5)),
           ("b",EInteger(20))],
          ELetS([("a",EId("b")),
                 ("b",EId("a"))],
                EPrimCall("-",[EId("a"),EId("b")]))).eval(INITIAL_PRIM_DICT).value
0
</pre>
	  </li>

<li> <p><b>Extra:</b> There's another way to implement evaluation for <tt>ELetS</tt>,
    and that's not to implement it at all! We saw that <tt>ELetS</tt>
    is basically equivalent to a bunch of nested <tt>ELet</tt>. So one
    possibility is to take our abstract representation
    with <tt>ELetS</tt>s inside, and rewrite it so that we <i>expand
      out</i> every <tt>ELetS</tt> into an equivalent expression made
    up of nested <tt>ELet</tt>. 
  </p>

  <p>Thus, the abstract representation for:
<pre>
  let (b = 10)
    let* (a = b, b = a)
      a - b
</pre>
can be rewritten into the abstract representation for:
<pre>
  let (b = 10)
    let (a = b)
      let (b = a)
        a - b
</pre>
and the result evaluated.
  </p>

<p>
    Add a
    method <tt>expand()</tt> to Expressions that <i>returns a new
    expression</i> in which every <tt>ELetS</tt> has been expanded out
    into an equivalent sequence of <tt>ELet</tt>.
</p>

<pre class="code">
>>> print(ELetS([("a",EInteger(99))],EId("a")).expand())
ELet([(a,EInteger(99))],EId(a))
>>> print(ELetS([("a",EInteger(99)),
                 ("b",EInteger(66))],EId("a")).expand())
ELet([(a,EInteger(99))],
     ELet([(b,EInteger(66))],
          EId(a)))
>>> print(ELetS([("a",EInteger(99)),
                 ("b",EInteger(66))],EId("b")).expand())
ELet([(a,EInteger(99))],
     ELet([(b,EInteger(66))],
          EId(b)))
>>> print(ELet([("a",EInteger(99))],
               ELetS([("a",EInteger(66)),
                      ("b",EId("a"))],
                     EId("a"))).expand())
ELet([(a,EInteger(99))],
     ELet([(a,EInteger(66))],
          ELet([(b,EId(a))],
               EId(a))))
>>> print(ELet([("a",EInteger(99))],
               ELetS([("a",EInteger(66)),
                      ("b",EId("a"))],
                     EId("b"))).expand())
ELet([(a,EInteger(99))],
     ELet([(a,EInteger(66))],
          ELet([(b,EId(a))],
               EId(b))))
>>> print(ELetS([("a",EInteger(5)),
                 ("b",EInteger(20))],
                ELetS([("a",EId("b")),
                       ("b",EId("a"))],
                      EPrimCall("-",[EId("a"),EId("b")]))).expand())
ELet([(a,EInteger(5))],
     ELet([(b,EInteger(20))],
          ELet([(a,EId(b))],
               ELet([(b,EId(a))],
                    EPrimCall(-,[EId(a),EId(b)])))))
>>> ELetS([("a",EInteger(5)),
           ("b",EInteger(20))],
          ELetS([("a",EId("b")),
                 ("b",EId("a"))],
                EPrimCall("-",[EId("a"),EId("b")]))).expand().eval(INITIAL_PRIM_DICT).value
0
</pre>
	  </li>

	</ol>
</li>




<li> <p><b>Alternative Evaluation Models for Let</b></p>

	<ol class="letter">

	  <li><p>The way we evaluate a <tt>let</tt> using the
	  substitution model we saw in class may feel a bit
	      wasteful.</p>

	    <p>For instance, an expression such as 
<pre>
  let (a = <i>&lt;some large expression X&gt;</i>)
    <i>&lt;E&gt;</i>
</pre>
where <tt><i>&lt;E&gt;</i></tt> is some expression with several <tt>a</tt>s
appearing in it, will evaluate by substituting the large
expression <tt><i>X</i></tt> for
every single <tt>a</tt>. This means that evaluating the resulting body
of the <tt>let</tt> will require us to evaluate over and over again
the large expression <tt><i>X</i></tt>.
	    </p>

	    <p>Here is one alternative. We introduce a new kind of
	    let-binding, <tt>letv</tt>. To evaluate an expression
<pre>
  letv (x = e1) e2
</pre>
instead of simply substituting <tt>e1</tt> for every occurrence
of identifier <tt>x</tt> in <tt>e2</tt>, we first evaluate <tt>e1</tt>
down to a value <tt>v</tt>, and then substitute <tt>v</tt> for every
occurrence of <tt>x</tt> in <tt>e2</tt>, evaluating the result. This
kind of evaluation is called <i>eager</i> (whereas the
original one, based on a straight up substitution, is
called <i>lazy</i> &mdash; can you see where the terms might come
from?). </p>

	    <p>Add an Expression node <tt>ELetV</tt> to the abstract
	    representation which implements the eager evaluation described
	    in the previous paragraph. <del>Make it as in Q1(a) above,
	    allowing it to handle multiple simultaneous
	      bindings. Thus, <tt>ELetV</tt> should take two
	    arguments, a list of pairs (each a pair of an identifier
	    name and an expression) and an expression (the body of the
		let).</del> <ins>For simplicity, implement <tt>ELetV</tt> so that it deals with a single binding, just like the original <tt>ELet</tt> I 
gave in class did. Thus, <tt>ELetV</tt> should take three arguments: a string indicated the name of the identifier in the binding, an expression to be bound, and an expression to evaluate in the context of that binding for the identifier.</ins></p>

<p>(There is a trickiness to implementing eager evaluation, which I hope you will notice. Make
  whatever modification to the abstract representation you feel you
  need to.)</p>

<pre class="code">
# The tests are particularly uninteresting
# Basically, ELetV should evaluate just like ELet

>>> ELetV("a",EInteger(10),EId("a")).eval(INITIAL_PRIM_DICT).value
10
>>> ELetV("a",EInteger(10),
          ELetV("b",EInteger(20),EId("a"))).eval(INITIAL_PRIM_DICT).value
10
>>> ELetV("a",EInteger(10),
          ELetV("a",EInteger(20),EId("a"))).eval(INITIAL_PRIM_DICT).value
20
>>> ELetV("a",EPrimCall("+",[EInteger(10),EInteger(20)]),
          ELetV("b",EInteger(20),EId("a"))).eval(INITIAL_PRIM_DICT).value
30
>>> ELetV("a",EPrimCall("+",[EInteger(10),EInteger(20)]),
          ELetV("b",EInteger(20),
                EPrimCall("*",[EId("a"),EId("a")]))).eval(INITIAL_PRIM_DICT).value
900
</pre>

	    <p><i>Meditation question: is there any other difference
	    between eager evaluation and lazy evaluation aside from
	      the fact that one seems to do less work? Can they
	      actually behave differently, or return different
		results?</i></p>

	  </li>

	  <li> <p><b>Extra:</b> Here is yet another way of
	  implementing evaluation, midway between the full lazy
	      evaluation presented in class and the eager evaluation
	  for <tt>ELetV</tt> in the previous question. Consider a new
	  kind of let-binding we could write:
<pre>
  letn (x = e1) e2
</pre>	      
which evaluates as follows: you substitute <tt>e1</tt> for <tt>x</tt>
in <tt>e2</tt> in more or less the usual way, but you make it so that
the first time you ever evaluate an <tt>e1</tt> in the course of
evaluating the substituted body <tt>e2</tt>, you remember the value
<tt>v</tt> that <tt>e1</tt> evaluates to so that if ever find yourself
needing to evaluate <tt>e1</tt> again elsewhere in <tt>e2</tt>, you
can just use <tt>v</tt> without needing to re-evaluate that new
occurrence of <tt>e2</tt>. Basically, you pay the cost of
evaluating <tt>e1</tt> at most once (but you may never pay it if you
never need to evaluate <tt>e1</tt>). </p>

<p>Add an Expression node <tt>ELetN</tt> to the abstract
	    representation which implements this third kind of
	    evaluation, described
	    in the previous paragraph. <del>Make it as in Q1(a) above,
	    allowing it to handle multiple simultaneous
	      bindings. Thus, <tt>ELetN</tt> should take two
	    arguments, a list of pairs (each a pair of an identifier
	    name and an expression) and an expression (the body of the
  let).</del> <ins>For simplicity, implement <tt>ELetN</tt> so that it deals with a single binding, just like the original <tt>ELet</tt> I 
gave in class did. Thus, <tt>ELetN</tt> should take three arguments: a string indicated the name of the identifier in the binding, an expression to be bound, and an expression to evaluate in the context of that binding for the identifier.</ins></p>

	    <p>Note that there are <i>many</i> ways of implementing
	      this. I'd like to see what you come up with.</p>

<pre class="code">
# Again, the tests are particularly uninteresting
# Basically, ELetN should evaluate just like ELet

>>> ELetN("a",EInteger(10),EId("a")).eval(INITIAL_PRIM_DICT).value
10
>>> ELetN("a",EInteger(10),
          ELetN("b",EInteger(20),EId("a"))).eval(INITIAL_PRIM_DICT).value
10
>>> ELetN("a",EInteger(10),
          ELetN("a",EInteger(20),EId("a"))).eval(INITIAL_PRIM_DICT).value
20
>>> ELetN("a",EPrimCall("+",[EInteger(10),EInteger(20)]),
          ELetN("b",EInteger(20),EId("a"))).eval(INITIAL_PRIM_DICT).value
30
>>> ELetN("a",EPrimCall("+",[EInteger(10),EInteger(20)]),
          ELetN("b",EInteger(20),
                EPrimCall("*",[EId("a"),EId("a")]))).eval(INITIAL_PRIM_DICT).value
900
</pre>


	  </li>

	</ol>
</li>

<li> <p><b>Defined Functions</b></p>
  
<p>In this question, we'll add defined functions to our
    language that can be called during the evaluation of an
    expression. In contrast with primitive operations, which are
    implemented in Python (our implementation language), defined
    functions are defined with our language itself.</p>

      <p>A defined function is represented as a
	dictionary <tt>{"params":<i>L</i>, "body":<i>exp</i>}</tt>
	where <tt><i>L</i></tt> is a list of parameter names (the
	parameters to the function) and <tt><i>exp</i></tt> is an
	expression (in our abstract representation) representing the body of the function which gets
	evaluated to return a result from the function.</p>

      <p>For example, here is the definition of a function to add one
	to its input:
<pre>
  { 
    "params": ["x"],
    "body": EPrimCall("+",[EId("x"),EInteger(1)])
  }
</pre>
while here is the definition of a function that squares its input:
<pre>
  {
    "params": ["y"],
    "body": EPrimCall("*",[EId("y"),EId("y")])
  }
</pre>
More interesting examples may require additional primitive
operations, because you're limited in what you can do with only basic
arithmetic. If you have a primitive operation "zero?" that tests whether
an integer is zero (it's easy enough to add to the primitive
dictionary) you can define an equality function as follows:
<pre>
  { 
    "params": ["a","b"],
    "body": EPrimCall("zero?",[EPrimCall("-",[EId("a"),EId("b")])])
  }
</pre>

<p>To use defined functions, we need a way to call them with arguments.</p>

      <p>Your main task is to add a new Expression node <tt>ECall</tt>
	to the abstract representation. <tt>ECall</tt> looks very much
	like <tt>EPrimCall</tt>: it takes two arguments, the name of a
	function to call, and a list of expressions corresponding to
	the arguments of the function call. Evaluating a function
	call requires looking up the function definition,
	substituting the argument expressions for the corresponding
	parameters in the body of the function, and evaluating the
	body.</p>

      <p>Where do we look up the function definition? We're going to
      use the same trick we used with primitive operations. We are
      going to use a dictionary which we'll call the functions
      dictionary and which will map function names to function
      definitions (where a function definition is a dictionary as
      above, with keys <tt>params</tt> and <tt>body</tt>). Thus, here
      is a functions dictionary containing the above definitions, with
      reasonable names:
<pre>
  { "+1": { 
             "params": ["x"],
             "body": EPrimCall("+",[EId("x"),EInteger(1)])
           },
    "square: {
               "params": ["y"],
               "body": EPrimCall("*",[EId("y"),EId("y")])
             },
    "=": {
           "params": ["a","b"],
           "body": EPrimCall("zero?",[EPrimCall("-",[EId("a"),EId("b")])])
         }
  }
</pre>
</p>

<p>We will pass such a function dictionary at the same time as
  the primitive dictionary, in every <tt>eval()</tt>
  call. Thus, <tt>eval()</tt> will now take two arguments, the
  primitives dictionary, and the functions dictionary.
</p>

<pre class="code">
# here's a function dictionary
>>> FUN_DICT = {
      "square": {"params":["x"],
                 "body":EPrimCall("*",[EId("x"),EId("x")])},
      "=": {"params":["x","y"],
            "body":EPrimCall("zero?",[EPrimCall("-",[EId("x"),EId("y")])])},
      "+1": {"params":["x"],
             "body":EPrimCall("+",[EId("x"),EValue(VInteger(1))])},
      "sum_from_to": {"params":["s","e"],
                      "body":EIf(ECall("=",[EId("s"),EId("e")]),
                                 EId("s"),
                                 EPrimCall("+",[EId("s"),
                                                ECall("sum_from_to",[ECall("+1",[EId("s")]),
                                                                     EId("e")])]))}
    }

>>> ECall("inc",
          [EInteger(100)]).eval(INITIAL_PRIM_DICT,FUN_DICT).value
101
>>> ECall("inc",
          [EPrimCall("+",[EInteger(100),EInteger(200)])]).eval(INITIAL_PRIM_DICT,FUN_DICT).value
301
>>> ECall("inc",
          [ECall("inc",
                 [EInteger(100)])]).eval(INITIAL_PRIM_DICT,FUN_DICT).value
102
>>> ECall("=",[EInteger(1),EInteger(2)]).eval(INITIAL_PRIM_DICT,FUN_DICT).value
False
>>> ECall("=",[EInteger(1),EInteger(1)]).eval(INITIAL_PRIM_DICT,FUN_DICT).value
True
>>> ECall("sum_from_to",[EInteger(0),EInteger(10)]).eval(INITIAL_PRIM_DICT,FUN_DICT).value
55
</pre>

</li>

    </ol>
    

  </body>
</html>

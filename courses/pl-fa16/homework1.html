<!DOCTYPE html>
<html>

  <head>
    
    <meta charset="utf-8">
    <title>Homework 1</title>

    <link rel="stylesheet" href="alt.css" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,800,700' rel='stylesheet' type='text/css'>

    <script src="autoscroll.js"></script>
    
    <style>

      hr { margin-top: 50px; }

        code,tt,pre {
          font-size: 130%;
        }
	
        div.lect {
	  padding-top: 0;
       	  padding-left: 3em;
	  margin-top:0;
        }
    	p.ann { 
    	  padding-left: 3em;
    	  text-indent: -3em; 
    	}
	p.ann_ctd{
	  padding-left: 3em;
        }
    	span.hdr {
   	  padding-right: 1em
    	}

	.hidden {
	  visibility: hidden;
        }

        tt.code {
           background: #e6e6e6;
        }

	pre.code {
	   border: 1px solid #c6c6c6;
	border-radius: 5px;
	padding: 10px;
	font-size:100%;
	}

/* from
    http://www.456bereastreet.com/archive/201105/styling_ordered_list_numbers/
 */

ol {
    counter-reset:li; /* Initiate a counter */
    margin-left:0; /* Remove the default left margin */
    padding-left:0; /* Remove the default left padding */
    padding-top:1em;
}
ol > li {
    position:relative; /* Create a positioning context */
    margin:0 0 6px 2em; /* Give each list item a left margin to make
    room for the numbers */
    padding:4px 8px; /* Add some spacing around the content */
    list-style:none; /* Disable the normal item numbering */
    /*border-top:2px solid #666;
    background:#f6f6f6; */
}
ol > li:before {
    counter-increment:li; /* Increment the counter by 1 */
    /* Position and style the number */
    position:absolute;
    top:-2px;
    left:-2em;
    -moz-box-sizing:border-box;
    -webkit-box-sizing:border-box;
    box-sizing:border-box;
    width:2em;
    /* Some space between the number and the content in browsers that
    support
       generated content but not positioning it (Camino 2 is one
    example) */
    margin-right:8px;
    padding:4px;
/*    border-top:2px solid #666;
    color:#fff;
    background:#666; 
    font-weight:bold; */
/*    font-family:"Helvetica Neue", Arial, sans-serif;
    text-align:center; */
}

ol.letter > li:before {
    content:"(" counter(li,lower-alpha) ")"; /* Use the counter as content */
}

ol.number > li:before {
    content:"(" counter(li,decimal) ")"; /* Use the counter as content */
}

li ol,
li ul {margin-top:6px;}

li > p { margin-top:0;}

    </style>

  </head>


  <body>

    <div class="navbar">

      <div class="home">
	<a href="../../index.html"><img src="../../home.png" style="height: 1.6em;"></a>
      </div>

      <ul>
	<li><a href="index.html"><b>Programming Languages FA16</b></a></li> 
	<li class="hidden"><a class="scrollto" href="#announcements">Announcements</a></li>
	<li class="hidden"><a class="scrollto" href="#info">Course Info</a></li>
	<li class="hidden"><a class="scrollto" href="#lectures">Lectures</a></li>
	<li class="hidden"><a class="scrollto" href="#homeworks">Homeworks</a></li>
      </ul>
    </div>


    <!-- padding -->
    <div id="top" style="height: 7em;"></div>
    
    <h1 class="clear">Homework 1</h1>
    
    <p class="subtitle">Due date: Monday, Sep 12 (11:59:59pm)</p>


    <p><b>Note on integrity:</b> This homework is meant to be done in teams of two. 
    You may discuss problems with fellow students, but
    all work must be entirely that of your team, and should not be from any
    other course, present, past, or future. If you use a solution from
    another source you must cite it &mdash; this includes when that source
      is someone else helping you.</p>

    <p>Every source file you submit should begin with a block comment
      that lists <span style="text-decoration:underline;">the members of your team</span>, your <span style="text-decoration:underline;">email addresses</span>, and any <span style="text-decoration:underline;">remarks</span> that you
      wish to make to the instructor.</p>

    <p>All programming is to be done in Python 2.7.</p>

    <p>Feel free to define helper functions if you need them.</p>

    <p>Please code your answers by modifying the
      file <a href="homework1.py"><tt>homework1.py</tt></a>
      provided.</p>

    <p>Questions marked <b>Extra</b> are optional. You do not have to
    do them. But will give you more practice and sometimes more
      insight into what is going on. Plus some of them are fun.</p>

    <p>Electronic submission instructions:</p>

    <ul>
      <li>Send an email with your file <tt>homework1.py</tt> as an attachment to <tt>pl.fa16.olin@gmail.com</tt> with subject <i>Homework 1 submission</i>. Only one email per team, please.</li>
    </ul>

    <hr>
    
    <ol class="number">

      <li> <p><b>Boolean Operations</b></p>

	<ol class="letter">

	  <li><p>Add an expression <tt class="code">EIsZero</tt> to
	  the abstract representation that takes an
	  expression <i>e</i> and evaluates to true if <i>e</i>
	  evaluates to integer 0, and to false if <i>e</i> evaluates
	      to an integer different from 0.</p>

	    <pre class="code">
>>> EIsZero(EInteger(0)).eval().value
True
>>> EIsZero(EInteger(1)).eval().value
False
>>> EIsZero(EInteger(9)).eval().value
False
>>> EIsZero(EInteger(-1)).eval().value
False
>>> EIsZero(EPlus(EInteger(1),EInteger(1))).eval().value
False
>>> EIsZero(EMinus(EInteger(1),EInteger(1))).eval().value
True
</pre>
	  </li>

	  <li> <p>Add
	    expressions <tt class="code">EAnd</tt>, <tt class="code">EOr</tt>,
	      and <tt class="code">ENot</tt> to the abstract
	    representation corresponding to the Boolean operations
	      of the same name. <tt>EAnd</tt> and <tt>EOr</tt> are
	      binary operations (they take two subexpressions)
	    while <tt>ENot</tt> is a unary operation (taking a single
	      subexpression). They should evaluate to the Boolean value
	      corresponding to applying the appropriate logical operator to
	      the result of evaluating the subexpressions.</p>
	      
	    <pre class="code">
>>> tt = EBoolean(True)
>>> ff = EBoolean(False)

>>> EAnd(tt,tt).eval().value
True
>>> EAnd(tt,ff).eval().value
False
>>> EAnd(ff,tt).eval().value
False
>>> EAnd(ff,ff).eval().value
False
>>> EOr(tt,tt).eval().value
True
>>> EOr(tt,ff).eval().value
True
>>> EOr(ff,tt).eval().value
True
>>> EOr(ff,ff).eval().value
False
>>> ENot(tt).eval().value
False
>>> ENot(ff).eval().value
True
>>> EAnd(EOr(tt,ff),EOr(ff,tt)).eval().value
True
>>> EAnd(EOr(tt,ff),EOr(ff,ff)).eval().value
False
>>> EAnd(tt,ENot(tt)).eval().value
False
>>> EAnd(tt,ENot(ENot(tt))).eval().value
True
</pre>
	  </li>

	  <li> <p><b>Extra:</b> Implement the evaluation
	      of <tt>EAnd</tt> and <tt>EOr</tt> so that they
	      are <a href="https://en.wikipedia.org/wiki/Short-circuit_evaluation">short-circuiting</a>.
	    </p>

	    <pre class="code">
>>> tt = EBoolean(True)
>>> ff = EBoolean(False)

>>> EAnd(ff,EInteger(10)).eval().value
False
>>> EAnd(ff,EInteger(0)).eval().value
False
>>> EOr(tt,EInteger(10)).eval().value
True
>>> EOr(tt,EInteger(0)).eval().value
True
</pre>
	  </li>

	</ol>
      </li>



      <li> <p><b>Vectors</b></p>

	<ol class="letter">

	  <li><p>Add a new class of
	  values <tt class="code">VVector</tt> to the abstract
	  representation, corresponding to vectors of values. Instead
	      of a <tt>value</tt> field, an instance
	      of <tt>VVector</tt> has a field <tt>length</tt> holding
	      the length of the vector, and a method <tt>get(<i>n</i>)</tt>
	  which can be used to get the <i>n</i>th value of the vector.
	      The first element of a vector is at position 0. </p>

	    <pre class="code">
>>> VVector([]).length
0
>>> VVector([VInteger(10),VInteger(20),VInteger(30)]).length
3
>>> VVector([VInteger(10),VInteger(20),VInteger(30)]).get(0).value
10
>>> VVector([VInteger(10),VInteger(20),VInteger(30)]).get(1).value
20
>>> VVector([VInteger(10),VInteger(20),VInteger(30)]).get(2).value
30
</pre>
	  </li>

	  <li><p>Add an expression <tt class="code">EVector</tt> to
	  the abstract representation which takes a list of
	      expressions <i>e<sub>1</sub></i>,
	  ..., <i>e<sub>n</sub></i> and evaluates to the vector
	      made up of the result of
	      evaluating each of <i>e<sub>1</sub></i>,
	      ..., <i>e<sub>n</sub></i>. </p>

	    <pre class="code">
>>> EVector([]).eval().length
0
>>> EVector([EInteger(10),EInteger(20),EInteger(30)]).eval().length
3
>>> EVector([EInteger(10),EInteger(20),EInteger(30)]).eval().get(0).value
10
>>> EVector([EInteger(10),EInteger(20),EInteger(30)]).eval().get(1).value
20
>>> EVector([EInteger(10),EInteger(20),EInteger(30)]).eval().get(2).value
30
>>> EVector([EPlus(EInteger(1),EInteger(2)),EInteger(0)]).eval().length
2
>>> EVector([EPlus(EInteger(1),EInteger(2)),EInteger(0)]).eval().get(0).value
3
>>> EVector([EPlus(EInteger(1),EInteger(2)),EInteger(0)]).eval().get(1).value
0
>>> EVector([EBoolean(True),EAnd(EBoolean(True),EBoolean(False))]).eval().length
2
>>> EVector([EBoolean(True),EAnd(EBoolean(True),EBoolean(False))]).eval().get(0).value
True
>>> EVector([EBoolean(True),EAnd(EBoolean(True),EBoolean(False))]).eval().get(1).value
False
</pre>
	  </li>

	      <li> <p>Extend the evaluation
		  of <tt>EPlus</tt>, <tt>EMinus</tt>, <tt>EAnd</tt>, <tt>EOr</tt>,
		  and <tt>ENot</tt> so that if given expressions
		  evaluating to vectors, they apply the corresponding
		  operations 
		  pointwise to the components of the
		  vectors. Thus, <tt>EPlus</tt> will compute vector
		  addition, <tt>EMinus</tt> vector
		  subtraction, and so on.</p>
	      
	    <pre class="code">
>>> def pair (v): return (v.get(0).value,v.get(1).value)

>>> v1 = EVector([EInteger(2),EInteger(3)])
>>> v2 = EVector([EInteger(33),EInteger(66)])

>>> pair(EPlus(v1,v2).eval())
(35, 69)
>>> pair(EMinus(v1,v2).eval())
(-31, -63)

>>> b1 = EVector([EBoolean(True),EBoolean(False)])
>>> b2 = EVector([EBoolean(False),EBoolean(False)])

>>> pair(EAnd(b1,b2).eval())
(False, False)
>>> pair(EOr(b1,b2).eval())
(True, False)
>>> pair(ENot(b1).eval())
(False, True)
</pre>
	  </li>

	      <li> <p>Extend the evaluation of <tt>ETimes</tt> so that
		  if given expressions evaluating to vectors of
		  integers as arguments, it computes the inner product
		  of those vectors.</p>
	      
	    <pre class="code">
>>> v1 = EVector([EInteger(2),EInteger(3)])
>>> v2 = EVector([EInteger(33),EInteger(66)])

>>> ETimes(v1,v2).eval().value
264
>>> ETimes(v1,EPlus(v2,v2)).eval().value
528
>>> ETimes(v1,EMinus(v2,v2)).eval().value
0
	    </pre>
	  </li>

	      <li> <p><b>Extra:</b> Extend the evaluation
		  of <tt>EPlus</tt>, <tt>ETimes</tt>, <tt>EMinus</tt>,
		  <tt>EAnd</tt>, and <tt>EOr</tt> so that when given
	      expressions evaluating to a 
	      vector and a scalar (i.e., an integer or a Boolean), in
	      either order, the
	      corresponding operation is applied to every element of
	      the vector and the scalar, yielding a vector of the results.
	    </p>

	    <pre class="code">
>>> def pair (v): return (v.get(0).value,v.get(1).value)

>>> v1 = EVector([EInteger(2),EInteger(3)])
>>> v2 = EVector([EInteger(33),EInteger(66)])

>>> pair(EPlus(v1,EInteger(100)).eval())
(102, 103)
>>> pair(EPlus(EInteger(100),v1).eval())
(102, 103)
>>> pair(EMinus(v1,EInteger(100)).eval())
(-98, -97)
>>> pair(EMinus(EInteger(100),v1).eval())
(98, 97)
>>> pair(ETimes(v1,EInteger(100)).eval())
(200, 300)
>>> pair(ETimes(EInteger(100),v1).eval())
(200, 300)

>>> pair(EAnd(EVector([EBoolean(True),EBoolean(False)]),EBoolean(True)).eval())
(True, False)
>>> pair(EOr(EVector([EBoolean(True),EBoolean(False)]),EBoolean(True)).eval())
(True, True)
</pre>
	  </li>

	</ol>
      </li>
      

      <li> <p><b>Rational Numbers</b></p>

	<ol class="letter">

	  <li><p>Add a new class of
	  values <tt class="code">VRational</tt> to the abstract
	  representation, corresponding to rational numbers (i.e.,
	      fractions). Instead of a <tt>value</tt> field, an
	      instance of <tt>VRational</tt> has a
	  field <tt>numer</tt> holding the numerator of the rational
	      number, and a field <tt>denom</tt> holding the
	      denominator. </p>

	    <pre class="code">
>>> VRational(1,3).numer
1
>>> VRational(1,3).denom
3
>>> VRational(2,3).numer
2
>>> VRational(2,3).denom
3
</pre>
	  </li>

	  <li><p>Add an expression <tt class="code">EDiv</tt> to
	  the abstract representation which takes two expressions
	  and evaluates to the rational 
	  number obtained by dividing the result of evaluating the
	  first to the result of evaluating the second. Division
	  should work with both integers and rational numbers.</p>

	    <pre class="code">
>>> def rat (v): return "{}/{}".format(v.numer,v.denom)

>>> rat(EDiv(EInteger(1),EInteger(2)).eval())
'1/2'
>>> rat(EDiv(EInteger(2),EInteger(3)).eval())
'2/3'
>>> rat(EDiv(EDiv(EInteger(2),EInteger(3)),EInteger(4)).eval())
'1/6'
>>> rat(EDiv(EInteger(2),EDiv(EInteger(3),EInteger(4))).eval())
'8/3'
</pre>
	  </li>


	  <li><p>Extend the implementation
	  of <tt>EPlus</tt>, <tt>EMinus</tt>, and <tt>ETimes</tt> so
	      that they work with both rationals and integers.
	    </p>

	    <pre class="code">
>>> def rat (v): return "{}/{}".format(v.numer,v.denom)

>>> half = EDiv(EInteger(1),EInteger(2))
>>> third = EDiv(EInteger(1),EInteger(3))

>>> rat(EPlus(half,third).eval())
'5/6'
>>> rat(EPlus(half,EInteger(1)).eval())
'3/2'
>>> rat(EMinus(half,third).eval())
'1/6'
>>> rat(EMinus(half,EInteger(1)).eval())
'-1/2'
>>> rat(ETimes(half,third).eval())
'1/6'
>>> rat(ETimes(half,EInteger(1)).eval())
'1/2'
</pre>
	  </li>

	  <li> <p><b>Extra:</b> Ensure that the rational number
	      obtained by evaluating <tt>EDiv</tt> is in simplified
	      form (i.e., 2/3, instead of 4/6, and 4 instead of 4/1).</p>
	      
	    <pre class="code">
>>> def rat (v): return "{}/{}".format(v.numer,v.denom)

>>> rat(EDiv(EInteger(3),EInteger(6)).eval())
'1/2'
>>> rat(EDiv(EInteger(4),EInteger(6)).eval())
'2/3'
>>> rat(EDiv(EInteger(-4),EInteger(6)).eval())
'-2/3'
>>> rat(EDiv(EInteger(-4),EInteger(-6)).eval())
'2/3'

>>> EDiv(EInteger(2),EInteger(1)).eval()
<__main__.VInteger object at 0x100f5e590>
>>> EDiv(EInteger(2),EInteger(1)).eval().value
2
>>> EDiv(EInteger(4),EInteger(2)).eval()
<__main__.VInteger object at 0x100f5e650>
>>> EDiv(EInteger(4),EInteger(2)).eval().value
2
</pre>
	  </li>

	  <li> <p><b>Extra:</b> Make your code in question 2
	      works with vectors of rational numbers, and extend 
	      <tt>EDiv</tt> so that it works with both vectors and
	      scalars (in any combination, as in 2(c) and 2(e). </p> 
	      
	    <pre class="code">
>>> def rat (v): return "{}/{}".format(v.numer,v.denom)

>>> rat(EPlus(EVector([half,third]),EVector([third,third])).eval().get(0))
'5/6'
>>> rat(EPlus(EVector([half,third]),EVector([third,third])).eval().get(1))
'2/3'
>>> rat(EMinus(EVector([half,third]),EVector([third,third])).eval().get(0))
'1/6'
>>> rat(EMinus(EVector([half,third]),third).eval().get(0))
'1/6'
>>> rat(ETimes(EVector([half,third]),half).eval().get(0))
'1/4'
>>> rat(ETimes(EVector([half,third]),half).eval().get(1))
'1/6'

>>> EDiv(EVector([half,third]),EVector([half,third])).eval().get(0).value
1
>>> EDiv(EVector([half,third]),EVector([half,third])).eval().get(1).value
1
>>> rat(EDiv(EVector([half,third]),EInteger(2)).eval().get(0))
'1/4'
>>> rat(EDiv(EVector([half,third]),EInteger(2)).eval().get(1))
'1/6'
</pre>
	  </li>


	</ol>
      </li>
      
    </ol>
    

  </body>
</html>

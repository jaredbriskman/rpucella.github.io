<html>
  <body>
    <pre>
############################################################
# Some solutions to homework 2
#



#
# Expressions
#

class Exp (object):
    pass


class EInteger (Exp):
    # Integer literal

    def __init__ (self,i):
        self._integer = i

    def __str__ (self):
        return "EInteger({})".format(self._integer)

    def eval (self,prim_dict,fun_dict):
        return VInteger(self._integer)

    def substitute (self,id,new_e):
        return self

    def expand (self):
        return self


class EBoolean (Exp):
    # Boolean literal

    def __init__ (self,b):
        self._boolean = b

    def __str__ (self):
        return "EBoolean({})".format(self._boolean)

    def eval (self,prim_dict,fun_dict):
        return VBoolean(self._boolean)

    def substitute (self,id,new_e):
        return self

    def expand (self):
        return self


class EPrimCall (Exp):

    def __init__ (self,name,es):
        self._name = name
        self._exps = es

    def __str__ (self):
        return "EPrimCall({},[{}])".format(self._name,",".join([ str(e) for e in self._exps]))

    def eval (self,prim_dict,fun_dict):
        vs = [ e.eval(prim_dict,fun_dict) for e in self._exps ]
        return apply(prim_dict[self._name],vs)

    def substitute (self,id,new_e):
        new_es = [ e.substitute(id,new_e) for e in self._exps]
        return EPrimCall(self._name,new_es)

    def expand (self):
        return EPrimCall(self._name,[ e.expand() for e in self._exps])


class EIf (Exp):
    # Conditional expression

    def __init__ (self,e1,e2,e3):
        self._cond = e1
        self._then = e2
        self._else = e3

    def __str__ (self):
        return "EIf({},{},{})".format(self._cond,self._then,self._else)

    def eval (self,prim_dict,fun_dict):
        v = self._cond.eval(prim_dict,fun_dict)
        if v.type != "boolean":
            raise Exception ("Runtime error: condition not a Boolean")
        if v.value:
            return self._then.eval(prim_dict,fun_dict)
        else:
            return self._else.eval(prim_dict,fun_dict)

    def substitute (self,id,new_e):
        return EIf(self._cond.substitute(id,new_e),
                   self._then.substitute(id,new_e),
                   self._else.substitute(id,new_e))

    def expand (self):
        return EIf(self._cond.expand(),
                   self._then.expand(),
                   self._else.expand())


class ELet (Exp):
    # local binding
    # QUESTION 1(a): extending let with multiple simultaneous bindings

    def __init__ (self,bindings,e2):
        self._bindings = bindings
        self._e2 = e2

    def __str__ (self):
        return "ELet([{}],{})".format(",".join([ "({},{})".format(id,str(exp)) for (id,exp) in self._bindings ]),self._e2)

    def eval (self,prim_dict,fun_dict):
        # by this point, all substitutions in bindings expressions have happened already (!)
        new_e2 = self._e2
        for (id,e) in self._bindings:
            new_e2 = new_e2.substitute(id,e)
        return new_e2.eval(prim_dict,fun_dict)

    def substitute (self,id,new_e):
        new_bindings = [ (bid,be.substitute(id,new_e)) for (bid,be) in self._bindings]
        if id in [ bid for (bid,_) in self._bindings]:
            return ELet(new_bindings, self._e2)
        return ELet(new_bindings, self._e2.substitute(id,new_e))

    def expand (self):
        return ELet([ (id,e.expand()) for (id,e) in self._bindings],
                    self._e2.expand())


class ELetS (Exp):
    # QUESTION 1(b): sequential multiple bindings

    def __init__ (self,bindings,e2):
        self._bindings = bindings
        self._e2 = e2

    def __str__ (self):
        return "ELetS([{}],{})".format(",".join([ "({},{})".format(id,str(exp)) for (id,exp) in self._bindings ]),self._e2)

    def eval (self,prim_dict,fun_dict):
        # by this point, all substitutions in bindings expressions have happened already (!)

        # helper function: apply a binding substitution to a list of 
        # bindings until the first binding that binds the same identifier
        
        def substitute_in_bindings (id,e,bindings):

            result = []
            # loop over all bindings
            for index in range(0,len(bindings)):
                # grab first binding
                (curr_id,curr_e) = bindings[index]
                # perform the substitution
                result.append((curr_id,curr_e.substitute(id,e)))
                # if blocking, then the rest of the bindings are unaffected
                if curr_id == id:
                    return result.extend(bindings[(index+1):])
            return result

        new_e2 = self._e2

        bindings = self._bindings
        while bindings:
            # grab first binding
            (id,e) = bindings[0]
            # apply binding substitution to rest of the bindings
            # this is going to be the new bindings for the next iteration
            bindings = substitute_in_bindings(id,e,bindings[1:])
            # apply binding substitution to body unless blocked by 
            # a binding later in the binding list
            if id in [ curr_id for (curr_id,_) in bindings]:
                new_e2 = new_e2
            else:
                new_e2 = new_e2.substitute(id,e)

        return new_e2.eval(prim_dict,fun_dict)

    def substitute (self,id,new_e):
        blocked = False
        new_bindings = []
        for (bid,be) in self._bindings:
            if blocked:     # we got blocked in a previous binding in the same ELetS
                new_bindings.append((bid,be))
            elif id == bid:   # rest is blocked!
                new_bindings.append((bid,be.substitute(id,new_e)))
                blocked = True
            else:
                new_bindings.append((bid,be.substitute(id,new_e)))
            
        if blocked:
            return ELetS(new_bindings, self._e2)
        return ELetS(new_bindings, self._e2.substitute(id,new_e))


    # QUESTION 1(c): expanding ELetS into nested ELet
    #                expand() method in every Exp node
    def expand (self):
        result = self._e2.expand()
        for (id,e) in reversed(self._bindings):
            result = ELet([(id,e)],result)
        return result



class ELetV (Exp):
    # QUESTION 2(a): eager let binding
    

    def __init__ (self,id,e1,e2):
        self._id = id
        self._e1 = e1
        self._e2 = e2

    def __str__ (self):
        return "ELetV({},{},{})".format(self._id,self._e1,self._e2)

    def eval (self,prim_dict,fun_dict):
        v = self._e1.eval(prim_dict,fun_dict)
        new_e2 = self._e2.substitute(self._id,EValue(v))
        return new_e2.eval(prim_dict,fun_dict)

    def substitute (self,id,new_e):
        if id == self._id:
            return ELetV(self._id,
                         self._e1.substitute(id,new_e),
                         self._e2)
        return ELetV(self._id,
                     self._e1.substitute(id,new_e),
                     self._e2.substitute(id,new_e))

    def expand (self):
        return ELetV(self._id,
                     self._e1.expand(),
                     self._e2.expand())



class ELetN (Exp):
    # QUESTION 2(b): local binding (by need)
    

    def __init__ (self,id,e1,e2):
        self._id = id
        self._e1 = e1
        self._e2 = e2

    def __str__ (self):
        return "ELetN({},{},{})".format(self._id,self._e1,self._e2)

    def eval (self,prim_dict,fun_dict):
        new_e2 = self._e2.substitute(self._id,ECached(self._e1))
        return new_e2.eval(prim_dict,fun_dict)

    def substitute (self,id,new_e):
        if id == self._id:
            return ELetN(self._id,
                         self._e1.substitute(id,new_e),
                         self._e2)
        return ELetN(self._id,
                     self._e1.substitute(id,new_e),
                     self._e2.substitute(id,new_e))
    
    def expand (self):
        return ELetN(self._id,
                     self._e1.expand(),
                     self._e2.expand())

class ECached (Exp):
    # cached expression
    # initially an expression
    # when you evaluate it once, it caches the resulting value
    # subsequent evaluation will deliver the cached value instead

    def __init__ (self,e):
        self._exp = e
        self._cached_value = None
    
    def __str__ (self):
        return "ECached({})".format(str(self._exp))

    def eval (self,prim_dict,fun_dict):
        if self._cached_value:
            return self._cached_value
        v = self._exp.eval(prim_dict,fun_dict)
        self._cached_value = v
        return v

    def substitute (self,id,new_e):
        # watch out! make sure we return the exact
        # same object we started with so that we don't
        # break any sharing (that's what makes caching works)
        
        self._exp = self._exp.substitute(id,new_e)
        return self

    def expand (self):
        # watch out! make sure we return the exact
        # same object we started with so that we don't
        # break any sharing (that's what makes caching works)

        self._exp = self._exp.expand()
        return self
    


class EValue (Exp):
    # Value literal (could presumably replace EInteger and EBoolean)
    def __init__ (self,v):
        self._value = v
    
    def __str__ (self):
        return "EValue({})".format(self._value)

    def eval (self,prim_dict,fun_dict):
        return self._value

    def substitute (self,id,new_e):
        return self

    def expand (self):
        return self



class EId (Exp):
    # identifier

    def __init__ (self,id):
        self._id = id

    def __str__ (self):
        return "EId({})".format(self._id)

    def eval (self,prim_dict,fun_dict):
        raise Exception("Runtime error: unknown identifier {}".format(self._id))

    def substitute (self,id,new_e):
        if id == self._id:
            return new_e
        return self

    def expand (self):
        return self



class ECall (Exp):
    # QUESTION 3: implementing defined function calls (eager)

    def __init__ (self,name,es):
        self._name = name
        self._exps = es

    def __str__ (self):
        return "ECall({},{})".format(self._name,self._exps)

    def eval (self,prim_dict,fun_dict):
        vs = [ e.eval(prim_dict,fun_dict) for e in self._exps ]
        params = fun_dict[self._name]["params"]
        body = fun_dict[self._name]["body"]
        if len(params) != len(vs):
            raise Exception("Runtime error: wrong number of argument calling function {}".format(self._name))
        for (val,p) in zip(vs,params):
            body = body.substitute(p,EValue(val))
        return body.eval(prim_dict,fun_dict)

    def substitute (self,var,new_e):
        new_es = [ e.substitute(var,new_e) for e in self._exps]
        return ECall(self._name,new_es)

    def expand (self):
        return ECall(self._name,[ e.expand() for e in self._exps])

    
#
# Values
#

class Value (object):
    pass


class VInteger (Value):
    # Value representation of integers
    def __init__ (self,i):
        self.value = i
        self.type = "integer"

class VBoolean (Value):
    # Value representation of Booleans
    def __init__ (self,b):
        self.value = b
        self.type = "boolean"





# Primitive operations

def oper_plus (v1,v2): 
    if v1.type == "integer" and v2.type == "integer":
        return VInteger(v1.value + v2.value)
    raise Exception ("Runtime error: trying to add non-numbers")

def oper_minus (v1,v2):
    if v1.type == "integer" and v2.type == "integer":
        return VInteger(v1.value - v2.value)
    raise Exception ("Runtime error: trying to subtract non-numbers")

def oper_times (v1,v2):
    if v1.type == "integer" and v2.type == "integer":
        return VInteger(v1.value * v2.value)
    raise Exception ("Runtime error: trying to multiply non-numbers")

def oper_zero (v1):
    if v1.type == "integer":
        return VBoolean(v1.value==0)
    raise Exception ("Runtime error: type error in zero?")

# Initial primitives dictionary

INITIAL_PRIM_DICT = {
    "+": oper_plus,
    "*": oper_times,
    "-": oper_minus,
    "zero?": oper_zero
}

INITIAL_FUN_DICT = {
    "square": {"params":["x"],
               "body":EPrimCall("*",[EId("x"),EId("x")])},
    "=": {"params":["x","y"],
          "body":EPrimCall("zero?",[EPrimCall("-",[EId("x"),EId("y")])])},
    "+1": {"params":["x"],
           "body":EPrimCall("+",[EId("x"),EValue(VInteger(1))])},
    "sum_from_to": {"params":["s","e"],
                    "body":EIf(ECall("=",[EId("s"),EId("e")]),
                               EId("s"),
                               EPrimCall("+",[EId("s"),
                                              ECall("sum_from_to",[ECall("+1",[EId("s")]),
                                                                   EId("e")])]))}
}
    </pre>
  </body>
</html>

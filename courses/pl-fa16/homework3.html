<!DOCTYPE html>
<html>

  <head>
    
    <meta charset="utf-8">
    <title>Homework 3</title>

    <link rel="stylesheet" href="alt.css" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,800,700' rel='stylesheet' type='text/css'>

    <script src="autoscroll.js"></script>
    
    <style>

      hr { margin-top: 50px; }

        code,tt,pre {
          font-size: 130%;
        }
	
        div.lect {
	  padding-top: 0;
       	  padding-left: 3em;
	  margin-top:0;
        }
    	p.ann { 
    	  padding-left: 3em;
    	  text-indent: -3em; 
    	}
	p.ann_ctd{
	  padding-left: 3em;
        }
    	span.hdr {
   	  padding-right: 1em
    	}

	.hidden {
	  visibility: hidden;
        }

        tt.code {
           background: #e6e6e6;
        }

	pre.code {
	   border: 1px solid #c6c6c6;
	border-radius: 5px;
	padding: 10px;
	font-size:100%;
	}

/* from
    http://www.456bereastreet.com/archive/201105/styling_ordered_list_numbers/
 */

ol {
    counter-reset:li; /* Initiate a counter */
    margin-left:0; /* Remove the default left margin */
    padding-left:0; /* Remove the default left padding */
    padding-top:1em;
}
ol > li {
    position:relative; /* Create a positioning context */
    margin:0 0 6px 2em; /* Give each list item a left margin to make
    room for the numbers */
    padding:4px 8px; /* Add some spacing around the content */
    list-style:none; /* Disable the normal item numbering */
    /*border-top:2px solid #666;
    background:#f6f6f6; */
}
ol > li:before {
    counter-increment:li; /* Increment the counter by 1 */
    /* Position and style the number */
    position:absolute;
    top:-2px;
    left:-2em;
    -moz-box-sizing:border-box;
    -webkit-box-sizing:border-box;
    box-sizing:border-box;
    width:2em;
    /* Some space between the number and the content in browsers that
    support
       generated content but not positioning it (Camino 2 is one
    example) */
    margin-right:8px;
    padding:4px;
/*    border-top:2px solid #666;
    color:#fff;
    background:#666; 
    font-weight:bold; */
/*    font-family:"Helvetica Neue", Arial, sans-serif;
    text-align:center; */
}

ol.letter > li:before {
    content:"(" counter(li,lower-alpha) ")"; /* Use the counter as content */
}

ol.number > li:before {
    content:"(" counter(li,decimal) ")"; /* Use the counter as content */
}

li ol,
li ul {margin-top:6px;}

li > p { margin-top:0;}

    </style>

  </head>


  <body>

    <div class="navbar">

      <div class="home">
	<a href="../../index.html"><img src="../../home.png" style="height: 1.6em;"></a>
      </div>

      <ul>
	<li><a href="index.html"><b>Programming Languages FA16</b></a></li> 
	<li class="hidden"><a class="scrollto" href="#announcements">Announcements</a></li>
	<li class="hidden"><a class="scrollto" href="#info">Course Info</a></li>
	<li class="hidden"><a class="scrollto" href="#lectures">Lectures</a></li>
	<li class="hidden"><a class="scrollto" href="#homeworks">Homeworks</a></li>
      </ul>
    </div>


    <!-- padding -->
    <div id="top" style="height: 7em;"></div>
    
    <h1 class="clear">Homework 3</h1>
    
    <p class="subtitle">Due date: Monday, Sep 26 (11:59:59pm)</p>


    <p><b>Note on integrity:</b> This homework is meant to be done in teams of two. 
    You may discuss problems with fellow students, but
    all work must be entirely that of your team, and should not be from any
    other course, present, past, or future. If you use a solution from
    another source you must cite it &mdash; this includes when that source
      is someone else helping you.</p>

    <p>Every source file you submit should begin with a block comment
      that lists <span style="text-decoration:underline;">the members of your team</span>, your <span style="text-decoration:underline;">email addresses</span>, and any <span style="text-decoration:underline;">remarks</span> that you
      wish to make to the instructor.</p>

    <p>All programming is to be done in Python 2.7.</p>

    <p>Feel free to define helper functions if you need them.</p>

    <p>Please code your answers by modifying the
      file <a href="homework3.py"><tt>homework3.py</tt></a>
      provided.</p>

    <p>Questions marked <b>Extra</b> are optional. You do not have to
    do them. But will give you more practice and sometimes more
      insight into what is going on. Plus some of them are fun.</p>

    <p>Electronic submission instructions:</p>

    <ul>
      <li>Send an email with your file <tt>homework3.py</tt> as an attachment to <tt>pl.fa16.olin@gmail.com</tt> with subject <i>Homework 3 submission</i>. Only one email per team, please.</li>
    </ul>

    <hr>
    
    <ol class="number">


      <!--   QUESTION 1    -->


      <li> <p><b>Extending the S-expressions parser</b></p>

	<ol class="letter">

	  <li><p>The Expression node <tt>ELet</tt> in the abstract representation in <tt>homework3.py</tt> supports simultaneous bindings as we saw in homework 2, but the parser can only handle a single binding, as in <tt>(let ((x 10)) <i>expr</i>)</tt>. </p>

	    <p>Extend the parser (function <tt>parse</tt>) so that it can parse <tt>let</tt> expressions with multiple bindings, such as
<pre>
  (let ((x 10) 
        (y 20) 
        (z 30)) 
    (+ x (* y z)))
</pre>
or 
<pre>
  (let ((a 10)) 
    (let ((sq (* a a))
          (db (+ a a))) 
      (+ sq db)))
</pre>

<pre class="code">
<i># sample outputs using the Calc shell
# note that it gives the parsed abstract representation, which is what I'll be checking
# I've sometimes indented the abstract representation for ease of reading</i>

>>> shell()
Homework 3 - Calc Language
calc> (let ((x 10) (y 20)) (+ x y))
Abstract representation: ELet([(x,EInteger(10)),
                               (y,EInteger(20))],
                              ECall(+,[EId(x),ECall(+,[EId(y),EInteger(0)])]))
30
calc> (let ((a (let ((x 1) (y 2)) x)) (b (let ((x 1) (y 2)) y))) (let ((b a) (a b)) a))
Abstract representation: ELet([(a,ELet([(x,EInteger(1)),
                                        (y,EInteger(2))],
                                       EId(x))),
                               (b,ELet([(x,EInteger(1)),
                                        (y,EInteger(2))],
                                       EId(y)))],
                              ELet([(b,EId(a)),
                                    (a,EId(b))],
                                   EId(a)))
2
calc> (let ((a 1) (b 2) (c 3) (d 4) (e 5) (f 6)) f)
Abstract representation: ELet([(a,EInteger(1)),
                               (b,EInteger(2)),
                               (c,EInteger(3)),
                               (d,EInteger(4)),
                               (e,EInteger(5)),
                               (f,EInteger(6))],
                              EId(f))
6
</pre></p>
	  </li>


	  <li><p>The only operations the parser in <tt>homework3.py</tt> can handle are <tt>+</tt> and <tt>*</tt>. Extend the parser so that it can deal with the following additional rule in the grammar for calling an arbitrary user-defined functions:
<pre>

   &lt;expr&gt; ::=  ...
               ( &lt;name&gt; &lt;expr-seq&gt; )

   &lt;expr-seq&gt; ::=  &lt;expr&gt;
                   &lt;expr&gt; &lt;expr-seq&gt;
</pre>
In other words, an expression of the form <tt>( <i>name</i> <i>e<sub>1</sub></i> ... <i>e<sub>k</sub></i> )</tt> should be parsable and return abstract representation <tt>ECall(<i>name</i>,[<i>a<sub>1</sub></i>,...,<i>a<sub>k</sub></i>])</tt> where <tt><i>a<sub>i</sub></i></tt> is the abstract representation obtained by parsing <tt><i>e<sub>i</sub></i></tt>.</p>

<p>Thus,
<pre>
  (zero? (+ 10 20))
</pre>
should parse
into <tt>ECall("zero?",[ECall("+",[EInteger(10),EInteger(20)])])</tt>
and when evaluated yield <tt>false</tt>, while
<pre>
  (zero? (- 20 20))
</pre>
should parse
into <tt>ECall("zero?",[ECall("-",[EInteger(20),EInteger(20)])])</tt>
and when evaluated yield <tt>true</tt>.
Note that 
<pre>
  (some-unknown-function 10 20 30)
</pre>
should parse successfully into 
<pre>
  ECall("some-unknown-function",[EInteger(10),EInteger(20),EInteger(30)])
</pre>
but of course should fail during <i>evaluation</i> if there is no
function <tt>some-unknown-function</tt> in the functions
dictionary.</p>  

<pre class="code">
<i># sample outputs using the Calc shell
# note that it gives the parsed abstract representation, which is what I'll be checking
# I've sometimes indented the abstract representation for ease of reading</i>

>>> shell()
Homework 3 - Calc Language
calc> (zero? 0)
Abstract representation: ECall(zero?,[EInteger(0)])
true
calc> (zero? 1)
Abstract representation: ECall(zero?,[EInteger(1)])
false
calc> (zero? (- 10 20))
Abstract representation: ECall(zero?,[ECall(-,[EInteger(10),EInteger(20)])])
false
calc> (zero? (let ((a 1) (b 1)) (- a b)))
Abstract representation: ECall(zero?,[ELet([(a,EInteger(1)),
                                            (b,EInteger(1))],
                                           ECall(-,[EId(a),EId(b)]))])
true
calc> (+1 10)
Abstract representation: ECall(+1,[EInteger(10)])
11
calc> (if (= 3 3) 1 2)
Abstract representation: EIf(ECall(=,[EInteger(3),EInteger(3)]),EInteger(1),EInteger(2))
1
calc> (if (= 3 4) 1 2)
Abstract representation: EIf(ECall(=,[EInteger(3),EInteger(4)]),EInteger(1),EInteger(2))
2
calc> (- 30 (- 20 15))
Abstract representation: ECall(-,[EInteger(30),ECall(-,[EInteger(20),EInteger(15)])])
25
calc> (+1 (if (zero? 0) 10 20))
Abstract representation: ECall(+1,[EIf(ECall(zero?,[EInteger(0)]),EInteger(10),EInteger(20))])
11
</pre>
	  </li>


	  <li><p> <b>Extra:</b> As it stands, the current language only
	    supports passing exactly two integers to <tt>+</tt>
	    and <tt>*</tt>. It's easy enough to modify the primitive
	    operations for <tt>+</tt> and <tt>*</tt>
	    (functions <tt>oper_plus</tt> and <tt>oper_times</tt>
	    in <tt>homework3.py</tt>) to support more than 2
	      arguments. But there's another approach we can use.</p>

	    <p>Intuitively, we can express addition with more than two
	      arguments as a nested sequence of additions with only
	      two arguments. For instance, <tt>(+ 1 2 3 4)</tt> is
	      equivalent to <tt>(+ 1 (+ 2 (+ 3 4)))</tt>. So one way
	      to support addition with more than two arguments is to
	      parse it into an abstract representation that uses nested
	      additions with two arguments.</p>

	    <p>Modify the parser in function <tt>parse</tt> so
	      that it can parse expressions of the
	      form <tt>(+ <i>e<sub>1</sub></i>
	      ... <i>e<sub>k</sub></i>)</tt>, and for those returns
	      the same abstract representation as if we had written
	      <tt>(+ <i>e<sub>1</sub></i> (+ <i>e<sub>2</sub></i> (+
		... (+ <i>e<sub>k-1</sub></i> <i>e<sub>k</sub></i>)
		...)))</tt>, or something equivalent. </p>

	    <p>Do the same for <tt>*</tt> as well.</p>
	  

<pre class="code">
<i># sample outputs using the Calc shell
# note that it gives the parsed abstract representation, which is what I'll be checking
# I've sometimes indented the abstract representation for ease of reading</i>

calc> (+ 1 2 3)
Abstract representation: ECall(+,[EInteger(1),
                                  ECall(+,[EInteger(2),
                                           ECall(+,[EInteger(3),
                                                    EInteger(0)])])])
6
calc> (+ 1 2 3 4 5)
Abstract representation: ECall(+,[EInteger(1),
                                  ECall(+,[EInteger(2),
                                           ECall(+,[EInteger(3),
                                                    ECall(+,[EInteger(4),
                                                             ECall(+,[EInteger(5),
                                                                      EInteger(0)])])])])])
15
calc> (* 1 2 3)
Abstract representation: ECall(*,[EInteger(1),
                                  ECall(*,[EInteger(2),
                                           ECall(*,[EInteger(3),
                                                    EInteger(1)])])])
6
calc> (* 1 2 3 4)
Abstract representation: ECall(*,[EInteger(1),
                                  ECall(*,[EInteger(2),
                                           ECall(*,[EInteger(3),
                                                    ECall(*,[EInteger(4),
                                                             EInteger(1)])])])])
24
</pre>
	  </li>


	</ol>

      </li>




      <!--   QUESTION 2    -->


      <li> <p><b>Shell definitions</b></p>

	<ol class="letter">

	  <li><p>If you look at the implementation of the simple shell
	      in function <tt>shell</tt>, you see that the functions
	      dictionary used to evaluate the expression parsed is
	      always the same, <tt>INITIAL_FUN_DICT</tt>. It would be
	      nice if there was a way to <i>add</i> definitions to the
	      dictionary, the way for instance we can do it in Python
	      using <tt>def</tt>.</p>

	  <p>This means that the parser when given a string will
	      either parse it into an expression (which the shell will
	      evaluate) or into a function defnition (which the shell will
	      add to the functions dictionary it uses. Recall that the 
	      representation of a defined function we use is as a
	      dictionary <tt>{"params":<i>L</i>, "body":<i>exp</i>}</tt>
	      where <tt><i>L</i></tt> is a list of parameter names (the
	      parameters to the function) and <tt><i>exp</i></tt> is an
	      expression (in our abstract representation) representing the body of the function which gets
	      evaluated to return a result from the function.</p>


	  <p>Here are the grammar rules for function definitions:
<pre>
  &lt;def&gt; ::= ( defun &lt;name&gt; ( &lt;params&gt; ) &lt;expr&gt; )

  &lt;params&gt; ::= &lt;name&gt; &lt;params&gt;
               &lt;name&gt;
</pre>
Thus, for example, the following defines a function that adds 1 to its
input:
<pre>
  (defun increment (x) 
    (+ x 1))
</pre>
	  </p>

	  <p>So your first challenge is to modify the parser in
	    function <tt>parse</tt> so that it can parse either an
	    expression or a function definition, and return an
	    abstract representation in the first case, or a function
	    definition in the second case (basically, a dictionary with
	    fields <tt>params</tt> and <tt>body</tt>).<del> Feel free to
	    solve the problem of returning either an abstract
	    representation or a function definition in whatever way
	    you choose. I do not specify a return type for
	      the <tt>parse</tt> function.</del> <ins>To ease the problem of testing your parser, let me prescribe what the parsing should return. If the result of parsing is an expression that should be evaluated, <tt>parse</tt> should return a dictionary <tt>{"result":"expression", "expr":<i>e</i>}</tt> where <tt><i>e</i></tt> is the abstract representation of the expression just parsed. If the result of parsing is a function definition that should be added to the functions dictionary, <tt>parse</tt> should return a dictionary <tt>{"result":"function", "name": <i>n</i>, "params": <i>L</i>, "body":<i>e</i>}</tt>, where <tt><i>n</i></tt> is the name of the function (a string), <tt><i>L</i></tt> is a list of parameters names (each a string), and <tt><i>e</i></tt> is the abstract representation of the body of the function.</ins>
	  </p>

	    <p>Your second challenge is to modify
	    function <tt>shell</tt> so that when the input string
	    parses into an expression, that expression gets evaluated an the result printed (the
	    way it is now), but when the input string parses into a function
	    definition, that function definition is added to the functions
	    dictionary that evaluation uses instead.
	    </p>

<pre class="code">
>>> parse("(let ((x 10)) (+1 x))")
{'expr': <__main__.ELet object at 0x101887090>, 'result': 'expression'}
>>> print(parse("(let ((x 10)) (+1 x))")["expr"])
ELet([(x,EInteger(10))],ECall(+1,[EId(x)]))
>>> parse("(defun decrement (x) (- x 1))")
{'body': <__main__.ECall object at 0x1018873d0>, 'params': ['x'], 'result': 'function', 'name': 'decrement'}
>>> print(parse("(defun decrement (x) (- x 1))")["body"])
ECall(-,[EId(x),EInteger(1)])

<i># sample outputs using the Calc shell
# note that it gives the parsed abstract representation, which is what I'll be checking
# I've sometimes indented the abstract representation for ease of reading</i>

>>> shell()
Homework 3 - Calc Language
calc> (defun decrement (x) (- x 1))
Function decrement added to functions dictionary
calc> (decrement 123)
Abstract representation: ECall(decrement,[EInteger(123)])
122
calc> (defun decr2 (x) (decrement (decrement x)))
Function decr2 added to functions dictionary
calc> (decr2 11)
Abstract representation: ECall(decr2,[EInteger(11)])
9
calc> (defun sum-of-squares (x y) (+ (square x) (square y)))
Function sum-of-squares added to functions dictionary
calc> (sum-of-squares 10 5)
Abstract representation: ECall(sum-of-squares,[EInteger(10),EInteger(5)])
125
</pre>
	  </li>



	  <li><p><b>Extra:</b> It would be nice if we could also
	  define <i>constant values</i>. For instance, we could
	      write
<pre>
  (define a (+ 10 20))
</pre>
in the shell, and
	      from that point on whenever you refer to <tt>a</tt> in some
expression it evaluates to <tt>30</tt>.</p>

	    <p>You will need to
	  modify the
	  parser so that it accepts these kind of definitions, modify
	  the evaluation method of Expression nodes so that it takes an additional
	      <i>values dictionary</i>, and 
	  modify the shell so that it can add constant definitions to
	  that dictionary when it recognizes them.
	    </p>

<!-- <pre class="code">
</pre> -->
	  </li>


	</ol>

      </li>





      <!--   QUESTION 3 - parsing natural syntax    -->


      <li> <p><b>A natural syntax parser</b></p>

	<ol class="letter">

	  <li>

	<p>As I mentioned in class, the reason why we'll be using S-expressions as our surface syntax
	  is for simplicity. It'll be easy to add features to our language without having to fight with the parser too too much. </p>
	
	<p>To get a sense of the challenges that a more natural syntax poses, we'll develop an alternate surface syntax for our calculator language, based on more standard
	  mathematical notation. </p>

	<p>Here is the base grammar I have in mind:

<pre>
  &lt;expr&gt; ::= &lt;integer&gt;
             true
             false
             &lt;identifier&gt;
             ( expr )
             &lt;expr&gt; ? &lt;expr&gt; : &lt;expr&gt;
             let ( &lt;bindings&gt; ) &lt;expr&gt;
             &lt;expr&gt; + &lt;expr&gt;
             &lt;expr&gt; * &lt;expr&gt;
             &lt;expr&gt; - &lt;expr&gt;
             &lt;name&gt; ( &lt;expr-seq&gt; )

  &lt;bindings&gt; ::= &lt;name&gt; = &lt;expr&gt; , &lt;bindings&gt;
                 &lt;name&gt; = &lt;expr&gt;

  &lt;expr-seq&gt; ::= &lt;expr&gt; , &lt;expr-seq&gt;
                 &lt;expr&gt;
</pre>
	</p>

	<p>Write a function <tt>parse_natural</tt> that does
	what <tt>parse</tt> does, but parsing according to the above
	grammar instead of S-expressions. It should return an abstract
	  representation of the parsed expression.</p>

	<p>In order to be able to use Pyparsing and parser
	combinators, you will need to modify the above grammar so that
	it is, at the very least, not left recursive. You may need to
	make other modifications to the grammar as well. Just make
	sure that the parser you write in the end accepts the same
	  inputs as the grammar above.</p>

	<p>The
	resulting abstract representation should represent the input
	expression subject to the usual rules of operator
	precedence: <tt>*</tt> groups more tightly than
	either <tt>+</tt> or <tt>-</tt>. Treat <tt>*</tt>, <tt>+</tt>,
	and <tt>-</tt> as associative operations. (They are, in fact,
	except for <tt>-</tt>. If you feel adventurous,
	make <tt>-</tt> right associative).  That is, <tt>10 * 20 +
	30</tt> should parse as though you had written <tt>(10 * 20) +
	30</tt>, and <tt>10 + 20 + 30</tt> can parse as either <tt>(10
	+ 20) + 30</tt> or <tt>10 + (20 + 30)</tt> and I don't care
	which.  
	</p>

	<p>Write a function <tt>shell_natural</tt> that does
	  what <tt>shell</tt> does except it
	  uses <tt>parse_natural</tt> instead of <tt>parse</tt>. 
	</p>

<pre class="code">
<i># sample outputs using the Calc shell
# note that it gives the parsed abstract representation, which is what I'll be checking
# I've sometimes indented the abstract representation for ease of reading</i>

>>> shell_natural()
Homework 3 - Calc Language (Natural syntax)
calc/nat> let (x = 10) x + 1
Abstract representation: ELet([(x,EInteger(10))],
                              ECall(+,[EId(x),EInteger(1)]))
11
calc/nat> let (x = 10 , y = 20) x + y * y
Abstract representation: ELet([(x,EInteger(10)),
                               (y,EInteger(20))],
                              ECall(+,[EId(x),ECall(*,[EId(y),EId(y)])]))
410
calc/nat> zero? (1)
Abstract representation: ECall(zero?,[EInteger(1)])
false
calc/nat> zero? (10 - 10)
Abstract representation: ECall(zero?,[ECall(-,[EInteger(10),EInteger(10)])])
true
calc/nat> zero? (0) ? 1 : 2
Abstract representation: EIf(ECall(zero?,[EInteger(0)]),EInteger(1),EInteger(2))
1
calc/nat> (zero? (0) ? 1 : 2) + 55
Abstract representation: ECall(+,[EIf(ECall(zero?,[EInteger(0)]),EInteger(1),EInteger(2)),
                                  EInteger(55)])
56
calc/nat> (zero? (1) ? 1 : 2) + 55
Abstract representation: ECall(+,[EIf(ECall(zero?,[EInteger(1)]),EInteger(1),EInteger(2)),
                                  EInteger(55)])
57
calc/nat> let (x = 4 + 5 * 6) let (y = x * 2) square(y)
Abstract representation: ELet([(x,ECall(+,[EInteger(4),ECall(*,[EInteger(5),EInteger(6)])]))],
                              ELet([(y,ECall(*,[EId(x),EInteger(2)]))],
                                   ECall(square,[EId(y)])))
4624
<i># double-checking...</i>
calc/nat> (34 * 2) * (34 * 2)
Abstract representation: ECall(*,[ECall(*,[EInteger(34),EInteger(2)]),
                                  ECall(*,[EInteger(34),EInteger(2)])])
4624
</pre>

<i>Note: if you hit a wall and cannot make any progress with the
  surface syntax I'm asking you to implement, you can make changes to
  the surface syntax to make it easier to parse. Document your
  changes, and explains why you had to do things that way. Try
  to keep it as close as possible to a natural syntax.</i>

	  </li>

	  <li><p><b>Extra:</b> Come up with a reasonable natural
	      syntax for function definitions, and redo Question 2(a)
	      above except with <tt>parse_natural</tt> and your syntax
	      for function definitions.


<pre class="code">
<i># sample outputs using the Calc shell
# note that it gives the parsed abstract representation, which is what I'll be checking
# I've sometimes indented the abstract representation for ease of reading</i>

calc/nat> function decrement (x) x - 1
Function decrement added to functions dictionary
calc/nat> decrement(10)
Abstract representation: ECall(decrement,[EInteger(10)])
9
calc/nat> function sum_of_squares (x,y) square(x) + square(y)
Function sum_of_squares added to functions dictionary
calc/nat> sum_of_squares(10,5)
Abstract representation: ECall(sum_of_squares,[EInteger(10),EInteger(5)])
125
</pre>

	  </li>

	</ol>

      </li>

    </ol>
    

  </body>
</html>

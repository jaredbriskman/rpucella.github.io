<!DOCTYPE html>
<html>

  <head>
    
    <meta charset="utf-8">
    <title>Homework 5</title>

    <link rel="stylesheet" href="alt.css" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,800,700' rel='stylesheet' type='text/css'>

    <script src="autoscroll.js"></script>
    
    <style>

      hr { margin-top: 50px; }

        code,tt,pre {
          font-size: 130%;
        }
	
        div.lect {
	  padding-top: 0;
       	  padding-left: 3em;
	  margin-top:0;
        }
    	p.ann { 
    	  padding-left: 3em;
    	  text-indent: -3em; 
    	}
	p.ann_ctd{
	  padding-left: 3em;
        }
    	span.hdr {
   	  padding-right: 1em
    	}

	.hidden {
	  visibility: hidden;
        }

        tt.code {
           background: #e6e6e6;
        }

	pre.code {
	   border: 1px solid #c6c6c6;
	border-radius: 5px;
	padding: 10px;
	font-size:100%;
	}

/* from
    http://www.456bereastreet.com/archive/201105/styling_ordered_list_numbers/
 */

ol {
    counter-reset:li; /* Initiate a counter */
    margin-left:0; /* Remove the default left margin */
    padding-left:0; /* Remove the default left padding */
    padding-top:1em;
}
ol > li {
    position:relative; /* Create a positioning context */
    margin:0 0 6px 2em; /* Give each list item a left margin to make
    room for the numbers */
    padding:4px 8px; /* Add some spacing around the content */
    list-style:none; /* Disable the normal item numbering */
    /*border-top:2px solid #666;
    background:#f6f6f6; */
}
ol > li:before {
    counter-increment:li; /* Increment the counter by 1 */
    /* Position and style the number */
    position:absolute;
    top:-2px;
    left:-2em;
    -moz-box-sizing:border-box;
    -webkit-box-sizing:border-box;
    box-sizing:border-box;
    width:2em;
    /* Some space between the number and the content in browsers that
    support
       generated content but not positioning it (Camino 2 is one
    example) */
    margin-right:8px;
    padding:4px;
/*    border-top:2px solid #666;
    color:#fff;
    background:#666; 
    font-weight:bold; */
/*    font-family:"Helvetica Neue", Arial, sans-serif;
    text-align:center; */
}

ol.letter > li:before {
    content:"(" counter(li,lower-alpha) ")"; /* Use the counter as content */
}

ol.number > li:before {
    content:"(" counter(li,decimal) ")"; /* Use the counter as content */
}

li ol,
li ul {margin-top:6px;}

li > p { margin-top:0;}

    </style>

  </head>


  <body>

    <div class="navbar">

      <div class="home">
	<a href="../../index.html"><img src="../../home.png" style="height: 1.6em;"></a>
      </div>

      <ul>
	<li><a href="index.html"><b>Programming Languages FA16</b></a></li> 
	<li class="hidden"><a class="scrollto" href="#announcements">Announcements</a></li>
	<li class="hidden"><a class="scrollto" href="#info">Course Info</a></li>
	<li class="hidden"><a class="scrollto" href="#lectures">Lectures</a></li>
	<li class="hidden"><a class="scrollto" href="#homeworks">Homeworks</a></li>
      </ul>
    </div>


    <!-- padding -->
    <div id="top" style="height: 7em;"></div>
    
    <h1 class="clear">Homework 5</h1>
    
    <p class="subtitle">Due date: <b>Thursday</b> Oct 12, 2016 (11:59:59pm)</p>


    <p><b>Note on integrity:</b> This homework is meant to be done in teams of two. 
    You may discuss problems with fellow students, but
    all work must be entirely that of your team, and should not be from any
    other course, present, past, or future. If you use a solution from
    another source you must cite it &mdash; this includes when that source
      is someone else helping you.</p>

    <p>Every source file you submit should begin with a block comment
      that lists <span style="text-decoration:underline;">the members of your team</span>, your <span style="text-decoration:underline;">email addresses</span>, and any <span style="text-decoration:underline;">remarks</span> that you
      wish to make to the instructor.</p>

    <p>All programming is to be done in Python 2.7.</p>

    <p>Feel free to define helper functions if you need them.</p>

    <p>Please code your answers by modifying the
      file <a href="homework5.py"><tt>homework5.py</tt></a>
      provided.</p>

    <p>Questions marked <b>Extra</b> are optional. You do not have to
    do them. But will give you more practice and sometimes more
      insight into what is going on. Plus some of them are fun.</p>

    <p>Electronic submission instructions:</p>

    <ul>
      <li>Send an email with your file <tt>homework5.py</tt> as an attachment to <tt>pl.fa16.olin@gmail.com</tt> with subject <i>Homework 5 submission</i>. Only one email per team, please.</li>
    </ul>

    <hr>

    <ol class="number">


      <!-- ************************************************************ -->
      
      <li> <p><b>Multi-argument functions</b></p>

	    <p>The code in <tt>homework5.py</tt> contains an
	      implementation of functions that only handles
	      single-argument
	      functions. <tt>ECall</tt>, <tt>EFunction</tt>, <tt>VClosure</tt>
	      all can accept lists of expressions and parameters, but
	      raise an exception if there is more than one.</p> 
	    
	    <p>Modify the code so that it handles multi-argument
	      functions, by extending <tt>ECall</tt> to accept more
	      than one argument expression. </p>

	    <p>Please implement <tt>ECall</tt> with <i>eager</i>
	      evaluation, that is, when evaluating <tt>ECall</tt>, you
	      should evaluate all the arguments down to values
	      before. The current single-argument implementation
	      of <tt>ECall</tt> is eager.
	    
	    <p>You will have to modify the definition
	      of <tt>EFunction</tt> and <tt>VClosure</tt> to match,
	      and also modify the parser so that it can produce
	      abstract representations using your
	      new <tt>ECall</tt>, <tt>EFunction</tt>,
	      and <tt>VClosure</tt> nodes. Node that the parser (and
	      the shell) can evaluate expressions and add new
	      top-level functions to the environment.</p>
	    
	    <p>Function <tt>initial_env()</tt> creates an initial
	      environment that already contains function wrappers for our
	      primitive operations that uses
	      multi-argument <tt>ECall</tt>s. Uncomment the appropriate line in <tt>shell</tt> when you have
	    completed this question if you want to try out some examples in the shell.</p>

<pre class="code">
>>> shell()
Homework 5 - Func Language
#quit to quit
func> (function (x y) (+ x y))
Abstract representation: EFunction([x,y],ECall(EId(+),[EId(x),EId(y)]))
&lt;function [x,y] ECall(EId(+),[EId(x),EId(y)])&gt;
func> ((function (x y) (+ x y)) 10 20)
Abstract representation: ECall(EFunction([x,y],ECall(EId(+),[EId(x),EId(y)])),[EValue(10),EValue(20)])
30
func> (defun sum2 (x y) (+ x y))
Function sum2 added to top-level environment
func> (sum2 10 20)
Abstract representation: ECall(EId(sum2),[EValue(10),EValue(20)])
30
func> (defun sum3 (x y z) (+ x (+ y z)))
Function sum3 added to top-level environment
func> (sum3 10 20 30)
Abstract representation: ECall(EId(sum3),[EValue(10),EValue(20),EValue(30)])
60
func> (sum3 (sum2 10 20) 30 40)
Abstract representation: ECall(EId(sum3),[ECall(EId(sum2),[EValue(10),EValue(20)]),EValue(30),EValue(40)])
100
</pre>

      </li>


      <!-- ************************************************************ -->
      
      
      <li> <p><b>Surface Syntax</b></p>

	<ol class="letter">

	  <!-- ---------------------------------------- -->
	  
	  <li>
	    <p>Once you have anonymous functions in the abstract
	    representation &mdash;
	    the <tt>EFunction</tt> expression node &mdash; we no
	      longer need <tt>ELet</tt> in the abstract
	      representation. We can have <tt>let</tt> in the surface
	    syntax as usual, but use a <i>front-end
		transformation</i> to transform any <tt>let</tt> into
	      uses of anonymous functions and function calls. (See <a href="homework4.html">Homework 4</a> for front-end transformations.)</p>

	    <p>You should convince yourself that
	      <pre>
  (let ((x (* 2 2))
        (y 20))
    (+ x y))
</pre>
	      could be written
	      <pre>
  ((function (x y) (+ x y))
      (* 2 2) 20)
</pre>
	Note the parenthesization &mdash; this is a <tt>function</tt> expression applied to two arguments.
	      More generally,
<pre>
  (let ((<i>n<sub>1</sub></i> <i>E<sub>1</sub></i>) (<i>n<sub>2</sub></i> <i>E<sub>2</sub></i>) ...)
     <i>F</i>)
</pre>
	      can always be written as
<pre>
  ((function (<i>n<sub>1</sub></i> <i>n<sub>2</sub></i> ...) <i>F</i>)
      <i>E<sub>1</sub></i> <i>E<sub>1</sub></i> ...)
</pre>
	    </p>

	    <p>Implement the above transformation in the parser
	      function <tt>parse</tt>. Note that the current version
	      of the parser raises an exception if you try to parse
	      a <tt>let</tt>. </p>
	      

<pre class="code">
>>> shell()
Homework 5 - Func Language
#quit to quit
func> (let ((x 10)) x)
Abstract representation: ECall(EFunction([x],EId(x)),[EValue(10)])
10
func> (let ((x 10)) (+ x 1))
Abstract representation: ECall(EFunction([x],ECall(EId(+),[EId(x),EValue(1)])),[EValue(10)])
11
func> (let ((x 10) (y 20)) (+ x y))
Abstract representation: ECall(EFunction([x,y],ECall(EId(+),[EId(x),EId(y)])),[EValue(10),EValue(20)])
30
func> (let ((x (* 2 3)) (y (* 4 5))) (+ x y))
Abstract representation: ECall(EFunction([x,y],ECall(EId(+),[EId(x),EId(y)])),
                               [ECall(EId(*),[EValue(2),EValue(3)]),ECall(EId(*),[EValue(4),EValue(5)])])
26
func> (let ((x 1) (y 2) (z 3)) (+ x (* y z)))
Abstract representation: ECall(EFunction([x,y,z],ECall(EId(+),[EId(x),ECall(EId(*),[EId(y),EId(z)])])),
                               [EValue(1),EValue(2),EValue(3)])
7
func> (let ((x (let ((y 10)) y))) x)
Abstract representation: ECall(EFunction([x],EId(x)),[ECall(EFunction([y],EId(y)),[EValue(10)])])
10
</pre>
	  </li>

	  <!-- ---------------------------------------- -->

	  <li><p>It turns out we don't need multi-argument
	      functions. If you have single-argument anonymous functions,
	      you can code up multiple argument functions using a
	      technique known
	      as <a href="https://en.wikipedia.org/wiki/Currying">currying</a>
	      (named after Haskell Curry, not the Indian dish).</p>

	    <p>Here's the idea. Suppose you wanted to define a
	      function taking two arguments, such as
<pre>
  (defun foo (x y) <i>E</i>)
</pre>
You call such a function with <tt>(foo 10 20)</tt>.</p>

	    <p>Another way to write that function is as follows:
<pre>
  (defun foo-alternate (x)
    (function (y) <i>E</i>))
</pre>
	      namely as a function that takes the first argument as
	      input, and <i>returns a function that takes the second
  argument as input and returns the final result</i>. To
	      invoke such a function, you would use:
	      <tt>((foo-alternate 10) 20)</tt>
	      Make sure you understand what's going on here. If you
	      do, then you've understood first-class functions.
	    </p>

	    <p>Here is how you would write a three-arguments function:
<pre>
  (defun bar-alternate (x)
    (function (y)
      (function (z) <i>F</i>)))
</pre>
	      and you would call it as <tt>(((bar-alternate 10) 20)
		30)</tt>.
	    </p>

	    <p>Write a version of the parser called <tt>parse_curry</tt>
	      that accepts the same surface syntax as your parser in Question 1 (multi-arguments functions and calls) but transforms multi-argument functions into single-argument function as above, and multi-argument function calls into nested function calls, again as above. Basically, you should accept the same surface syntax as Question 1, but you should produce an abstract representation that never uses functions (or closures) with more than one argument.</p>

	    <p>I've given you a companion shell <tt>shell_curry</tt> that implements a shell just like <tt>shell</tt> except using <tt>parse_curry</tt>. 
	      It uses <tt>initial_env_curry</tt>, which creates an initial
	      environment that already contains function wrappers for our
	      primitive operations that uses curried functions.</p>
	      
<pre class="code">
>>> shell_curry()
Homework 5 - Func Language
#quit to quit
func/curry> +
Abstract representation: EId(+)
&lt;function [x] EFunction([y],EPrimCall(&lt;prim&gt;,[EId(x),EId(y)]))&gt;
func/curry> (+ 10 20)
Abstract representation: ECall(ECall(EId(+),[EValue(10)]),[EValue(20)])
30
func/curry> (* 2 3)
Abstract representation: ECall(ECall(EId(*),[EValue(2)]),[EValue(3)])
6
func/curry> ((function (x y) (+ x y)) 10 20)
Abstract representation: ECall(ECall(EFunction([x],EFunction([y],ECall(ECall(EId(+),[EId(x)]),[EId(y)]))),
                                     [EValue(10)]),
                               [EValue(20)])
30
func/curry> (function (x y) (+ x y))
Abstract representation: EFunction([x],EFunction([y],ECall(ECall(EId(+),[EId(x)]),[EId(y)])))
&lt;function [x] EFunction([y],ECall(ECall(EId(+),[EId(x)]),[EId(y)]))&gt;
func/curry> (defun test (x y z) (+ x (+ y z)))
Function test added to top-level environment
func/curry> test
Abstract representation: EId(test)
&lt;function [x] EFunction([y],EFunction([z],ECall(ECall(EId(+),[EId(x)]),[ECall(ECall(EId(+),[EId(y)]),[EId(z)])])))&gt;
func/curry> (test 1 2 3)
Abstract representation: ECall(ECall(ECall(EId(test),[EValue(1)]),[EValue(2)]),[EValue(3)])
6
</pre>
	  </li>

	</ol>

      </li>


      
      <!-- ************************************************************ -->
      
      <li> <p><b>Recursive Anonymous Functions</b></p>

	<p>Anonymous functions cannot be recursive, at least not as we
	have them now. In order to write a recursive function, you
	need to know the name of the function, and the point of an
	  anonymous function is that we do not give it a name!</p>

	<p>That may not seem like such a bad limitation, but it also
	means that we cannot define local recursive functions. The one
	way
	  we can define a local function right now is
	  via <tt>let</tt>, such as:
<pre>
  (let ((double (function (x) (* 2 x))))
    (double (double 10)))
</pre>
        But because this relies on the use of an anonymous function,
we cannot write a recursive function in this manner.</p>

	<p>There are a couple of ways around this limitation. One is
	  to define a slightly different form of <tt>let</tt> that
	  somehow lets us make the binding that we are
	  creating <i>visible</i> within the expression that we are
	  binding. Such a <tt>let</tt> is called a <tt>letrec</tt>. We
	  are not going to pursue that approach, but you
	  can <a href="http://www.cs.rpi.edu/academics/courses/fall00/ai/scheme/reference/schintro-v14/schintro_126.html">read
	    about it</a>.</p>

	<p>No, the approach we are going to use is to allow the
	writing of recursive anonymous function by giving the
	anonymous function an internal name by which it can refer to itself
	  within its own body. For example, here is a recursive
	  anonymous function to sum up all the integers from 0
	  to <i>n</i>:
<pre>
  (function me (n) (if (zero? n) 0 (+ n (me (- n 1)))))
</pre>
	This creates an anonymous function &mdash; it evaluates to a
closure &mdash; but within the function body, the internal name <tt>me</tt> refers to the
anonymous function itself. There is nothing special about
the <tt>me</tt> symbol. Anything can be chosen:
<pre>
  (function hello (n) (if (zero? n) 0 (+ n (hello (- n 1)))))
</pre>
represents exactly the same function.
	</p>

	<p>With the ability to write recursive anonymous functions, we
	  can now locally define recursive function. For instance,
<pre>
  (let ((sum (function me (n) (if (zero? n)
                                  0
                                  (+ n (me (- n 1)))))))
    (sum 50))	    
</pre>
Note that the function is referred to as <tt>me</tt> within its own
body, but is bound to the name <tt>sum</tt> by which it can be
referred to elsewhere in the code. In other words, the internal name
doesn't need to be the same as the name to which you ultimately bind the
function.</p>

	<ol class="letter">

	<li>
	<p>Your first task is to extend <tt>EFunction</tt> so that
	  it takes a third (optional) argument representing the
	internal name of the function. By default, if an internal name
	is not supplied to <tt>EFunction</tt>, then it evaluates to a
	normal closure the way we have it now. If an internal
	name <i>is</i> supplied to <tt>EFunction</tt>, then it
	evaluates to a closure whose environment has a binding for
	  that internal name that refers to the closure
	  itself. (Convince yourself that this is enough to give you
	  recursion.) There
	  are a few ways of achieving that, but I'll let you figure
	  them out.</p>

	<p><b>Hint:</b> the cleanest way I found is to change <tt>VClosure</tt> so that instead of accessing
	  the stored environment as a field, you access it via a method <tt>env()</tt>.</p>

	<p>
	  (If you change the interface of <tt>VClosure</tt>,
	  make sure Questions 1 and 2 still works with your
	  new <tt>VClosure</tt>! I'll be testing your code as a whole.)</p>

<pre class="code">
# let's define the recusive function above
>>> e = EFunction(["n"],
                  EIf(ECall(EId("zero?"),[EId("n")]),
		      EValue(VInteger(0)),
		      ECall(EId("+"),[EId("n"),
		                      ECall(EId("me"),[ECall(EId("-"),[EId("n"),EValue(VInteger(1))])])])),
                  name="me")
# evaluate the function to get a closure value
>>> f = e.eval(initial_env())
# call the closure with argument 10
>>> ECall(EValue(f),[EValue(VInteger(10))]).eval([]).value
55
</pre>
	</li>

	<li>
	<p>Your second task is to extend the surface syntax to account
	  for an internal name. Extend the parser <tt>parse</tt> so
	  that it parses not only the form <tt>(function (<i>name<sub>1</sub></i>
	    ...) <i>expr</i>)</tt> as before, but also the recursive
	  form <tt>(function <i>name<sub>int</sub></i> (<i>name<sub>1</sub></i>
	    ...) <i>expr</i>)</tt> which should parse to
	  an <tt>EFunction</tt> with the specified internal
	  name <tt><i>name<sub>int</sub></i></tt>. 
	</p>
<pre class="code">
>>> shell()
Homework 5 - Func Language
#quit to quit
func> ((function (x y) (+ x y)) 10 20)
Abstract representation: ECall(EFunction([x,y],ECall(EId(+),[EId(x),EId(y)])),[EValue(10),EValue(20)])
30
func> ((function me (n) (if (zero? n) 0 (+ n (me (- n 1))))) 10)
Abstract representation: ECall(EFunction([n],
                                         EIf(ECall(EId(zero?),[EId(n)]),
                                             EValue(0),
					     ECall(EId(+),
					           [EId(n),ECall(EId(me),[ECall(EId(-),[EId(n),EValue(1)])])]))),
                               [EValue(10)])
55
func> (let ((sum (function me (n) (if (zero? n) 0 (+ n (me (- n 1))))))) (sum 100))
Abstract representation: ECall(EFunction([sum],
                                         ECall(EId(sum),[EValue(100)])),
	                       [EFunction([n],
			                  EIf(ECall(EId(zero?),[EId(n)]),
					      EValue(0),
					      ECall(EId(+),
					            [EId(n),ECall(EId(me),[ECall(EId(-),[EId(n),EValue(1)])])])))])
5050
func> ((function me2 (n1 n2) (if (= n2 n1) n2 (+ n2 (me2 n1 (- n2 1))))) 0 20)
Abstract representation: ECall(EFunction([n1,n2],
                                         EIf(ECall(EId(=),[EId(n2),EId(n1)]),
					     EId(n2),
					     ECall(EId(+),
					           [EId(n2),ECall(EId(me2),
						                  [EId(n1),ECall(EId(-),[EId(n2),EValue(1)])])]))),
                               [EValue(0),EValue(20)])
210
</pre>
	</li>
	  
      </li>


    </ol>
    

  </body>
</html>

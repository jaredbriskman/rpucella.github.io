<!DOCTYPE html>
<html>

  <head>
    
    <meta charset="utf-8">
    <title>Homework 4</title>

    <link rel="stylesheet" href="alt.css" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,800,700' rel='stylesheet' type='text/css'>

    <script src="autoscroll.js"></script>
    
    <style>

      hr { margin-top: 50px; }

        code,tt,pre {
          font-size: 130%;
        }
	
        div.lect {
	  padding-top: 0;
       	  padding-left: 3em;
	  margin-top:0;
        }
    	p.ann { 
    	  padding-left: 3em;
    	  text-indent: -3em; 
    	}
	p.ann_ctd{
	  padding-left: 3em;
        }
    	span.hdr {
   	  padding-right: 1em
    	}

	.hidden {
	  visibility: hidden;
        }

        tt.code {
           background: #e6e6e6;
        }

	pre.code {
	   border: 1px solid #c6c6c6;
	border-radius: 5px;
	padding: 10px;
	font-size:100%;
	}

/* from
    http://www.456bereastreet.com/archive/201105/styling_ordered_list_numbers/
 */

ol {
    counter-reset:li; /* Initiate a counter */
    margin-left:0; /* Remove the default left margin */
    padding-left:0; /* Remove the default left padding */
    padding-top:1em;
}
ol > li {
    position:relative; /* Create a positioning context */
    margin:0 0 6px 2em; /* Give each list item a left margin to make
    room for the numbers */
    padding:4px 8px; /* Add some spacing around the content */
    list-style:none; /* Disable the normal item numbering */
    /*border-top:2px solid #666;
    background:#f6f6f6; */
}
ol > li:before {
    counter-increment:li; /* Increment the counter by 1 */
    /* Position and style the number */
    position:absolute;
    top:-2px;
    left:-2em;
    -moz-box-sizing:border-box;
    -webkit-box-sizing:border-box;
    box-sizing:border-box;
    width:2em;
    /* Some space between the number and the content in browsers that
    support
       generated content but not positioning it (Camino 2 is one
    example) */
    margin-right:8px;
    padding:4px;
/*    border-top:2px solid #666;
    color:#fff;
    background:#666; 
    font-weight:bold; */
/*    font-family:"Helvetica Neue", Arial, sans-serif;
    text-align:center; */
}

ol.letter > li:before {
    content:"(" counter(li,lower-alpha) ")"; /* Use the counter as content */
}

ol.number > li:before {
    content:"(" counter(li,decimal) ")"; /* Use the counter as content */
}

li ol,
li ul {margin-top:6px;}

li > p { margin-top:0;}

    </style>

  </head>


  <body>

    <div class="navbar">

      <div class="home">
	<a href="../../index.html"><img src="../../home.png" style="height: 1.6em;"></a>
      </div>

      <ul>
	<li><a href="index.html"><b>Programming Languages FA16</b></a></li> 
	<li class="hidden"><a class="scrollto" href="#announcements">Announcements</a></li>
	<li class="hidden"><a class="scrollto" href="#info">Course Info</a></li>
	<li class="hidden"><a class="scrollto" href="#lectures">Lectures</a></li>
	<li class="hidden"><a class="scrollto" href="#homeworks">Homeworks</a></li>
      </ul>
    </div>


    <!-- padding -->
    <div id="top" style="height: 7em;"></div>
    
    <h1 class="clear">Homework 4</h1>
    
    <p class="subtitle">Due date: Monday, Oct 3 (11:59:59pm)</p>


    <p><b>Note on integrity:</b> This homework is meant to be done in teams of two. 
    You may discuss problems with fellow students, but
    all work must be entirely that of your team, and should not be from any
    other course, present, past, or future. If you use a solution from
    another source you must cite it &mdash; this includes when that source
      is someone else helping you.</p>

    <p>Every source file you submit should begin with a block comment
      that lists <span style="text-decoration:underline;">the members of your team</span>, your <span style="text-decoration:underline;">email addresses</span>, and any <span style="text-decoration:underline;">remarks</span> that you
      wish to make to the instructor.</p>

    <p>All programming is to be done in Python 2.7.</p>

    <p>Feel free to define helper functions if you need them.</p>

    <p>Please code your answers by modifying the
      file <a href="homework4.py"><tt>homework4.py</tt></a>
      provided.</p>

    <p>Questions marked <b>Extra</b> are optional. You do not have to
    do them. But will give you more practice and sometimes more
      insight into what is going on. Plus some of them are fun.</p>

    <p>Electronic submission instructions:</p>

    <ul>
      <li>Send an email with your file <tt>homework4.py</tt> as an attachment to <tt>pl.fa16.olin@gmail.com</tt> with subject <i>Homework 4 submission</i>. Only one email per team, please.</li>
    </ul>

    <hr>
    
    <ol class="number">


      <li> <p><b>Front-End Transformations</b></p>

      <p>We have a small calculator language right now that we can
      extend with primitives or with user-defined functions by simply
      adding them to the functions dictionary, either directly or  using <tt>(defun
      ...)</tt> from the shell, as we saw in Homework 3.</p>

      <p>However, that does not help us if we want to add new special
      forms, that is, new expression forms with their own evaluation rules. To
      add a new special form, we generally need to add a new kind of node to the abstract
      representation. This goes counter to the drive to keep the
      abstract representation as simple as possible, the same
      motivation that moved us to have a single <tt>EPrimCall</tt>
      instead of a node type for every primitive operation.</p>

      <p>It turns out, however, that many special forms can be
      expressed in terms of simpler expressions already in the
      language. For instance, as I mentioned in class, a
	short-circuiting <tt>(and <i>E</i> <i>F</i>)</tt> can be
	implemented using the simpler <tt>(if <i>E</i> <i>F</i>
      false)</tt>. (Check! Try it for all possible choices of true and
	false for <tt><i>E</i></tt> and <tt><i>F</i></tt>.)</p>

	<p>One convenient place where we can transform some special
	forms in the surface syntax into their simpler equivalent is
	during parsing, where we can produce the abstract
	representation of the simpler equivalent directly. This means
	that the abstract representation doesn't need to understand
	  these new special forms, keeping it as simple as possible.</p>


	<ol class="letter">

	  <li><p>Consider short-circuiting Boolean
	      operators <tt>and</tt>
	      and <tt>or</tt>. Intuitively, <pre>(and <i>E</i> <i>F</i>)</pre>
	      can be expressed using <pre>(if <i>E</i> <i>F</i> false)</pre> and this generalizes to more than two
	      arguments: <pre>(and <i>E</i> <i>F</i> <i>G</i>)</pre> can
	      be understood as <pre>(and <i>E</i> (and <i>F</i> <i>G</i>))</pre> and thus can be expressed
	      as <pre>(if <i>E</i> (if <i>F</i> <i>G</i> false) false)</pre> and similarly for more than three arguments. For
	      completeness, we often take <tt>(and <i>E</i>)</tt> to
	      be equivalent to <tt><i>E</i></tt>, and
	      even <tt>(and)</tt> to be equivalent
	      to <tt>true</tt>.</p>

	    <p>Similarly, <pre>(or <i>E</i> <i>F</i>)</pre>
	      can be expressed using <pre>(if <i>E</i> true <i>F</i>)</pre> and this generalizes to more than two
	      arguments: <pre>(or <i>E</i> <i>F</i> <i>G</i>)</pre> can
	      be understood as <pre>(or <i>E</i> (or <i>F</i> <i>G</i>))</pre> and thus can be expressed
	      as <pre>(if <i>E</i> true (if <i>F</i> true <i>G</i>))</pre> and similarly for more than three arguments. For completeness, we often take <tt>(or <i>E</i>)</tt> to
	      be equivalent to <tt><i>E</i></tt>, and
	      even <tt>(or)</tt> to be equivalent
	      to <tt>false</tt>.</p>

	    <p>Change the parser in <tt>parse()</tt> to correctly
	      parse <tt>(and <i>E</i> <i>F</i> ...)</tt>
	      and <tt>(or <i>E</i> <i>F</i> ...)</tt> and produce an
	      equivalent abstract representation in terms
	      of <tt>if</tt> as described above.</p>

<pre class="code">
>>> shell()
Homework 4 - Calc Language
calc> (and)
Abstract representation: EBoolean(True)
true
calc> (and true)
Abstract representation: EBoolean(True)
true
calc> (and true false)
Abstract representation: EIf(EBoolean(True),EBoolean(False),EBoolean(False))
false
calc> (and false true)
Abstract representation: EIf(EBoolean(False),EBoolean(True),EBoolean(False))
false
calc> (and false 999)
Abstract representation: EIf(EBoolean(False),EInteger(999),EBoolean(False))
false
calc> (and (= 1 1))
Abstract representation: ECall(=,[EInteger(1),EInteger(1)])
true
calc> (and (= 1 1) (= 1 2))
Abstract representation: EIf(ECall(=,[EInteger(1),EInteger(1)]),
                             ECall(=,[EInteger(1),EInteger(2)]),
                             EBoolean(False))
false
calc> (and true false true)
Abstract representation: EIf(EBoolean(True),
                             EIf(EBoolean(False),EBoolean(True),EBoolean(False)),
                             EBoolean(False))
false
calc> (let ((x true)) (and x x false true))
Abstract representation: ELet([(x,EBoolean(True))],
                              EIf(EId(x),
                                  EIf(EId(x),
                                      EIf(EBoolean(False),EBoolean(True),EBoolean(False)),
                                      EBoolean(False)),
                                  EBoolean(False)))
false
calc> (or)
Abstract representation: EBoolean(False)
false
calc> (or true)
Abstract representation: EBoolean(True)
true
calc> (or false)
Abstract representation: EBoolean(False)
false
calc> (or true false)
Abstract representation: EIf(EBoolean(True),EBoolean(True),EBoolean(False))
true
calc> (or false false)
Abstract representation: EIf(EBoolean(False),EBoolean(True),EBoolean(False))
false
calc> (or true false false)
Abstract representation: EIf(EBoolean(True),
                             EBoolean(True),
                             EIf(EBoolean(False),EBoolean(True),EBoolean(False)))
true
calc> (or true false 99)
Abstract representation: EIf(EBoolean(True),
                             EBoolean(True),
                             EIf(EBoolean(False),EBoolean(True),EInteger(99)))
true
calc> (or true false false true)
Abstract representation: EIf(EBoolean(True),
                             EBoolean(True),
                             EIf(EBoolean(False),
                                 EBoolean(True),
                                 EIf(EBoolean(False),EBoolean(True),EBoolean(True))))
true
calc> (or (= 1 1))
Abstract representation: ECall(=,[EInteger(1),EInteger(1)])
true
calc> (or (= 1 1) (= 1 2))
Abstract representation: EIf(ECall(=,[EInteger(1),EInteger(1)]),
                             EBoolean(True),
                             ECall(=,[EInteger(1),EInteger(2)]))
true
</pre>
	  </li>


	  <li><p>Recall the sequential let we developed in Homework
	      2. Intuitively, <pre>
(let* ((x <i>E</i>) 
       (y <i>F</i>)
       (z <i>G</i>)) 
  <i>H</i>)</pre> can be understood as the
	      simpler <pre>
(let ((x <i>E</i>)) 
  (let ((y <i>F</i>)) 
    (let ((z <i>G</i>)) 
      <i>H</i>)))</pre>

	    <p>Change the parser in <tt>parse()</tt> to correctly
	      parse <tt>(let* ((<i>n</i> <i>E</i>) ...) <i>F</i>)</tt> and produce an
	      equivalent abstract representation in terms
	      of <tt>let</tt> as described above.</p>

<pre class="code">
>>> shell()
Homework 4 - Calc Language
calc> (let* ((x 10)) x)
Abstract representation: ELet([(x,EInteger(10))],EId(x))
10
calc> (let* ((x 10) (y (+ x 1))) y)
Abstract representation: ELet([(x,EInteger(10))],
                              ELet([(y,ECall(+,[EId(x),EInteger(1)]))],EId(y)))
11
calc> (let* ((x 10) (y (+ x 1)) (z (+ y 1))) x)
Abstract representation: ELet([(x,EInteger(10))],
                              ELet([(y,ECall(+,[EId(x),EInteger(1)]))],
                                   ELet([(z,ECall(+,[EId(y),EInteger(1)]))],
                                        EId(x))))
10
calc> (let* ((x 10) (y (+ x 1)) (z (+ y 1))) y)
Abstract representation: ELet([(x,EInteger(10))],
                              ELet([(y,ECall(+,[EId(x),EInteger(1)]))],
                                   ELet([(z,ECall(+,[EId(y),EInteger(1)]))],
                                        EId(y))))
11
calc> (let* ((x 10) (y (+ x 1)) (z (+ y 1))) z)
Abstract representation: ELet([(x,EInteger(10))],
                              ELet([(y,ECall(+,[EId(x),EInteger(1)]))],
                                   ELet([(z,ECall(+,[EId(y),EInteger(1)]))],
                                        EId(z))))
12
</pre>
	  </li>


	  <li><p>The <tt>if</tt> form is pretty barebones. In
	  particular, if we need to check several conditions and
	  return a different value for each, we may have to define a
	      whole bunch of nested <tt>if</tt>s.</p>

	    <p>An interesting special
	  form is one that lets us do a conditional on several
	  conditions and return a different value in each
	  case. Special form <tt>(cond (<i>C</i> <i>E</i>) ...)</tt>
	  takes a sequence of clauses <tt>(<i>C</i> <i>E</i>)</tt>
	  where each <tt><i>C</i></tt> and <tt><i>E</i></tt> is an
	  expression, and intuitively evaluates as follow: look at each clause in
	      order, for each check if <tt><i>C</i></tt> evaluates
	  to <tt>true</tt> &mdash; if so, return the result of
	      evaluating the corresponding <tt><i>E</i></tt>,
	  otherwise continue down the list of clauses. If no clause
	      applies, then return <tt>false</tt>. </p>

	    <p>Thus, for example, <pre>
(cond ((= x 0) 99)
      ((= x 1) 66)
      ((= x 2) 33)
      (true 0))</pre> 
	      evaluates to <tt>99</tt> when <tt>x</tt> has
	      value <tt>0</tt>, to <tt>66</tt> when <tt>x</tt> has
	      value <tt>1</tt>, to <tt>33</tt> when <tt>x</tt> has
	      value 2, and <tt>0</tt> otherwise (since <tt>true</tt>
	      always evaluates to <tt>true</tt>).</p>

	    <p>Now, of course, we can express this <tt>cond</tt> 
	      using a sequence of <tt>if</tt>s: <pre>
(if (= x 0)
    99
    (if (= x 1)
        66
        (if (= x 2) 
            33
            (if true 
                0
                false))))</pre>
	    </p>

	    <p>This is an easy transformation to perform. Change the
	      parser in <tt>parse()</tt> to correctly 
	      parse <tt>(cond (<i>C</i> <i>F</i>) ...)</tt>
              and produce an
	      equivalent abstract representation in terms
	      of <tt>if</tt> as described above.</p>

<pre class="code">
>>> shell()
Homework 4 - Calc Language
calc> (cond)
Abstract representation: EBoolean(False)
false
calc> (cond (true 10))
Abstract representation: EIf(EBoolean(True),EInteger(10),EBoolean(False))
10
calc> (cond (false 20) (true 30))
Abstract representation: EIf(EBoolean(False),
                             EInteger(20),
                             EIf(EBoolean(True),EInteger(30),EBoolean(False)))
30
calc> (cond ((= 1 2) 20) ((= 1 1) 30))
Abstract representation: EIf(ECall(=,[EInteger(1),EInteger(2)]),
                             EInteger(20),
                             EIf(ECall(=,[EInteger(1),EInteger(1)]),
                                 EInteger(30),
                                 EBoolean(False)))
30
calc> (cond ((= 1 2) 20) ((= 1 3) 30))
Abstract representation: EIf(ECall(=,[EInteger(1),EInteger(2)]),
                             EInteger(20),
                             EIf(ECall(=,[EInteger(1),EInteger(3)]),
                                 EInteger(30),
                                 EBoolean(False)))
false
</pre>
	  </li>


	  <li><p><b>Extra:</b> Consider another form of conditional, a
	      case analysis for integers. Special form <tt>(case <i>F</i>
		(<i>L</i> <i>E</i>) ...)</tt> takes an
	      expression <i>F</i> and a  sequence of
	      clauses <tt>(<i>L</i> <i>E</i>)</tt> where each <i>L</i>
	      is a sequence of integers such as <tt>(1 2 3)</tt>
	      or <tt>(6 1 3 2 -3)</tt>. Intuitively, a <tt>case</tt>
	      evaluates as follows: <tt><i>F</i></tt> is first
	      evaluated to a value <tt><i>v</i></tt>, and then we go down the sequence of clauses,
	      for each clause checking if <tt><i>v</i></tt> is one of
	      the integers in <tt><i>L</i></tt> &mdash; if so, we
	      return the result of evaluating the
	      corresponding <tt><i>E</i></tt>, otherwise, we continue
	      down the sequence of clauses. As with <tt>cond</tt>, we
	      return <tt>false</tt> if no clause applies to
	      value <tt><i>v</i></tt>.</p>

	    <p>It is straightforward to express a <tt>case</tt> in
	      terms of <tt>if</tt>s. For example, <pre>
(case x
  ((1 2 3) 10)
  ((4 5 6) 20))</pre> can be expressed as <pre>
(let ((v x)) 
  (if (or (= v 1) (= v 2) (= v 3))
      10
      (if (or (= v 4) (= v 5) (= v 6))
          20
          false)))</pre>



	    <p>Change the
	      parser in <tt>parse()</tt> to correctly 
	      parse <tt>(case <i>F</i> (<i>L</i> <i>E</i>) ...)</tt>
              and produce an
	      equivalent abstract representation in terms
	      of <tt>if</tt> as described above.</p>


<pre class="code">
>>> shell()
Homework 4 - Calc Language
calc> (case 1)
Abstract representation: ELet([(___case___,EInteger(1))],EBoolean(False))
false
calc> (case 1 ((1 2 3) 99) ((4 5 6) 66))
Abstract representation: ELet([(___case___,EInteger(1))],
                              EIf(EIf(ECall(=,[EId(___case___),EInteger(4)]),
                                      EBoolean(True),
                                      EIf(ECall(=,[EId(___case___),EInteger(5)]),
                                          EBoolean(True),
                                          ECall(=,[EId(___case___),EInteger(6)]))),
                                  EInteger(66),
                                  EIf(EIf(ECall(=,[EId(___case___),EInteger(1)]),
                                          EBoolean(True),
                                          EIf(ECall(=,[EId(___case___),EInteger(2)]),
                                              EBoolean(True),
                                              ECall(=,[EId(___case___),EInteger(3)]))),
                                      EInteger(99),
                                      EBoolean(False))))
99
calc> (case 2 ((1 2 3) 99) ((4 5 6) 66))
Abstract representation: ELet([(___case___,EInteger(2))],
                              EIf(EIf(ECall(=,[EId(___case___),EInteger(4)]),
                                      EBoolean(True),
                                      EIf(ECall(=,[EId(___case___),EInteger(5)]),
                                          EBoolean(True),
                                          ECall(=,[EId(___case___),EInteger(6)]))),
                                  EInteger(66),
                                  EIf(EIf(ECall(=,[EId(___case___),EInteger(1)]),
                                          EBoolean(True),
                                          EIf(ECall(=,[EId(___case___),EInteger(2)]),
                                              EBoolean(True),
                                              ECall(=,[EId(___case___),EInteger(3)]))),
                                      EInteger(99),
                                      EBoolean(False))))
99
calc> (case 5 ((1 2 3) 99) ((4 5 6) 66))
Abstract representation: ELet([(___case___,EInteger(5))],
                              EIf(EIf(ECall(=,[EId(___case___),EInteger(4)]),
                                      EBoolean(True),
                                      EIf(ECall(=,[EId(___case___),EInteger(5)]),
                                          EBoolean(True),
                                          ECall(=,[EId(___case___),EInteger(6)]))),
                                  EInteger(66),
                                  EIf(EIf(ECall(=,[EId(___case___),EInteger(1)]),
                                          EBoolean(True),
                                          EIf(ECall(=,[EId(___case___),EInteger(2)]),
                                              EBoolean(True),
                                              ECall(=,[EId(___case___),EInteger(3)]))),
                                      EInteger(99),
                                      EBoolean(False))))
66
calc> (case 8 ((1 2 3) 99) ((4 5 6) 66))
Abstract representation: ELet([(___case___,EInteger(8))],
                              EIf(EIf(ECall(=,[EId(___case___),EInteger(4)]),
                                      EBoolean(True),
                                      EIf(ECall(=,[EId(___case___),EInteger(5)]),
                                          EBoolean(True),
                                          ECall(=,[EId(___case___),EInteger(6)]))),
                                  EInteger(66),
                                  EIf(EIf(ECall(=,[EId(___case___),EInteger(1)]),
                                          EBoolean(True),
                                          EIf(ECall(=,[EId(___case___),EInteger(2)]),
                                              EBoolean(True),
                                              ECall(=,[EId(___case___),EInteger(3)]))),
                                      EInteger(99),
                                      EBoolean(False))))
false
</pre>
	  </li>



	</ol>

      </li>


      <li> <p><b>The Environment Model</b></p>

	<p>If you look at our implementation of evaluation for our
	  expressions up until now, you know that the evaluation of
	  a <tt>let</tt> relies on substitution: to evaluate an
	  expression such as <tt>(let ((x 10)) <i>E</i>)</tt>, we
	  substitute <tt>10</tt> for <tt>x</tt> in <tt><i>E</i></tt>
	  and evaluate the resulting <tt><i>E</i></tt>. (Substitution
	  also arises when we evaluate a function call, but we know
	  that because the majority of you have implemented the
	  evaluation of a function call using a <tt>let</tt>!)</p>

	<p>Using substitution to implement the evaluation
	of <tt>let</tt> (and function calls) matches our intuition and
	is reasonably clean, but it's also horribly inefficient. We
	  can do a lot better, without too much effort.</p>

	<p>The intuition for an alternative implementation model is
	  that when we evaluate an expression such as <tt>(let ((x
	    10)) <i>E</i>)</tt>, instead of substituting <tt>10</tt>
	  for <tt>x</tt> in <tt><i>E</i></tt>, we instead remember
	  that <tt>x</tt> &rightarrow; <tt>10</tt>, and then we
	  evaluate <tt><i>E</i></tt>: during evaluation
	  of <tt><i>E</i></tt>, if we encounter <tt>x</tt>, we
	  return value <tt>10</tt>. </p>

	<p>This way of evaluating <tt>let</tt> is called the
	  <i>environment model</i> of evaluation, because the way we remember
	  that <tt>x</tt> &rightarrow; <tt>10</tt> is to put that information
	  in an <i>environment</i>, which records all the bindings that we've
	  seen that pertain to the current evaluation.</p>

	<p>The environment acts like a stack: when you evaluate
	a <tt>let</tt>, you push the bindings on top of the
	  environment. When you finish evaluating the body of
	the <tt>let</tt>, you pop those bindings from the environment,
	returning the environment to what it looked like before you
	  started evaluating the <tt>let</tt>. This is necessary
	because when you evaluate an expression such as:
<pre>
(let ((x 10))
   (+ (let ((y 20)) 
         (* y y))
      x))</pre>
the binding for <tt>y</tt> is only relevant to evaluate <tt>(* y
   y)</tt>. This is what the substitution model tells you, and the
   environment model should return the same result as the substitution
   model (it is just a more efficient implementation of the same
thing).</p>

<p>For a more complex example, consider the expression
<pre>
(let ((x 10))
   (+ (let ((x 20)) 
         (* x x))
      x))
</pre>
</p>

<p>
The substitution model tells you that this evaluates to 
<pre>
   (+ (let ((x 20))
         (* x x))
      10)
</pre>
which evaluates to
<pre>
   (+ 400
      10)
</pre>
that is <tt>410</tt>. </p>

<p>The environment tells you that to evaluate
<pre>
(let ((x 10))
   (+ (let ((x 20))
         (* x x))
      x))
</pre>
you add <tt>x</tt> &rightarrow; <tt>10</tt> to the environment, and
then evaluate 
<pre>
  (+ (let ((x 20))
        (* x x))
     x)
</pre>
which evaluates by first evaluating both arguments to the <tt>+</tt>
<b>in the environment containing <tt>x</tt> &rightarrow; <tt>10</tt></b>.

The first argument is
<pre>
  (let ((x 20))
     (* x x))
</pre>
which first adds <tt>x</tt> &rightarrow; <tt>20</tt> to the
environment (which is now [<tt>x</tt>
&rightarrow; <tt>20</tt>; <tt>x</tt> &rightarrow; <tt>10</tt>], with
the stack growing to the left) and then evaluates <tt>(* x x)</tt> in
that new environment. That requires looking up the value
of <tt>x</tt>, which you do from the top of the stack. The first
binding for <tt>x</tt> you find is <tt>x</tt>
&rightarrow; <tt>20</tt>, and thus <tt>(* x x)</tt> evaluates
to <tt>400</tt>. 
</p>

<p>
The second argument to <tt>+</tt> is
<pre>
  x
</pre>
which is to be evaluated, remember, in the environment
where <tt>x</tt> &rightarrow;<tt>10</tt>. This evaluates
to <tt>10</tt>, and thus we have <tt>(+ 400 10)</tt> which
yields <tt>410</tt>, the result we got from evaluation in the
substitution model. </p>

	<p>Does that make sense?</p>

	<p>Here is a simpler example: 
<pre>
(let ((x 10))
  (let ((y (+ x 1)))
    (let ((x (* y 2)))
      (* x x))))
</pre>
Again, to evaluate this expression, we first add a binding <tt>x</tt>
&rightarrow; <tt>10</tt> to the environment, then we evaluate the body
of the <tt>let</tt>. It is an other <tt>let</tt>, so we evaluate the
binding in the environment to get <tt>y</tt>
&rightarrow; <tt>11</tt>. We add this binding to the environment which now looks like [<tt>y</tt>
&rightarrow; <tt>11</tt>; <tt>x</tt> &rightarrow; <tt>10</tt>]. We
then evaluate the body of the <tt>let</tt>, which is again
a <tt>let</tt>. We evaluate the binding in the environment to
get <tt>x</tt> &rightarrow; <tt>22</tt>. We add this binding to the
environment which now looks like [<tt>x</tt> &rightarrow; <tt>22</tt>; <tt>y</tt>
&rightarrow; <tt>11</tt>; <tt>x</tt> &rightarrow; <tt>10</tt>]. We
then evaluate the body <tt>(* x x)</tt> of the let in that
environment, where we need to look up the value bound to <tt>x</tt> in
the environment, and we find the first one (remember, the top of the
stack is on the left) with value <tt>22</tt>, meaning that the final result
of the evaluation is <tt>484</tt>.</p>


	<p><b>Your first challenge for this question</b> is to add a
	  method <tt>evalEnv()</tt> to every Expression
	  node. Method <tt>evalEnv()</tt> takes
	  two arguments, a functions dictionary <tt><i>d</i></tt> as before, as well as an
	  environment <tt><i>env</i></tt>, and evaluates the
	  Expression node in environment <tt><i>env</i></tt> (and
	  resolving function names using functions
	  dictionary <tt><i>d</i></tt> as
	  before). Your <tt>evalEnv()</tt> methods should not call
	  the <tt>eval()</tt> method &mdash; <tt>evalEnv()</tt> should
	  be defined in terms of recursive <tt>evalEnv()</tt> when
	  needed.</p>

	<p>You can implement the environment however you want. A
	simple list of bindings, a more complex structure, it's up to you. As long as
	it behaves as I've indicated above, and more importantly, as
	  long as calling <tt>evalEnv()</tt> on any expression you can
	  write gives you the same result as calling <tt>eval()</tt>,
	  you should be fine. The key thing is that when you evaluate
	  the body of a <tt>let</tt>, you do so in an environment
	where you've added a binding to the original environment in
	  which you were evaluating the <tt>let</tt>.</p>

	<p><b>Your second challenge</b> is to implement a function <tt>shellEnv()</tt> that
	  works just like <tt>shell()</tt> except it
	  uses <tt>evalEnv()</tt> to evaluate the expressions you
	  enter, instead of <tt>eval()</tt>. Any top-level expression
	  you evaluate should be evaluated in the empty environment,
	  whatever that may mean for your choice of representation for
	  the environment.</p>

	<p><i>Note: If you search for "environment model of evaluation" you
	will find a lot of links online, some more useful than
	others. Many of them spend most of their time on the problem of implementing
	the environment model of evaluation for first-class functions, which we will not see
	    deeply until next lecture.</i></p>
  

      </li>


    </ol>
    

  </body>
</html>

<!DOCTYPE html>
<html>

  <head>
    
    <meta charset="utf-8">
    <title>Homework 4</title>

    <link rel="stylesheet" href="alt.css" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,800,700' rel='stylesheet' type='text/css'>

    <script src="autoscroll.js"></script>
    
    <style>

      hr { margin-top: 50px; }

        code,tt,pre {
          font-size: 130%;
        }
	
        div.lect {
	  padding-top: 0;
       	  padding-left: 3em;
	  margin-top:0;
        }
    	p.ann { 
    	  padding-left: 3em;
    	  text-indent: -3em; 
    	}
	p.ann_ctd{
	  padding-left: 3em;
        }
    	span.hdr {
   	  padding-right: 1em
    	}

	.hidden {
	  visibility: hidden;
        }

        tt.code {
           background: #e6e6e6;
        }

	pre.code {
	   border: 1px solid #c6c6c6;
	border-radius: 5px;
	padding: 10px;
	font-size:100%;
	}

/* from
    http://www.456bereastreet.com/archive/201105/styling_ordered_list_numbers/
 */

ol {
    counter-reset:li; /* Initiate a counter */
    margin-left:0; /* Remove the default left margin */
    padding-left:0; /* Remove the default left padding */
    padding-top:1em;
}
ol > li {
    position:relative; /* Create a positioning context */
    margin:0 0 6px 2em; /* Give each list item a left margin to make
    room for the numbers */
    padding:4px 8px; /* Add some spacing around the content */
    list-style:none; /* Disable the normal item numbering */
    /*border-top:2px solid #666;
    background:#f6f6f6; */
}
ol > li:before {
    counter-increment:li; /* Increment the counter by 1 */
    /* Position and style the number */
    position:absolute;
    top:-2px;
    left:-2em;
    -moz-box-sizing:border-box;
    -webkit-box-sizing:border-box;
    box-sizing:border-box;
    width:2em;
    /* Some space between the number and the content in browsers that
    support
       generated content but not positioning it (Camino 2 is one
    example) */
    margin-right:8px;
    padding:4px;
/*    border-top:2px solid #666;
    color:#fff;
    background:#666; 
    font-weight:bold; */
/*    font-family:"Helvetica Neue", Arial, sans-serif;
    text-align:center; */
}

ol.letter > li:before {
    content:"(" counter(li,lower-alpha) ")"; /* Use the counter as content */
}

ol.number > li:before {
    content:"(" counter(li,decimal) ")"; /* Use the counter as content */
}

li ol,
li ul {margin-top:6px;}

li > p { margin-top:0;}

    </style>

  </head>


  <body>

    <div class="navbar">

      <div class="home">
	<a href="../../index.html"><img src="../../home.png" style="height: 1.6em;"></a>
      </div>

      <ul>
	<li><a href="index.html"><b>Foundations of Computer Science SP16</b></a></li> 
	<li class="hidden"><a class="scrollto" href="#announcements">Announcements</a></li>
	<li class="hidden"><a class="scrollto" href="#info">Course Info</a></li>
	<li class="hidden"><a class="scrollto" href="#lectures">Lectures</a></li>
	<li class="hidden"><a class="scrollto" href="#homeworks">Homeworks</a></li>
      </ul>
    </div>


    <!-- padding -->
    <div id="top" style="height: 7em;"></div>
    
    <h1 class="clear">Homework 4</h1>
    
    <p class="subtitle">Due date: Friday, February 19 (midnight)</p>

    <p><b>Note on integrity:</b> This homework is meant to be done
    individually. You may discuss problems with fellow students, but
    all work must be entirely your own, and should not be from any
    other course, present, past, or future. If you use a solution from
    another source you must cite it &mdash; this includes when that source
      is someone else helping you.</p>

    <p>Every source file you submit should begin with a block comment
      that lists your <span style="text-decoration:underline;">name</span>, your <span style="text-decoration:underline;">email address</span>, and any <span style="text-decoration:underline;">remarks</span> that you
      wish to make to the instructor.</p>

    <p>All programming is to be done in OCaml v4.</p>

    <p>Feel free to define helper functions if you need them.</p>

    <p>Please code your answers by modifying the
      file <a href="homework4.ml"><tt>homework4.ml</tt></a> provided.</p>

    <p>Electronic submission instructions:</p>

    <ul>
      <li>Download the file <a href="hw4-checker.ml"><tt>hw4-checker.ml</tt></a> into the same directory as your homework solution.</li>
      <li>Start a <i>new</i> OCaml shell.</li>
      <li>Load your homework code via <tt>#use "homework4.ml";;</tt></li>
      <li>Load the homework checker via <tt>#use "hw4-checker.ml";;</tt></li>
      <li>The homework checker checks that you've implemented all functions (or provided stubs for them) and that those functions have the type that I asked you to give them. If the checker says your types are OK, then you're fine. If the checker gives you an error, fix it. If you believe that the checker gives you an error wrongly, send me an email.</li>
      <li>When you're ready to submit, send an email with your file <tt>homework4.ml</tt> as an attachment to <tt>focs.sp16@gmail.com</tt> with subject <i>Homework 4 submission</i>.</li>
    </ul>

    <p>If your code fails because you did not follow the instructions above (in particular, because your code fails to type check when put in presence of my automated testing rig) I'll be unhappy.</p>


    <hr>

    <p>Now that we have the notion of passing functions around as values, we can use a much better type for <i>deterministic finite automata</i>:</p>
    <pre>
   type 'a dfa = { states: 'a list;
                   alphabet: char list;
                   delta: 'a -> char -> 'a;
                   start : 'a;
                   accepting : 'a list }
</pre>
    <p>Everything is pretty much as before (states, alphabet, start state, accepting states) but the transition relation is now a function, and by that, I mean a real OCaml function: it takes a state of type <tt>'a</tt> and an alphabet symbol of type <tt>char</tt> and gives you back a new state.</p>

    <p>No more searching for transitions matching the one you're looking for. Now, you get the state you want pretty much directly. As a bonus, you can use pattern matching to define the function that represents the transitions.</p>

<p>Here is the new version of the deterministic finite automaton that
  we saw in the last homework, the one which accepts the set of all
  strings over <tt>{a,b}</tt> that contains a number of <tt>a</tt>s
  that is a multiple of 3.
</p>

<pre>
   let dfaThreeA = { 
     states = ["start";"one";"two"];
     alphabet = ['a';'b'];
     delta = (fun q a -> 
               match (q,a) with
                 ("start",'a') -> "one"
               | ("one",'a') -> "two"
               | ("two",'a') -> "start"
               | ("start",'b') -> "start"
               | ("one",'b') -> "one"
               | ("two",'b') -> "two");
     start = "start";
     accepting = ["start"]
   } 
</pre>

    <hr>
    
    <ol class="number">
      <li> <p><b>Deterministic Finite Automata Revisited</b></p>

	<ol class="letter">

<!--
	  <li> <p>Code a function <tt class="code">???</tt> of
	      type <tt class="code">???</tt> which...
	    </p>

<pre class="code">
</pre>
	  </li>
-->

	  <li> <p>Code a function <tt class="code">isAccepting</tt> of
	      type <tt class="code">'a dfa -> 'a -> bool</tt> which
	      takes a deterministic finite automaton <i>m</i> (of the
	      type <tt>dfa</tt> above) and a state <i>q</i>
	      of <i>m</i> and returns true when <i>q</i> is an
	      accepting states and false otherwise.</p>

	    <p>Note the type of the function. It should be a curried
	    function, like every other function in this homework.</p> 
	     
<pre class="code">
# isAccepting dfaThreeA "start";;
- : bool = true
# isAccepting dfaThreeA "one";;
- : bool = false
# isAccepting dfaThreeA "two";;
- : bool = false
</pre>
	  </li>



	  <li> <p>Code a function <tt class="code">steps</tt> of
	      type <tt class="code">'a dfa -> 'a -> char list -> 'a</tt>
	      which takes a deterministic finite automaton <i>m</i>, a
		  state <i>q</i> of <i>m</i>, and a list of
	      symbols <i>l</i> of 
		the alphabet of <i>m</i>, and returns the state
		of <i>m</i> resulting from following the transitions
	      of <i>m</i> from <i>q</i> according to the symbols
	      in <i>l</i>.</p>
	    </p>

	    <pre class="code">
# steps dfaThreeA "start" [];;
- : string = "start"
# steps dfaThreeA "start" ['a'];;
- : string = "one"
# steps dfaThreeA "start" ['a';'b'];;
- : string = "one"
# steps dfaThreeA "start" ['a';'b';'a'];;
- : string = "two"
# steps dfaThreeA "one" [];;
- : string = "one"
# steps dfaThreeA "one" ['a'];;
- : string = "two"
# steps dfaThreeA "one" ['a';'b'];;
- : string = "two"
# steps dfaThreeA "one" ['a';'b';'a'];;
- : string = "start"
</pre>
	  </li>


	  <li> <p>Code a function <tt class="code">acceptDFA</tt> of
	      type <tt class="code">'a dfa -> string -> bool</tt> which
	      takes a deterministic finite automaton <i>m</i> and a string <i>s</i>
	      over the alphabet of <i>m</i>, and returns true if <i>m</i>
	      accepts <i>s</i>, and false otherwise. 
	    </p>

	    <p>You can use function <tt>explode</tt> (provided in the
	      homework code) to turn a string into a list of
	      characters.</p>

	    <p>For testing purposes, I've provided you also with a
	      function <tt>langDFA</tt> where <tt>langDFA m k</tt>
	      prints out all the strings of length up to <tt>k</tt>
	      accepted by the deterministic finite
	      automaton <tt>m</tt>. Note that it calls your
	      function <tt>acceptDFA</tt>, so it won't work correctly
	      until you implement that.

	    <pre class="code">
# acceptDFA dfaThreeA "";;
- : bool = true
# acceptDFA dfaThreeA "a";;
- : bool = false
# acceptDFA dfaThreeA "b";;
- : bool = true
# acceptDFA dfaThreeA "aa";;
- : bool = false
# acceptDFA dfaThreeA "aaa";;
- : bool = true
# acceptDFA dfaThreeA "ababa";;
- : bool = true
# acceptDFA dfaThreeA "abababa";;
- : bool = false
# langDFA dfaThreeA 6;;
  &lt;epsilon&gt;
  b
  bb
  aaa
  bbb
  baaa
  abaa
  aaba
  aaab
  bbbb
  bbaaa
  babaa
  abbaa
  baaba
  ababa
  aabba
  baaab
  abaab
  aabab
  aaabb
  bbbbb
  aaaaaa
  bbbaaa
  bbabaa
  babbaa
  abbbaa
  bbaaba
  bababa
  abbaba
  baabba
  ababba
  aabbba
  bbaaab
  babaab
  abbaab
  baabab
  ababab
  aabbab
  baaabb
  abaabb
  aababb
  aaabbb
  bbbbbb
- : unit = ()
</pre>
	  </li>


	</ol>
      </li>

      <li> <p><b>Higher-Order Functions</b></p>

	<p>For each function you have to code in this question, full
	  points will be awarded if the 
	  function does not use explicit recursion &mdash; that is, if you use
	  <tt>List.map</tt> or <tt>List.filter</tt>
	  or <tt>List.fold_right</tt>. If you can't get it to 
	  work without recursion, please provide a version with explicit recursion.</p>

	<ol class="letter">

	  <li>
	    <p>The OCaml <tt>List</tt> module contains
	  functions <tt>for_all</tt> and <tt>exists</tt> that both
	    take a predicate and a list, and return <tt>true</tt> if all the
	    elements of the list satisfy the predicate (for
	    <tt>for_all</tt>), or at least one element of the list satisfies
	    the predicate (for <tt>exists</tt>).</p>

	    <p>Code a function <tt class="code">at_least</tt> of
	      type <tt class="code">int -> ('a -> bool) -> 'a list -> bool</tt>
	      where <tt>at_least n p xs</tt> returns <tt>true</tt> exactly when there are
	      at least <tt>n</tt> elements in <tt>xs</tt> that satisfy predicate <tt>p</tt>.</p>

<pre class="code">
# at_least 0 (fun x -> x) [];;
- : bool = true
# at_least 1 (fun x -> x) [];;
- : bool = false
# at_least 0 (fun x -> x) [true;true;false];;
- : bool = true
# at_least 1 (fun x -> x > 0) [2;3;0];;
- : bool = true
# at_least 2 (fun x -> x > 0) [2;3;0];;
- : bool = true
# at_least 3 (fun x -> x > 0) [2;3;0];;
- : bool = false
</pre>
	  </li>

	  <li>
	    <p>Code a function <tt class="code">max_positive</tt> of
	      type <tt class="code">int list -> int</tt>
	      where <tt>max_positive xs</tt> returns the maximum
	      positive element in list <tt>xs</tt> if one
	      exists, and 0 otherwise.</p>

<pre class="code">
# max_positive [];;
- : int = 0
# max_positive [4];;
- : int = 4
# max_positive [4;5];;
- : int = 5
# max_positive [5;4];;
- : int = 5
# max_positive [4;6;5];;
- : int = 6
# max_positive [-1;-2;-3];;
- : int = 0
</pre>
	  </li>

	  <li>
	    <p>Code a function <tt class="code">map_funs</tt> of
	      type <tt>('a -> 'b) list -> 'a -> 'b list</tt>
	      where <tt>map_funs fs x</tt> returns the results of
	      applying every function in <tt>fs</tt> to <tt>x</tt>.</p>

<pre class="code">
# let dbl x = "double of "^(string_of_int x);;
val dbl : int -> string = <fun>
# let neg x = "negation of "^(string_of_int x);;
val neg : int -> string = <fun>

# map_funs [] 3;;
- : 'a list = []
# map_funs [dbl] 3;;
- : string list = ["double of 3"]
# map_funs [dbl;neg] 3;;
- : string list = ["double of 3"; "negation of 3"]
# map_funs [dbl;neg;dbl] 3;;
- : string list = ["double of 3"; "negation of 3"; "double of 3"]
# map_funs [(fun x -> x * 2); (fun x -> x * x)] 10;;
- : int list = [20; 100]
# map_funs [(fun x -> "+"^x); (fun x -> "-"^x)] "hello";;
- : string list = ["+hello"; "-hello"]
</pre>
	  </li>


	  <li>
	    <p>Code a function <tt class="code">map_cross</tt> of type
	      <tt class="code">('a -> 'b) list -> 'a list -> 'b
		list</tt> where <tt>map_cross fs xs</tt> returns all the results of
	      applying a function in <tt>fs</tt> to a value
	      in <tt>xs</tt>. </p>

<pre class="code">
# let dbl x = "double of "^(string_of_int x);;
val dbl : int -> string = <fun>
# let neg x = "negation of "^(string_of_int x);;
val neg : int -> string = <fun>

# map_cross [] [];;
- : 'a list = []
# map_cross [] [1;2;3];;
- : 'a list = []
# map_cross [dbl; neg] [];;
- : string list = []
# map_cross [dbl] [3];;
- : string list = ["double of 3"]
# map_cross [dbl] [1;2;3];;
- : string list = ["double of 1"; "double of 2"; "double of 3"]
# map_cross [dbl;neg] [3];;
- : string list = ["double of 3"; "negation of 3"]
# map_cross [dbl;neg] [1;2;3];;
- : string list =
["double of 1"; "negation of 1"; "double of 2"; "negation of 2"; "double of 3"; "negation of 3"]
# map_cross [(fun x -> "+"^x);(fun x -> "-"^x)] ["hello";"world"];;
- : string list = ["+hello"; "-hello"; "+world"; "-world"]
</pre>
	  </li>


	  <li>
	    <p>Code a function <tt class="code">all_pairings</tt> of type
	      <tt class="code">'a list -> 'b list -> ('a * 'b)
	      list</tt> where <tt>all_pairings xs ys</tt> returns all
	      the ways of pairing up an element of <tt>xs</tt> with an
	      element of <tt>ys</tt>.</p>

<pre class="code">
# all_pairings [] [];;
- : ('a * 'b) list = []
# all_pairings [1;2] [];;
- : (int * 'a) list = []
# all_pairings [] ["a";"b";"c"];;
- : ('a * string) list = []
# all_pairings [1] ["a";"b";"c"];;
- : (int * string) list = [(1, "a"); (1, "b"); (1, "c")]
# all_pairings [1;2] ["a"];;
- : (int * string) list = [(1, "a"); (2, "a")]
# all_pairings [1;2] ["a";"b";"c"];;
- : (int * string) list =
[(1, "a"); (1, "b"); (1, "c"); (2, "a"); (2, "b"); (2, "c")]
</pre>
	  </li>


	</ol>

      </li>

      <li> <p><b>Advanced Higher-Order Functions</b></p>

	<p>For each function you have to code in this question, full
	  points will be awarded if the 
	  function does not use explicit recursion &mdash; that is, if you use
	  <tt>List.map</tt> or <tt>List.filter</tt>
	  or <tt>List.fold_right</tt>. If you can't get it to 
	  work without recursion, please provide a version with explicit recursion.</p>


	<ol class="letter">

	<li>
	  <p>Code a function <tt class="code">prefixes</tt> of
	    type <tt class="code">'a list -> 'a list list</tt>
	    where <tt>prefixes xs</tt> returns the list of all
	    prefixes of <tt>xs</tt>: if 
	    <tt>xs</tt> is <tt>[x1; x2; x3]</tt> then the prefixes
	    of <tt>xs</tt> are <tt>[]</tt>, <tt>[x1]</tt>, <tt>[x1;
	    x2]</tt>, and <tt>[x1; x2; x3]</tt>. (Note that the empty 
	    list is a prefix of every list.)</p>

<pre class="code">
# prefixes [];;
- : 'a list list = [[]]
# prefixes [1];;
- : int list list = [[]; [1]]
# prefixes [1;2;3;4];;
- : int list list = [[]; [1]; [1; 2]; [1; 2; 3]; [1; 2; 3; 4]]
# prefixes ["a";"b"];;
- : string list list = [[]; ["a"]; ["a"; "b"]]
</pre>

	</li>


	<li>
	  <p>Code a function <tt class="code">suffixes</tt> of
	    type <tt class="code">'a list -> 'a list list</tt>
	    where <tt>suffixes xs</tt> returns the list of all
	    suffixes of <tt>xs</tt>: if <tt>xs</tt> is <tt>[x1; x2; x3]</tt> then the suffixes of <tt>xs</tt>
	    are <tt>[x1; x2; x3]</tt>, <tt>[x2; x3]</tt>, <tt>[x3]</tt>, and <tt>[]</tt>. (Note that
	    the empty list is a suffix of every list.)</p>

<pre class="code">
# suffixes [];;
- : 'a list list = [[]]
# suffixes [1];;
- : int list list = [[1]; []]
# suffixes [1;2;3;4];;
- : int list list = [[1; 2; 3; 4]; [2; 3; 4]; [3; 4]; [4]; []]
# suffixes ["a";"b";"c"];;
- : string list list = [["a"; "b"; "c"]; ["b"; "c"]; ["c"]; []]
</pre>

	</li>


	<li>
	  <p>Code a function <tt class="code">inject</tt> of
	    type <tt class="code">'a -> 'a list -> 'a list list</tt>
	    where <tt>inject a xs</tt> returns all the ways in which value 
	    <tt>a</tt> can be added to the list <tt>xs</tt>. </p>

<pre class="code">
# inject 99 [];;
- : int list list = [[99]]
# inject 99 [1];;
- : int list list = [[99; 1]; [1; 99]]
# inject 99 [1;2];;
- : int list list = [[99; 1; 2]; [1; 99; 2]; [1; 2; 99]]
# inject 99 [1;2;3;4];;
- : int list list =
[[99; 1; 2; 3; 4]; [1; 99; 2; 3; 4]; [1; 2; 99; 3; 4]; [1; 2; 3; 99; 4]; [1; 2; 3; 4; 99]]
# inject "X" ["a";"b"];;
- : string list list = [["X"; "a"; "b"]; ["a"; "X"; "b"]; ["a"; "b"; "X"]]
</pre>
	  <p><i>
	    This is probably the most difficult question on all the
	    homeworks until now. My suggestion: come up with a recursive definition for
	    <tt>inject</tt>, then complete the rest of this
	    question. When you're done, come back to this one and try
	    to write <tt>inject</tt> without explicit recursion. There
	    are a couple of ways of doing it. If you go the route that
	    I always go down, you'll notice that at some point you
	    need information that you do not have, and you'll need to
	    figure out a way to get that information, somehow. (Yes, I
	    could be more nebulous, but that would require effort, and
	    it's late.)</i></p>

	</li>


	<li>
	  <p>Code a function <tt class="code">permutations</tt> of type
	  <tt class="code">'a list -> 'a list list</tt> where <tt>permutations
	    xs</tt> returns the list of all permutations
	    of <tt>xs</tt>. (A permutation of a list is a list
	    containing the exact same elements, but in a different
	  order, treating repeated elements as distinct.) </p>

<pre class="code">
# permutations [];;
- : 'a list list = [[]]
# permutations [1];;
- : int list list = [[1]]
# permutations [1;2];;
- : int list list = [[1; 2]; [2; 1]]
# permutations [1;2;3;4];;
- : int list list =
[[1; 2; 3; 4]; [2; 1; 3; 4]; [2; 3; 1; 4]; [2; 3; 4; 1]; [1; 3; 2; 4];
 [3; 1; 2; 4]; [3; 2; 1; 4]; [3; 2; 4; 1]; [1; 3; 4; 2]; [3; 1; 4; 2];
 [3; 4; 1; 2]; [3; 4; 2; 1]; [1; 2; 4; 3]; [2; 1; 4; 3]; [2; 4; 1; 3];
 [2; 4; 3; 1]; [1; 4; 2; 3]; [4; 1; 2; 3]; [4; 2; 1; 3]; [4; 2; 3; 1];
 [1; 4; 3; 2]; [4; 1; 3; 2]; [4; 3; 1; 2]; [4; 3; 2; 1]]
# permutations ["a";"b"];;
- : string list list = [["a"; "b"]; ["b"; "a"]]
</pre>
	</li>


	</ol>

      </li>



    </ol>
	
    

  </body>
</html>

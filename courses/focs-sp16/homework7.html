<!DOCTYPE html>
<html>

  <head>
    
    <meta charset="utf-8">
    <title>Homework 7</title>

    <link rel="stylesheet" href="alt.css" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,800,700' rel='stylesheet' type='text/css'>

    <script src="autoscroll.js"></script>
    
    <style>

      hr { margin-top: 50px; }

        code,tt,pre {
          font-size: 140%;
        }
	
        div.lect {
	  padding-top: 0;
       	  padding-left: 3em;
	  margin-top:0;
        }
    	p.ann { 
    	  padding-left: 3em;
    	  text-indent: -3em; 
    	}
	p.ann_ctd{
	  padding-left: 3em;
        }
    	span.hdr {
   	  padding-right: 1em
    	}

	.hidden {
	  visibility: hidden;
        }

        tt.code {
           background: #e6e6e6;
        }

	pre.code {
	   border: 1px solid #c6c6c6;
	border-radius: 5px;
	padding: 10px;
	font-size:100%;
	}

/* from
    http://www.456bereastreet.com/archive/201105/styling_ordered_list_numbers/
 */

ol {
    counter-reset:li; /* Initiate a counter */
    margin-left:0; /* Remove the default left margin */
    padding-left:0; /* Remove the default left padding */
    padding-top:1em;
}
ol > li {
    position:relative; /* Create a positioning context */
    margin:0 0 6px 2em; /* Give each list item a left margin to make
    room for the numbers */
    padding:4px 8px; /* Add some spacing around the content */
    list-style:none; /* Disable the normal item numbering */
    /*border-top:2px solid #666;
    background:#f6f6f6; */
}
ol > li:before {
    counter-increment:li; /* Increment the counter by 1 */
    /* Position and style the number */
    position:absolute;
    top:-2px;
    left:-2em;
    -moz-box-sizing:border-box;
    -webkit-box-sizing:border-box;
    box-sizing:border-box;
    width:2em;
    /* Some space between the number and the content in browsers that
    support
       generated content but not positioning it (Camino 2 is one
    example) */
    margin-right:8px;
    padding:4px;
/*    border-top:2px solid #666;
    color:#fff;
    background:#666; 
    font-weight:bold; */
/*    font-family:"Helvetica Neue", Arial, sans-serif;
    text-align:center; */
}

ol.letter > li:before {
    content:"(" counter(li,lower-alpha) ")"; /* Use the counter as content */
}

ol.number > li:before {
    content:"(" counter(li,decimal) ")"; /* Use the counter as content */
}

li ol,
li ul {margin-top:6px;}

li > p { margin-top:0;}

    </style>

  </head>


  <body>

    <div class="navbar">

      <div class="home">
	<a href="../../index.html"><img src="../../home.png" style="height: 1.6em;"></a>
      </div>

      <ul>
	<li><a href="index.html"><b>Foundations of Computer Science SP16</b></a></li> 
	<li class="hidden"><a class="scrollto" href="#announcements">Announcements</a></li>
	<li class="hidden"><a class="scrollto" href="#info">Course Info</a></li>
	<li class="hidden"><a class="scrollto" href="#lectures">Lectures</a></li>
	<li class="hidden"><a class="scrollto" href="#homeworks">Homeworks</a></li>
      </ul>
    </div>


    <!-- padding -->
    <div id="top" style="height: 7em;"></div>
    
    <h1 class="clear">Homework 7</h1>
    
    <p class="subtitle">Due date: Saturday, April 2nd (midnight)</p>

    <p><b>Note on integrity:</b> This homework is meant to be done
    individually. You may discuss problems with fellow students, but
    all work must be entirely your own, and should not be from any
    other course, present, past, or future. If you use a solution from
    another source you must cite it &mdash; this includes when that source
      is someone else helping you.</p>

    <p>Every source file you submit should begin with a block comment
      that lists your <span style="text-decoration:underline;">name</span>, your <span style="text-decoration:underline;">email address</span>, and any <span style="text-decoration:underline;">remarks</span> that you
      wish to make to the instructor.</p>

    <p>All programming is to be done in OCaml v4.</p>

    <p>Feel free to define helper functions if you need them.</p>

    <p>Please code your answers by modifying the
      file <a href="homework7.ml"><tt>homework7.ml</tt></a> provided.</p>

    <p>Electronic submission instructions:</p>

    <ul>
      <li>Download the file <a href="hw7-checker.ml"><tt>hw7-checker.ml</tt></a> into the same directory as your homework solution.</li>
      <li>Start a <i>new</i> OCaml shell.</li>
      <li>Load your homework code via <tt>#use "homework7.ml";;</tt></li>
      <li>Load the homework checker via <tt>#use "hw7-checker.ml";;</tt></li>
      <li>The homework checker checks that you've implemented all functions (or provided stubs for them) and that those functions have the type that I asked you to give them. If the checker says your types are OK, then you're fine. If the checker gives you an error, fix it. If you believe that the checker gives you an error wrongly, send me an email.</li>
      <li>When you're ready to submit, send an email with your file <tt>homework7.ml</tt> as an attachment to <tt>focs.sp16@gmail.com</tt> with subject <i>Homework 7 submission</i>.</li>
    </ul>

    <p>If your code fails because you did not follow the instructions above (in particular, because your code fails to type check when put in presence of my automated testing rig) I'll be unhappy.</p>


    <hr>


    <p>Here is a type for <i>generative grammars:</i></p>

    <pre>
type grammar = {
  nonterminals: string list;
  terminals: string list;
  rules: (string * string) list;
  startsym : string
}    </pre>
<p>Recall that a grammar is described by a set of nonterminal symbols, a set of terminal
    symbols, a set of rules, and a starting symbol. The following
  grammar with
starting nonterminal S
  and terminals <tt>a</tt> and <tt>b</tt>
  generates the language
      {<tt>a</tt><sup>n</sup><tt>b</tt><sup>n</sup> | n&ge;0}:</p>
    <p>&nbsp;S &#x2192; &epsilon;<br>
    &nbsp;S &#x2192; <tt>a</tt> S <tt>b</tt> </p>

    <p>Here is how you represent that grammar with the type above:</p>
<pre>
let anbn = {
  nonterminals = ["S"];
  terminals = ["a";"b"];
  rules = [("S","");
           ("S","aSb")];
  startsym = "S"
}</pre>
    <p>Note that a rule P &#x2192; Q is represented by a pair (P,Q)
    where P and Q are strings containing terminal and nonterminal
      symbols.</p>

    <p>Here is a grammar generating the language {<tt>a</tt><sup>n</sup><tt>b</tt><sup>m</sup> | m&ge;n&ge;0}:</p>

<pre>
let anbm = {
  nonterminals = ["S";"T";"B"];
  terminals = ["a";"b"];
  rules = [ ("S","TB");
            ("T","");
	    ("T","aTb");
	    ("B","");
	    ("B","Bb")];
  startsym = "S"
}</pre>

<p>To check whether a string can be generated from a grammar, I
  provided you with a function
<pre>
    generate: int -> grammar -> string -> bool
</pre>
Intuitively, <tt>generate n gr str</tt> checks whether string <tt>str</tt>
can be generated by grammar <tt>gr</tt>, and returns true or false. If
true, the function also prints a sequence of rewrites that shows how
the string is generated. For example:</p>
<pre>
# generate 10 anbm "aabbb";;
Searching (depth 01, max width 1)
Searching (depth 02, max width 2)
Searching (depth 03, max width 3)
Searching (depth 04, max width 4)
Searching (depth 05, max width 5)
Searching (depth 06, max width 6)
   S
-> TB
-> aTbB
-> aaTbbB
-> aabbB
-> aabbBb
-> aabbb
- : bool = true</pre>

<p> What's argument <tt>n</tt>, you ask? Well,
checking if a string can be generated by a grammar is done by taking
the starting symbol, and repeatedly applying all possible rules until
the string is generated. That's expensive. Also, if the string cannot
be generated, then this process never terminates. (Question: why is
  that? Why can't we do better?) To control the process and prevent
  the search to go on forever, rules are applying only
up to <i>depth</i> <tt>n</tt> (that is, up to <tt>n</tt> rules can be
applied in any sequence of rewrites &mdash; moreover, the maximum width of
string that can be obtained during any of those rewrites is
also <tt>n</tt>). This means, in particular, that if you know that a
string requires K rewrites to be generated, then you need to supply a
value of at least K to function <tt>generate</tt>. The tricky bit is that the
largest the parameter <tt>n</tt>, the slowest the generation process, because the tree of rewrites being searched gets bigger
as <tt>n</tt> increases. If your grammars get too complicated,
don't be surprised if it gets difficult to generate strings
you <i>know</i> can be generated.</p>

    <p>Here's a sample generation that fails because the search depth
    is too low:</p>
<pre>
# generate 10 anbm "aaaaaabbbbbb";;
Searching (depth 01, max width 1)
Searching (depth 02, max width 2)
Searching (depth 03, max width 3)
Searching (depth 04, max width 4)
Searching (depth 05, max width 5)
Searching (depth 06, max width 6)
Searching (depth 07, max width 7)
Searching (depth 08, max width 8)
Searching (depth 09, max width 9)
Searching (depth 10, max width 10)
Searching (depth 11, max width 11)
- : bool = false</pre>
    <p>Increasing the depth gets us the string:</p>
<pre>
# generate 13 anbm "aaaaaabbbbbb";;
Searching (depth 01, max width 1)
Searching (depth 02, max width 2)
Searching (depth 03, max width 3)
Searching (depth 04, max width 4)
Searching (depth 05, max width 5)
Searching (depth 06, max width 6)
Searching (depth 07, max width 7)
Searching (depth 08, max width 8)
Searching (depth 09, max width 9)
Searching (depth 10, max width 10)
Searching (depth 11, max width 11)
Searching (depth 12, max width 12)
Searching (depth 13, max width 13)
   S
-> TB
-> aTbB
-> aaTbbB
-> aaaTbbbB
-> aaaaTbbbbB
-> aaaaaTbbbbbB
-> aaaaaTbbbbb
-> aaaaaaTbbbbbb
-> aaaaaabbbbbb
- : bool = true</pre>
    
    <hr>
    
    <ol class="number">

      <li> <p><b>Context-Free Grammars</b></p>

	<p>In this question,  I ask you to define context-free
	grammars as constants using <tt>let</tt> with a fixed name
	given below in each question. There is already a placeholder
	in homework7.ml for those answers. Just replace the
	placeholder with your definition.</p> 

	<ol class="letter">

<!--
	  <li> <p>Code a function <tt class="code">???</tt> of
	      type <tt class="code">???</tt> which...
	    </p>

<pre class="code">
</pre>
	  </li>
-->

<li><p>Define a context-free grammar <tt class="code">palindromes</tt>
    of type <tt class="code">grammar</tt>
    that generates all palindromes over alphabet
    {<tt>a</tt>,<tt>b</tt>,<tt>c</tt>}. Remember that a palindrome is
    a string that reads the same left-to-right and right-to-left, such
    as <tt>aba</tt> or <tt>ccddcc</tt>.</p> 

	  </li>

<li><p>Define a context-free grammar <tt class="code">ambncmn</tt>
    of type <tt class="code">grammar</tt>
    that generates the language
    {<tt>a</tt><sup>m</sup><tt>b</tt><sup>n</sup><tt>c</tt><sup>m+n</sup>
    | m, n &ge; 0}, i.e., the set of all strings made up
    of <tt>a</tt>s followed by <tt>b</tt>s 
    followed by <tt>c</tt>s, where there are as many <tt>c</tt>s as <tt>a</tt>s and <tt>b</tt>s together.</p>
      
	  </li>


<li><p>Define a context-free grammar <tt class="code">amcmnbn</tt>
    of type <tt class="code">grammar</tt>
    that generates the language
    {<tt>a</tt><sup>m</sup><tt>c</tt><sup>m+n</sup><tt>b</tt><sup>n</sup>
    | m, n &ge; 0}, i.e., the set of all strings made up
    of <tt>a</tt>s followed by <tt>c</tt>s 
    followed by <tt>b</tt>s, where there are as many <tt>c</tt>s as <tt>a</tt>s and <tt>b</tt>s together.</p>
      
	  </li>


<li><p>Define a context-free grammar <tt class="code">ambncm</tt>
    of type <tt class="code">grammar</tt> that
    generates the language
    {<tt>a</tt><sup>m</sup><tt>b</tt><sup>n</sup><tt>c</tt><sup>m</sup>
    | m, n &ge; 0}, i.e., the set of all strings made up
    of <tt>a</tt>s followed by <tt>b</tt>s 
    followed by <tt>c</tt>s, where there are as many <tt>a</tt>s as <tt>c</tt>s.</p>
      
	  </li>


<li><p>Define a context-free grammar <tt class="code">eqnum</tt> 
    of type <tt class="code">grammar</tt>
    that
    generates all strings over {<tt>d</tt>,<tt>e</tt>} that have an
    equal number of <tt>d</tt>s and <tt>e</tt>s.</p> 
      
	  </li>

	</ol>

      </li>


<li> <p><b>Finite Automata and Grammars</b></p>

  <p>Recall the type for deterministic finite automata from homework
    3:</p>
  <pre>
type 'a dfa = { states: 'a list;
		alphabet: char list;
		delta: 'a -> char -> 'a;
		start : 'a;
		accepting : 'a list }  </pre>

  <p>In class, I described a way to convert a deterministic finite
  automaton to a context-free grammar that generates the language accepted by the
  automaton.</p>  

 <p>Code a function <tt class="code">dfaGrammar</tt> of
	      type <tt class="code">string dfa -> grammar</tt> which
	      takes a deterministic finite automaton with strings (of
	      length 1) as states, and returns a context-free grammar
	      generating the language accepted by the automaton.
	    </p>

  <p>I gave you a sample DFA <tt>dfaThreeA</tt> that accepts all
    strings over {<tt>a</tt>,<tt>b</tt>} with a multiple-of-three
    number of <tt>a</tt>s, but feel free to define your own for testing.</p>

	    <p>(The depth parameters in the examples below are dependent on
	      the grammar you create.)</p>

<pre class="code">
# generate 10 (dfaGrammar dfaThreeA) "bb";;
Searching (depth 01, max width 1)
Searching (depth 02, max width 2)
Searching (depth 03, max width 3)
   S
-> ...
- : bool = true
# generate 10 (dfaGrammar dfaThreeA) "ababa";;
Searching (depth 01, max width 1)
Searching (depth 02, max width 2)
Searching (depth 03, max width 3)
Searching (depth 04, max width 4)
Searching (depth 05, max width 5)
Searching (depth 06, max width 6)
   S
-> ...
- : bool = true
# generate 10 (dfaGrammar dfaThreeA) "bababbbab";;
Searching (depth 01, max width 1)
Searching (depth 02, max width 2)
Searching (depth 03, max width 3)
Searching (depth 04, max width 4)
Searching (depth 05, max width 5)
Searching (depth 06, max width 6)
Searching (depth 07, max width 7)
Searching (depth 08, max width 8)
Searching (depth 09, max width 9)
Searching (depth 10, max width 10)
   S
-> ...
- : bool = true
# generate 13 (dfaGrammar dfaThreeA) "bababbbaaaab";;
Searching (depth 01, max width 1)
Searching (depth 02, max width 2)
Searching (depth 03, max width 3)
Searching (depth 04, max width 4)
Searching (depth 05, max width 5)
Searching (depth 06, max width 6)
Searching (depth 07, max width 7)
Searching (depth 08, max width 8)
Searching (depth 09, max width 9)
Searching (depth 10, max width 10)
Searching (depth 11, max width 11)
Searching (depth 12, max width 12)
Searching (depth 13, max width 13)
   S
-> ...
- : bool = true
# generate 10 (dfaGrammar dfaThreeA) "babb";;
Searching (depth 01, max width 1)
Searching (depth 02, max width 2)
Searching (depth 03, max width 3)
Searching (depth 04, max width 4)
Searching (depth 05, max width 5)
Searching (depth 06, max width 6)
Searching (depth 07, max width 7)
Searching (depth 08, max width 8)
Searching (depth 09, max width 9)
Searching (depth 10, max width 10)
Searching (depth 11, max width 11)
- : bool = false
# generate 10 (dfaGrammar dfaThreeA) "babab";;
Searching (depth 01, max width 1)
Searching (depth 02, max width 2)
Searching (depth 03, max width 3)
Searching (depth 04, max width 4)
Searching (depth 05, max width 5)
Searching (depth 06, max width 6)
Searching (depth 07, max width 7)
Searching (depth 08, max width 8)
Searching (depth 09, max width 9)
Searching (depth 10, max width 10)
Searching (depth 11, max width 11)
- : bool = false
</pre>

      </li>

      <li> <p><b>Unrestricted grammars</b></p>

	<p>In this question,  I ask you to define unrestricted
	grammars as constants using <tt>let</tt> with a fixed name
	given below in each question. There is already a placeholder
	in homework7.ml for those answers. Just replace the
	placeholder with your definition.</p> 

	<p>Note that I'm asking for unrestricted grammars. The
	  languages below are <i>not</i> context-free, meaning that
	  they have no context-free grammars.</p>

	<p>Testing these might be difficult, depending on the
	complexity of the grammars you come up with. To help me on my
	end, <b>I'm asking you to show me the sequence of rewrites for
	    two strings for each grammar</b>. You should put those in a
	comment near your solution to the question. I don't care about
	the format, except that it should show all intermediate
	  rewrites. The sequence of rewrites produced
	by <tt>generate</tt> is perfectly acceptable. For example, for
	  the grammar <tt>anbn</tt>, showing how <tt>aaabbb</tt> is
	generated:
	  <pre>
(* Sequence of rewrites for aaabbb:

   S
-> aSb
-> aaSbb
-> aaaSbbb
-> aaabbb

*)</pre>

	<ol class="letter">

<li><p>Define a grammar <tt class="code">addition</tt>
    of type <tt class="code">grammar</tt>
    that generates strings of the
    form <tt><i>x<sub>1</sub></i>+<i>x<sub>2</sub></i>=<i>x<sub>3</sub></i></tt>
    where <tt><i>x<sub>1</sub></i></tt>, <tt><i>x<sub>2</sub></i></tt>, <tt><i>x<sub>3</sub></i></tt>
    are sequences of <tt>x</tt> of
    length <i>n<sub>1</sub></i>, <i>n<sub>2</sub></i>, <i>n<sub>3</sub></i>
    &ge; 0
    respectively, such
    that <i>n<sub>1</sub></i> + <i>n<sub>2</sub></i> = <i>n<sub>3</sub></i>. Thus, <tt>x+xxx=xxxx</tt>
    is in the language, while <tt>xx+xx=xxx</tt> is not. </p>

  <p>Show the sequences of rewrites in your grammar that
    generate <tt>xx+xxx=xxxxx</tt> and <tt>xxx+xx=xxxxx</tt>. 

	    <p>(The depth parameters in the examples below are dependent on
	      the grammar you create.)</p>
<pre class="code">
# generate 10 addition "+=";;
Searching (depth 01, max width 1)
Searching (depth 02, max width 2)
   S
-> ...
- : bool = true
# generate 12 addition "x+=x";;
Searching (depth 01, max width 1)
Searching (depth 02, max width 2)
Searching (depth 03, max width 3)
Searching (depth 04, max width 4)
   S
-> ...
- : bool = true
# generate 10 addition "x+x=xx";;
Searching (depth 01, max width 1)
Searching (depth 02, max width 2)
Searching (depth 03, max width 3)
Searching (depth 04, max width 4)
Searching (depth 05, max width 5)
Searching (depth 06, max width 6)
   S
-> ...
- : bool = true
# generate 10 addition "x+xx=xxx";;
Searching (depth 01, max width 1)
Searching (depth 02, max width 2)
Searching (depth 03, max width 3)
Searching (depth 04, max width 4)
Searching (depth 05, max width 5)
Searching (depth 06, max width 6)
Searching (depth 07, max width 7)
Searching (depth 08, max width 8)
   S
-> ...
- : bool = true
# generate 12 addition "x+xxx=xxxx";;
Searching (depth 01, max width 1)
Searching (depth 02, max width 2)
Searching (depth 03, max width 3)
Searching (depth 04, max width 4)
Searching (depth 05, max width 5)
Searching (depth 06, max width 6)
Searching (depth 07, max width 7)
Searching (depth 08, max width 8)
Searching (depth 09, max width 9)
Searching (depth 10, max width 10)
Searching (depth 11, max width 11)
Searching (depth 12, max width 12)
   S
-> ...
- : bool = true
# generate 10 addition "x+xx=xx";;
Searching (depth 01, max width 1)
Searching (depth 02, max width 2)
Searching (depth 03, max width 3)
Searching (depth 04, max width 4)
Searching (depth 05, max width 5)
Searching (depth 06, max width 6)
Searching (depth 07, max width 7)
Searching (depth 08, max width 8)
Searching (depth 09, max width 9)
Searching (depth 10, max width 10)
Searching (depth 11, max width 11)
- : bool = false
# generate 12 addition "x+xxx=xxx";;
Searching (depth 01, max width 1)
Searching (depth 02, max width 2)
Searching (depth 03, max width 3)
Searching (depth 04, max width 4)
Searching (depth 05, max width 5)
Searching (depth 06, max width 6)
Searching (depth 07, max width 7)
Searching (depth 08, max width 8)
Searching (depth 09, max width 9)
Searching (depth 10, max width 10)
Searching (depth 11, max width 11)
Searching (depth 12, max width 12)
Searching (depth 13, max width 13)
- : bool = false
</pre>
	  </li>


<li><p>Define a grammar <tt class="code">powers2</tt> of type <tt class="code">grammar</tt>
    that generates strings of <tt>a</tt>s of length a power of
    2: 1, 2, 4, 8, 16, 32,
    etc. Thus,  <tt>a</tt>, <tt>aa</tt>, <tt>aaaa</tt>, <tt>aaaaaaaa</tt>
    are in the language, but not &epsilon;, or <tt>aaa</tt>. </p>

  <p>Show the sequences of rewrites in your grammar that
    generate <tt>aaaa</tt>, and <tt>aaaaaaaa</tt>. 

	    <p>(The depth parameters in the examples below are dependent on
	      the grammar you create.)</p>

<pre class="code">
# generate 10 powers2 "";;
Searching (depth 01, max width 1)
Searching (depth 02, max width 2)
Searching (depth 03, max width 3)
Searching (depth 04, max width 4)
Searching (depth 05, max width 5)
Searching (depth 06, max width 6)
Searching (depth 07, max width 7)
Searching (depth 08, max width 8)
Searching (depth 09, max width 9)
Searching (depth 10, max width 10)
Searching (depth 11, max width 11)
- : bool = false
# generate 10 powers2 "a";;
Searching (depth 01, max width 1)
Searching (depth 02, max width 2)
Searching (depth 03, max width 3)
   S
-> ...
- : bool = true
# generate 10 powers2 "aa";;
Searching (depth 01, max width 1)
Searching (depth 02, max width 2)
Searching (depth 03, max width 3)
Searching (depth 04, max width 4)
Searching (depth 05, max width 5)
   S
-> ...
- : bool = true
# generate 10 powers2 "aaa";;
Searching (depth 01, max width 1)
Searching (depth 02, max width 2)
Searching (depth 03, max width 3)
Searching (depth 04, max width 4)
Searching (depth 05, max width 5)
Searching (depth 06, max width 6)
Searching (depth 07, max width 7)
Searching (depth 08, max width 8)
Searching (depth 09, max width 9)
Searching (depth 10, max width 10)
Searching (depth 11, max width 11)
- : bool = false
# generate 10 powers2 "aaaa";;
Searching (depth 01, max width 1)
Searching (depth 02, max width 2)
Searching (depth 03, max width 3)
Searching (depth 04, max width 4)
Searching (depth 05, max width 5)
Searching (depth 06, max width 6)
Searching (depth 07, max width 7)
Searching (depth 08, max width 8)
Searching (depth 09, max width 9)
   S
-> ...
- : bool = true
# generate 16 powers2 "aaaaaaaa";;
Searching (depth 01, max width 1)
Searching (depth 02, max width 2)
Searching (depth 03, max width 3)
Searching (depth 04, max width 4)
Searching (depth 05, max width 5)
Searching (depth 06, max width 6)
Searching (depth 07, max width 7)
Searching (depth 08, max width 8)
Searching (depth 09, max width 9)
Searching (depth 10, max width 10)
Searching (depth 11, max width 11)
Searching (depth 12, max width 12)
Searching (depth 13, max width 13)
Searching (depth 14, max width 14)
Searching (depth 15, max width 15)
   S
-> ...
- : bool = true
</pre>
	  </li>

		  
	</ol>
	
      </li>

    </ol>

  </body>
</html>

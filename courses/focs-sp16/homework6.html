<!DOCTYPE html>
<html>

  <head>
    
    <meta charset="utf-8">
    <title>Homework 6</title>

    <link rel="stylesheet" href="alt.css" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,800,700' rel='stylesheet' type='text/css'>

    <script src="autoscroll.js"></script>
    
    <style>

      hr { margin-top: 50px; }

        code,tt,pre {
          font-size: 140%;
        }
	
        div.lect {
	  padding-top: 0;
       	  padding-left: 3em;
	  margin-top:0;
        }
    	p.ann { 
    	  padding-left: 3em;
    	  text-indent: -3em; 
    	}
	p.ann_ctd{
	  padding-left: 3em;
        }
    	span.hdr {
   	  padding-right: 1em
    	}

	.hidden {
	  visibility: hidden;
        }

        tt.code {
           background: #e6e6e6;
        }

	pre.code {
	   border: 1px solid #c6c6c6;
	border-radius: 5px;
	padding: 10px;
	font-size:100%;
	}

/* from
    http://www.456bereastreet.com/archive/201105/styling_ordered_list_numbers/
 */

ol {
    counter-reset:li; /* Initiate a counter */
    margin-left:0; /* Remove the default left margin */
    padding-left:0; /* Remove the default left padding */
    padding-top:1em;
}
ol > li {
    position:relative; /* Create a positioning context */
    margin:0 0 6px 2em; /* Give each list item a left margin to make
    room for the numbers */
    padding:4px 8px; /* Add some spacing around the content */
    list-style:none; /* Disable the normal item numbering */
    /*border-top:2px solid #666;
    background:#f6f6f6; */
}
ol > li:before {
    counter-increment:li; /* Increment the counter by 1 */
    /* Position and style the number */
    position:absolute;
    top:-2px;
    left:-2em;
    -moz-box-sizing:border-box;
    -webkit-box-sizing:border-box;
    box-sizing:border-box;
    width:2em;
    /* Some space between the number and the content in browsers that
    support
       generated content but not positioning it (Camino 2 is one
    example) */
    margin-right:8px;
    padding:4px;
/*    border-top:2px solid #666;
    color:#fff;
    background:#666; 
    font-weight:bold; */
/*    font-family:"Helvetica Neue", Arial, sans-serif;
    text-align:center; */
}

ol.letter > li:before {
    content:"(" counter(li,lower-alpha) ")"; /* Use the counter as content */
}

ol.number > li:before {
    content:"(" counter(li,decimal) ")"; /* Use the counter as content */
}

li ol,
li ul {margin-top:6px;}

li > p { margin-top:0;}

    </style>

  </head>


  <body>

    <div class="navbar">

      <div class="home">
	<a href="../../index.html"><img src="../../home.png" style="height: 1.6em;"></a>
      </div>

      <ul>
	<li><a href="index.html"><b>Foundations of Computer Science SP16</b></a></li> 
	<li class="hidden"><a class="scrollto" href="#announcements">Announcements</a></li>
	<li class="hidden"><a class="scrollto" href="#info">Course Info</a></li>
	<li class="hidden"><a class="scrollto" href="#lectures">Lectures</a></li>
	<li class="hidden"><a class="scrollto" href="#homeworks">Homeworks</a></li>
      </ul>
    </div>


    <!-- padding -->
    <div id="top" style="height: 7em;"></div>
    
    <h1 class="clear">Homework 6</h1>
    
    <p class="subtitle">Due date: Friday, March 11 (midnight)</p>

    <p><b>Note on integrity:</b> This homework is meant to be done
    individually. You may discuss problems with fellow students, but
    all work must be entirely your own, and should not be from any
    other course, present, past, or future. If you use a solution from
    another source you must cite it &mdash; this includes when that source
      is someone else helping you.</p>

    <p>Every source file you submit should begin with a block comment
      that lists your <span style="text-decoration:underline;">name</span>, your <span style="text-decoration:underline;">email address</span>, and any <span style="text-decoration:underline;">remarks</span> that you
      wish to make to the instructor.</p>

    <p>All programming is to be done in OCaml v4.</p>

    <p>Feel free to define helper functions if you need them.</p>

    <p>Please code your answers by modifying the
      file <a href="homework6.ml"><tt>homework6.ml</tt></a> provided.</p>

    <p>Electronic submission instructions:</p>

    <ul>
      <li>Download the file <a href="hw6-checker.ml"><tt>hw6-checker.ml</tt></a> into the same directory as your homework solution.</li>
      <li>Start a <i>new</i> OCaml shell.</li>
      <li>Load your homework code via <tt>#use "homework6.ml";;</tt></li>
      <li>Load the homework checker via <tt>#use "hw6-checker.ml";;</tt></li>
      <li>The homework checker checks that you've implemented all functions (or provided stubs for them) and that those functions have the type that I asked you to give them. If the checker says your types are OK, then you're fine. If the checker gives you an error, fix it. If you believe that the checker gives you an error wrongly, send me an email.</li>
      <li>When you're ready to submit, send an email with your file <tt>homework6.ml</tt> as an attachment to <tt>focs.sp16@gmail.com</tt> with subject <i>Homework 6 submission</i>.</li>
    </ul>

    <p>If your code fails because you did not follow the instructions above (in particular, because your code fails to type check when put in presence of my automated testing rig) I'll be unhappy.</p>


    <hr>


    <p>For this homework, we use the same type of Turing machines as
      in Homework 5:</p>

<pre>
type symbol = string

type 'a tm = { states : 'a list;
	       input_alphabet : symbol list;
	       tape_alphabet : symbol list;
	       left_marker : symbol;
	       blank : symbol;
	       delta : ('a * symbol) -> ('a * symbol * int);
	       start : 'a;
	       accept : 'a;
	       reject : 'a }
</pre>

    <p>I've provided you with a function <tt>run</tt> to execute those Turing machines. As in
      Homework 5, the only types of Turing machines <tt>run</tt> can
      execute are of type <tt>string tm</tt>. That's because the
      Turing machines prints information such as the state it's in at
      every step, and that forces the states to be something specific,
      here, strings. (We're going to fix that problem here, among other
      things.) </p>

    <p>In this homework, we'll explore a slightly easier way to program Turing
      machines.</p>

<p>
Depending on how you implemented the Turing machine for binary
addition in Homework 5, you probably noticed that there
was a fair amount of redundancy in the state transitions. Some of that
redundancy it turns out can be eliminated by encoding information in
the finite control of the Turing machine &mdash; that is, in its
states.
</p>

<p>
To illustrate, let's consider a slightly simpler language. Consider
the language <i>Add1</i>, consisting of all strings of the
form <tt><i>u</i><i>#v</i></tt> where <tt><i>u</i></tt>
and <tt><i>v</i></tt> are non-empty strings of the same length over <tt>{0,1}</tt> and
<tt><i>v</i></tt> is <tt><i>u</i></tt>+1 in binary. The Turing machine
implementing this language is a simpler variant than the Turing
machine you implemented for binary addition, but shares similar
features. In particular, you need to match a symbol after
the <tt>#</tt> that depends on the symbol you saw before
the <tt>#</tt>, and you need to remember a carry in some cases. 
</p>

<p>
A possible structure for the Turing machine is as follows:
<ul>
<li>Scan from left to right, making sure the string has the right
  shape</li>
<li>Scan from left to right, finding the last <tt>0</tt>
or <tt>1</tt> before the <tt>#</tt>, crossing it out, and then
scanning past the <tt>#</tt> to find the last <tt>0</tt> or <tt>1</tt>
before the end of the string, and checking that it matches the value
  seen before the <tt>#</tt> plus any carry from the previous
  iteration.</li>
<li>Continue until all the symbols have been crossed out (accept) or
  you exhaust the symbols before or after the <tt>#</tt> (reject). 
</li>
</ul>
</p>

<p>
Here is a Turing machine that implements the above, where the states
are not just strings, but 
rather <i>structured</i> values. For this particular example, I chose
a state to be a tuple of 
the form <i>(name,m,c)</i> where <i>name</i> is a name for the
state, <i>m</i> is either -1 (the uninitialized value) or 0 or 1 (representing
whether or not the symbol read before the <tt>#</tt> when scanning was
a <tt>0</tt> or a <tt>1</tt>), and <i>c</i> is the carry from
iteration to iteration, set to -1 (uninitialized) or to 0 or 1 when there is
no carry or a carry, respectively. Other choices are possible. 
</p>

<pre>
let add1 = 
  { states = triples ["start";"check1";"check2";"rewind";"go-end-1";"go-end-2";
                      "skip";"scan-1";"scan-2";"check-done"]
                     [-1;0;1] [-1;0;1];
    input_alphabet = ["0";"1";"#"];
    tape_alphabet = ["0";"1";"#";"X";"_";">"];
    blank = "_";
    left_marker = ">";
    start = ("start",-1,-1);
    accept = ("acc",-1,-1);
    reject = ("rej",-1,-1);
    delta = (fun x -> match x with
    | (("start",-1,-1),">") -> (("check1",-1,-1),">",1)
    | (("check1",-1,-1),"0") -> (("check1",-1,-1),"0",1)
    | (("check1",-1,-1),"1") -> (("check1",-1,-1),"1",1)
    | (("check1",-1,-1),"#") -> (("check2",-1,-1),"#",1)
    | (("check2",-1,-1),"0") -> (("check2",-1,-1),"0",1)
    | (("check2",-1,-1),"1") -> (("check2",-1,-1),"1",1)
    | (("check2",-1,-1),"_") -> (("rewind",-1,1),"_",0)   (* start with a carry of 1! *)

    | (("rewind",-1,carry),">") -> (("go-end-1",-1,carry),">",1)
    | (("rewind",-1,carry),"0") -> (("rewind",-1,carry),"0",0)
    | (("rewind",-1,carry),"1") -> (("rewind",-1,carry),"1",0)
    | (("rewind",-1,carry),"#") -> (("rewind",-1,carry),"#",0)
    | (("rewind",-1,carry),"X") -> (("rewind",-1,carry),"X",0)

    | (("go-end-1",-1,carry),"#") -> (("scan-1",-1,carry),"#",0)
    | (("go-end-1",-1,carry),sym) -> (("go-end-1",-1,carry),sym,1)

    | (("scan-1",-1,carry),"X") -> (("scan-1",-1,carry),"X",0)
    | (("scan-1",-1,carry),"0") -> (("skip",0,carry),"X",1)
    | (("scan-1",-1,carry),"1") -> (("skip",1,carry),"X",1)
    | (("scan-1",-1,0),">") -> (("check-done",-1,-1),">",1)  (* carry should be 0 to accept *)

    | (("skip",v,carry),"#") -> (("go-end-2",v,carry),"#",1)
    | (("skip",v,carry),"X") -> (("skip",v,carry),"X",1)

    | (("go-end-2",v,carry),"_") -> (("scan-2",v,carry),"_",0)
    | (("go-end-2",v,carry),sym) -> (("go-end-2",v,carry),sym,1)

    | (("scan-2",v,carry),"X") -> (("scan-2",v,carry),"X",0)
    | (("scan-2",v,carry),"0") when (v+carry) mod 2 = 0 -> (("rewind",-1,(v+carry) / 2),"X",0)
    | (("scan-2",v,carry),"1") when (v+carry) mod 2 = 1 -> (("rewind",-1,(v+carry) / 2),"X",0)

    | (("check-done",-1,-1),"_") -> (("acc",-1,-1),"_",1)
    | (("check-done",-1,-1),"X") -> (("check-done",-1,-1),"X",1)
    | (("check-done",-1,-1),"#") -> (("check-done",-1,-1),"#",1)

    | (_,sym) -> (("rej",-1,-1),sym,1))}
</pre>

    <p>Note that the states are constructed via a
    function <tt>triples</tt> that you will implement in Problem 1. It
    basically takes the cross product of its three arguments. So the
      above machine has 90 states. It's a finite number of states
    &mdash; that's because I don't allow arbitary integers, but only
    -1,0,1. </p>

    <p>The transition function, and this is key, can use
    pattern-matching and variables to represent a whole swat of
    transitions when the transition doesn't depend on part of the
    state. In <tt>add1</tt>, most of the
    transitions during the iteration do not depend on the carry part
    of the state. So we can just match on the name of the state, and
    pass the carry part through to the resulting state. We could spell
    it out by having different transitions for all the possible values
    of the carry (-1,0,1), but we don't need to. That's where we gain
    a lot of the simplification. Look at the code for matching in
    state named <tt>scan-2</tt>. Those two rules take the place of the
    four rules that would be needed otherwise (one for every possible
    choice of <tt>v</tt> and <tt>carry</tt>) and not only is it
    shorter but it's also easier to see what's happening.</p>

    <p>There's only one problem with the above. The resulting machine
      has type <tt>(string * int * int) tm</tt>. Which is fine, except
      that our <tt>run</tt> function expects a <tt>string tm</tt>, as
      I mentioned above. </p>

    <p>The way we're going to fix that annoyance (Problem 2 below) is
      by implementing a function to <i>transform</i> a Turing
      machine with structured states into an equivalent Turing machine
      where the states are just strings. We'll need to provide a
      transformation function that can transform a tuple into a string
      (which can be anything but to be readable, we'll just flatten
      the representation into a string), and modify the transitions of
      the Turing machine to work with those new states.
    </p>

    <p>
    Here are a few sample runs of the machine with a correctly
    implemented <tt>transform</tt> function. Note the state
    transformation function, which uses <tt>^</tt> to concatenate
    strings, and <tt>string_of_int</tt> to convert an integer into a
    string.</p>

<pre>
# let m = transform add1 (fun (x,y,z) -> x^"|"^(string_of_int y)^"|"^(string_of_int z));;
val m : string tm =
  {states =
    ["start|-1|-1"; "start|-1|0"; "start|-1|1"; "start|0|-1"; "start|0|0";
     "start|0|1"; "start|1|-1"; "start|1|0"; "start|1|1"; "check1|-1|-1";
     "check1|-1|0"; "check1|-1|1"; "check1|0|-1"; "check1|0|0"; "check1|0|1";
     "check1|1|-1"; "check1|1|0"; "check1|1|1"; "check2|-1|-1";
     "check2|-1|0"; "check2|-1|1"; "check2|0|-1"; "check2|0|0"; "check2|0|1";
     "check2|1|-1"; "check2|1|0"; "check2|1|1"; "rewind|-1|-1";
     "rewind|-1|0"; "rewind|-1|1"; "rewind|0|-1"; "rewind|0|0"; "rewind|0|1";
     "rewind|1|-1"; "rewind|1|0"; "rewind|1|1"; "go-end-1|-1|-1";
     "go-end-1|-1|0"; "go-end-1|-1|1"; "go-end-1|0|-1"; "go-end-1|0|0";
     "go-end-1|0|1"; "go-end-1|1|-1"; "go-end-1|1|0"; "go-end-1|1|1";
     "go-end-2|-1|-1"; "go-end-2|-1|0"; "go-end-2|-1|1"; "go-end-2|0|-1";
     "go-end-2|0|0"; "go-end-2|0|1"; "go-end-2|1|-1"; "go-end-2|1|0";
     "go-end-2|1|1"; "skip|-1|-1"; "skip|-1|0"; "skip|-1|1"; "skip|0|-1";
     "skip|0|0"; "skip|0|1"; "skip|1|-1"; "skip|1|0"; "skip|1|1";
     "scan-1|-1|-1"; "scan-1|-1|0"; "scan-1|-1|1"; "scan-1|0|-1";
     "scan-1|0|0"; "scan-1|0|1"; "scan-1|1|-1"; "scan-1|1|0"; "scan-1|1|1";
     "scan-2|-1|-1"; "scan-2|-1|0"; "scan-2|-1|1"; "scan-2|0|-1";
     "scan-2|0|0"; "scan-2|0|1"; "scan-2|1|-1"; "scan-2|1|0"; "scan-2|1|1";
     "check-done|-1|-1"; "check-done|-1|0"; "check-done|-1|1";
     "check-done|0|-1"; "check-done|0|0"; "check-done|0|1";
     "check-done|1|-1"; "check-done|1|0"; "check-done|1|1"];
   input_alphabet = ["0"; "1"; "#"];
   tape_alphabet = ["0"; "1"; "#"; "X"; "_"; ">"]; left_marker = ">";
   blank = "_"; delta = &lt;fun&gt;; start = "start|-1|-1"; accept = "acc|-1|-1";
   reject = "rej|-1|-1"}
# run m "00#01";;
start|-1|-1       [>] 0  0  #  0  1 
check1|-1|-1       > [0] 0  #  0  1 
check1|-1|-1       >  0 [0] #  0  1 
check1|-1|-1       >  0  0 [#] 0  1 
check2|-1|-1       >  0  0  # [0] 1 
check2|-1|-1       >  0  0  #  0 [1]
check2|-1|-1       >  0  0  #  0  1 [_]
rewind|-1|1        >  0  0  #  0 [1] _ 
rewind|-1|1        >  0  0  # [0] 1  _ 
rewind|-1|1        >  0  0 [#] 0  1  _ 
rewind|-1|1        >  0 [0] #  0  1  _ 
rewind|-1|1        > [0] 0  #  0  1  _ 
rewind|-1|1       [>] 0  0  #  0  1  _ 
go-end-1|-1|1      > [0] 0  #  0  1  _ 
go-end-1|-1|1      >  0 [0] #  0  1  _ 
go-end-1|-1|1      >  0  0 [#] 0  1  _ 
scan-1|-1|1        >  0 [0] #  0  1  _ 
skip|0|1           >  0  X [#] 0  1  _ 
go-end-2|0|1       >  0  X  # [0] 1  _ 
go-end-2|0|1       >  0  X  #  0 [1] _ 
go-end-2|0|1       >  0  X  #  0  1 [_]
scan-2|0|1         >  0  X  #  0 [1] _ 
rewind|-1|0        >  0  X  # [0] X  _ 
rewind|-1|0        >  0  X [#] 0  X  _ 
rewind|-1|0        >  0 [X] #  0  X  _ 
rewind|-1|0        > [0] X  #  0  X  _ 
rewind|-1|0       [>] 0  X  #  0  X  _ 
go-end-1|-1|0      > [0] X  #  0  X  _ 
go-end-1|-1|0      >  0 [X] #  0  X  _ 
go-end-1|-1|0      >  0  X [#] 0  X  _ 
scan-1|-1|0        >  0 [X] #  0  X  _ 
scan-1|-1|0        > [0] X  #  0  X  _ 
skip|0|0           >  X [X] #  0  X  _ 
skip|0|0           >  X  X [#] 0  X  _ 
go-end-2|0|0       >  X  X  # [0] X  _ 
go-end-2|0|0       >  X  X  #  0 [X] _ 
go-end-2|0|0       >  X  X  #  0  X [_]
scan-2|0|0         >  X  X  #  0 [X] _ 
scan-2|0|0         >  X  X  # [0] X  _ 
rewind|-1|0        >  X  X [#] X  X  _ 
rewind|-1|0        >  X [X] #  X  X  _ 
rewind|-1|0        > [X] X  #  X  X  _ 
rewind|-1|0       [>] X  X  #  X  X  _ 
go-end-1|-1|0      > [X] X  #  X  X  _ 
go-end-1|-1|0      >  X [X] #  X  X  _ 
go-end-1|-1|0      >  X  X [#] X  X  _ 
scan-1|-1|0        >  X [X] #  X  X  _ 
scan-1|-1|0        > [X] X  #  X  X  _ 
scan-1|-1|0       [>] X  X  #  X  X  _ 
check-done|-1|-1   > [X] X  #  X  X  _ 
check-done|-1|-1   >  X [X] #  X  X  _ 
check-done|-1|-1   >  X  X [#] X  X  _ 
check-done|-1|-1   >  X  X  # [X] X  _ 
check-done|-1|-1   >  X  X  #  X [X] _ 
check-done|-1|-1   >  X  X  #  X  X [_]
acc|-1|-1          >  X  X  #  X  X  _ [_]
- : bool = true
# run m "011#100";;
start|-1|-1       [>] 0  1  1  #  1  0  0 
check1|-1|-1       > [0] 1  1  #  1  0  0 
check1|-1|-1       >  0 [1] 1  #  1  0  0 
check1|-1|-1       >  0  1 [1] #  1  0  0 
check1|-1|-1       >  0  1  1 [#] 1  0  0 
check2|-1|-1       >  0  1  1  # [1] 0  0 
check2|-1|-1       >  0  1  1  #  1 [0] 0 
check2|-1|-1       >  0  1  1  #  1  0 [0]
check2|-1|-1       >  0  1  1  #  1  0  0 [_]
rewind|-1|1        >  0  1  1  #  1  0 [0] _ 
rewind|-1|1        >  0  1  1  #  1 [0] 0  _ 
rewind|-1|1        >  0  1  1  # [1] 0  0  _ 
rewind|-1|1        >  0  1  1 [#] 1  0  0  _ 
rewind|-1|1        >  0  1 [1] #  1  0  0  _ 
rewind|-1|1        >  0 [1] 1  #  1  0  0  _ 
rewind|-1|1        > [0] 1  1  #  1  0  0  _ 
rewind|-1|1       [>] 0  1  1  #  1  0  0  _ 
go-end-1|-1|1      > [0] 1  1  #  1  0  0  _ 
go-end-1|-1|1      >  0 [1] 1  #  1  0  0  _ 
go-end-1|-1|1      >  0  1 [1] #  1  0  0  _ 
go-end-1|-1|1      >  0  1  1 [#] 1  0  0  _ 
scan-1|-1|1        >  0  1 [1] #  1  0  0  _ 
skip|1|1           >  0  1  X [#] 1  0  0  _ 
go-end-2|1|1       >  0  1  X  # [1] 0  0  _ 
go-end-2|1|1       >  0  1  X  #  1 [0] 0  _ 
go-end-2|1|1       >  0  1  X  #  1  0 [0] _ 
go-end-2|1|1       >  0  1  X  #  1  0  0 [_]
scan-2|1|1         >  0  1  X  #  1  0 [0] _ 
rewind|-1|1        >  0  1  X  #  1 [0] X  _ 
rewind|-1|1        >  0  1  X  # [1] 0  X  _ 
rewind|-1|1        >  0  1  X [#] 1  0  X  _ 
rewind|-1|1        >  0  1 [X] #  1  0  X  _ 
rewind|-1|1        >  0 [1] X  #  1  0  X  _ 
rewind|-1|1        > [0] 1  X  #  1  0  X  _ 
rewind|-1|1       [>] 0  1  X  #  1  0  X  _ 
go-end-1|-1|1      > [0] 1  X  #  1  0  X  _ 
go-end-1|-1|1      >  0 [1] X  #  1  0  X  _ 
go-end-1|-1|1      >  0  1 [X] #  1  0  X  _ 
go-end-1|-1|1      >  0  1  X [#] 1  0  X  _ 
scan-1|-1|1        >  0  1 [X] #  1  0  X  _ 
scan-1|-1|1        >  0 [1] X  #  1  0  X  _ 
skip|1|1           >  0  X [X] #  1  0  X  _ 
skip|1|1           >  0  X  X [#] 1  0  X  _ 
go-end-2|1|1       >  0  X  X  # [1] 0  X  _ 
go-end-2|1|1       >  0  X  X  #  1 [0] X  _ 
go-end-2|1|1       >  0  X  X  #  1  0 [X] _ 
go-end-2|1|1       >  0  X  X  #  1  0  X [_]
scan-2|1|1         >  0  X  X  #  1  0 [X] _ 
scan-2|1|1         >  0  X  X  #  1 [0] X  _ 
rewind|-1|1        >  0  X  X  # [1] X  X  _ 
rewind|-1|1        >  0  X  X [#] 1  X  X  _ 
rewind|-1|1        >  0  X [X] #  1  X  X  _ 
rewind|-1|1        >  0 [X] X  #  1  X  X  _ 
rewind|-1|1        > [0] X  X  #  1  X  X  _ 
rewind|-1|1       [>] 0  X  X  #  1  X  X  _ 
go-end-1|-1|1      > [0] X  X  #  1  X  X  _ 
go-end-1|-1|1      >  0 [X] X  #  1  X  X  _ 
go-end-1|-1|1      >  0  X [X] #  1  X  X  _ 
go-end-1|-1|1      >  0  X  X [#] 1  X  X  _ 
scan-1|-1|1        >  0  X [X] #  1  X  X  _ 
scan-1|-1|1        >  0 [X] X  #  1  X  X  _ 
scan-1|-1|1        > [0] X  X  #  1  X  X  _ 
skip|0|1           >  X [X] X  #  1  X  X  _ 
skip|0|1           >  X  X [X] #  1  X  X  _ 
skip|0|1           >  X  X  X [#] 1  X  X  _ 
go-end-2|0|1       >  X  X  X  # [1] X  X  _ 
go-end-2|0|1       >  X  X  X  #  1 [X] X  _ 
go-end-2|0|1       >  X  X  X  #  1  X [X] _ 
go-end-2|0|1       >  X  X  X  #  1  X  X [_]
scan-2|0|1         >  X  X  X  #  1  X [X] _ 
scan-2|0|1         >  X  X  X  #  1 [X] X  _ 
scan-2|0|1         >  X  X  X  # [1] X  X  _ 
rewind|-1|0        >  X  X  X [#] X  X  X  _ 
rewind|-1|0        >  X  X [X] #  X  X  X  _ 
rewind|-1|0        >  X [X] X  #  X  X  X  _ 
rewind|-1|0        > [X] X  X  #  X  X  X  _ 
rewind|-1|0       [>] X  X  X  #  X  X  X  _ 
go-end-1|-1|0      > [X] X  X  #  X  X  X  _ 
go-end-1|-1|0      >  X [X] X  #  X  X  X  _ 
go-end-1|-1|0      >  X  X [X] #  X  X  X  _ 
go-end-1|-1|0      >  X  X  X [#] X  X  X  _ 
scan-1|-1|0        >  X  X [X] #  X  X  X  _ 
scan-1|-1|0        >  X [X] X  #  X  X  X  _ 
scan-1|-1|0        > [X] X  X  #  X  X  X  _ 
scan-1|-1|0       [>] X  X  X  #  X  X  X  _ 
check-done|-1|-1   > [X] X  X  #  X  X  X  _ 
check-done|-1|-1   >  X [X] X  #  X  X  X  _ 
check-done|-1|-1   >  X  X [X] #  X  X  X  _ 
check-done|-1|-1   >  X  X  X [#] X  X  X  _ 
check-done|-1|-1   >  X  X  X  # [X] X  X  _ 
check-done|-1|-1   >  X  X  X  #  X [X] X  _ 
check-done|-1|-1   >  X  X  X  #  X  X [X] _ 
check-done|-1|-1   >  X  X  X  #  X  X  X [_]
acc|-1|-1          >  X  X  X  #  X  X  X  _ [_]
- : bool = true
# run m "011#010";;
start|-1|-1       [>] 0  1  1  #  0  1  0 
check1|-1|-1       > [0] 1  1  #  0  1  0 
check1|-1|-1       >  0 [1] 1  #  0  1  0 
check1|-1|-1       >  0  1 [1] #  0  1  0 
check1|-1|-1       >  0  1  1 [#] 0  1  0 
check2|-1|-1       >  0  1  1  # [0] 1  0 
check2|-1|-1       >  0  1  1  #  0 [1] 0 
check2|-1|-1       >  0  1  1  #  0  1 [0]
check2|-1|-1       >  0  1  1  #  0  1  0 [_]
rewind|-1|1        >  0  1  1  #  0  1 [0] _ 
rewind|-1|1        >  0  1  1  #  0 [1] 0  _ 
rewind|-1|1        >  0  1  1  # [0] 1  0  _ 
rewind|-1|1        >  0  1  1 [#] 0  1  0  _ 
rewind|-1|1        >  0  1 [1] #  0  1  0  _ 
rewind|-1|1        >  0 [1] 1  #  0  1  0  _ 
rewind|-1|1        > [0] 1  1  #  0  1  0  _ 
rewind|-1|1       [>] 0  1  1  #  0  1  0  _ 
go-end-1|-1|1      > [0] 1  1  #  0  1  0  _ 
go-end-1|-1|1      >  0 [1] 1  #  0  1  0  _ 
go-end-1|-1|1      >  0  1 [1] #  0  1  0  _ 
go-end-1|-1|1      >  0  1  1 [#] 0  1  0  _ 
scan-1|-1|1        >  0  1 [1] #  0  1  0  _ 
skip|1|1           >  0  1  X [#] 0  1  0  _ 
go-end-2|1|1       >  0  1  X  # [0] 1  0  _ 
go-end-2|1|1       >  0  1  X  #  0 [1] 0  _ 
go-end-2|1|1       >  0  1  X  #  0  1 [0] _ 
go-end-2|1|1       >  0  1  X  #  0  1  0 [_]
scan-2|1|1         >  0  1  X  #  0  1 [0] _ 
rewind|-1|1        >  0  1  X  #  0 [1] X  _ 
rewind|-1|1        >  0  1  X  # [0] 1  X  _ 
rewind|-1|1        >  0  1  X [#] 0  1  X  _ 
rewind|-1|1        >  0  1 [X] #  0  1  X  _ 
rewind|-1|1        >  0 [1] X  #  0  1  X  _ 
rewind|-1|1        > [0] 1  X  #  0  1  X  _ 
rewind|-1|1       [>] 0  1  X  #  0  1  X  _ 
go-end-1|-1|1      > [0] 1  X  #  0  1  X  _ 
go-end-1|-1|1      >  0 [1] X  #  0  1  X  _ 
go-end-1|-1|1      >  0  1 [X] #  0  1  X  _ 
go-end-1|-1|1      >  0  1  X [#] 0  1  X  _ 
scan-1|-1|1        >  0  1 [X] #  0  1  X  _ 
scan-1|-1|1        >  0 [1] X  #  0  1  X  _ 
skip|1|1           >  0  X [X] #  0  1  X  _ 
skip|1|1           >  0  X  X [#] 0  1  X  _ 
go-end-2|1|1       >  0  X  X  # [0] 1  X  _ 
go-end-2|1|1       >  0  X  X  #  0 [1] X  _ 
go-end-2|1|1       >  0  X  X  #  0  1 [X] _ 
go-end-2|1|1       >  0  X  X  #  0  1  X [_]
scan-2|1|1         >  0  X  X  #  0  1 [X] _ 
scan-2|1|1         >  0  X  X  #  0 [1] X  _ 
rej|-1|-1          >  0  X  X  #  0  1 [X] _ 
- : bool = false
</pre>


    <hr>
    
    <ol class="number">

      <li> <p><b>Easy Warm Up</b></p>

	<p>The code in <tt>homework6.ml</tt> includes a
	  function <tt>pairs</tt> of type <tt>'a list -> 'b list ->
	  ('a * 'b) list</tt> which is basically
	  function <tt>all_pairs</tt> from Homework 4.</p>

	<ol class="letter">

<!--
	  <li> <p>Code a function <tt class="code">???</tt> of
	      type <tt class="code">???</tt> which...
	    </p>

<pre class="code">
</pre>
	  </li>
-->

	  <li> <p>Code a function <tt class="code">triples</tt> of
	      type <tt class="code">'a list -> 'b list -> 'c list ->
		('a * 'b * 'c) list</tt> where <tt>(triples xs ys
		zs)</tt> returns the list of all
	      triples <i>(a,b,c)</i> where <i>a</i> is an element
	      of <tt>xs</tt>, <i>b</i> is an element of <tt>ys</tt>,
	      and <i>c</i> is an element of <tt>zs</tt>.  Order is not important.
	    </p>

<pre class="code">
# triples [] [] [];;
- : ('a * 'b * 'c) list = []
# triples [] ["a";"b"] [100;101];;
- : ('a * string * int) list = []
# triples [1;2] [] [100;101];;
- : (int * 'a * int) list = []
# triples [1;2] ["a";"b"] [];;
- : (int * string * 'a) list = []
# triples [1] ["a"] [100];;
- : (int * string * int) list = [(1, "a", 100)]
# triples [1;2;3] ["a";"b"] [100;101;102];;
- : (int * string * int) list =
[(1, "a", 100); (1, "a", 101); (1, "a", 102); (1, "b", 100); (1, "b", 101);
 (1, "b", 102); (2, "a", 100); (2, "a", 101); (2, "a", 102); (2, "b", 100);
 (2, "b", 101); (2, "b", 102); (3, "a", 100); (3, "a", 101); (3, "a", 102);
 (3, "b", 100); (3, "b", 101); (3, "b", 102)]
</pre>
	  </li>

	  <li> 
	    <p> Code a
	      function <tt class="code">quads</tt> of
	      type <tt class="code">'a list -> 'b list -> 'c list ->
		'd list -> ('a * 'b * 'c * 'd) list</tt>
	      where <tt>(quads xs ys zs ws)</tt> returns the list of all
	      tuples <i>(a,b,c,d)</i> where <i>a</i> is an element
	      of <tt>xs</tt>, <i>b</i> is an element of <tt>ys</tt>,
	      <i>c</i> is an element of <tt>zs</tt>, and <i>d</i> is
	      an element of <tt>ws</tt>. Order is not important.
	    </p>

<pre class="code">
# quads [] [] [] [];;
- : ('a * 'b * 'c * 'd) list = []
# quads [] ["a";"b"] [100;101] [true;false];;
- : ('a * string * int * bool) list = []
# quads [1;2] [] [100;101] [true;false];;
- : (int * 'a * int * bool) list = []
# quads [1;2] ["a";"b"] [] [true;false];;
- : (int * string * 'a * bool) list = []
# quads [1;2] ["a";"b"] [100;101] [];;
- : (int * string * int * 'a) list = []
# quads [1] ["a"] [100] [true];;
- : (int * string * int * bool) list = [(1, "a", 100, true)]
# quads [1;2] ["a";"b"] [100;101] [true;false];;
- : (int * string * int * bool) list =
[(1, "a", 100, true); (1, "a", 100, false); (1, "a", 101, true);
 (1, "a", 101, false); (1, "b", 100, true); (1, "b", 100, false);
 (1, "b", 101, true); (1, "b", 101, false); (2, "a", 100, true);
 (2, "a", 100, false); (2, "a", 101, true); (2, "a", 101, false);
 (2, "b", 100, true); (2, "b", 100, false); (2, "b", 101, true);
 (2, "b", 101, false)]
</pre>
	  </li>



	  <li><p>Code a function <tt class="code">range</tt> of
	      type <tt class="code">int -> int list</tt>
	      where <tt>(range n)</tt> returns the list of all integers
	      from <tt>0</tt> to <tt>n</tt>, inclusively. It should
	      return the empty list if <tt>n</tt>&lt;0. Order is not important.
	    </p>

<pre class="code">
# range (-1);;
- : int list = []
# range 0;;
- : int list = [0]
# range 3;;
- : int list = [3; 2; 1; 0]
# range 17;;
- : int list = [17; 16; 15; 14; 13; 12; 11; 10; 9; 8; 7; 6; 5; 4; 3; 2; 1; 0]
</pre>
	  </li>

	</ol>

      </li>


      <li> <p><b>Structured States</b></p>

	<ol class="letter">

<!--
	  <li> <p>Code a function <tt class="code">???</tt> of
	      type <tt class="code">???</tt> which...
	    </p>

<pre class="code">
</pre>
	  </li>
-->

	  <li> <p>Code a function <tt class="code">transformStates</tt> of
	      type <tt class="code">'a list -> ('a -> b) -> 'b
		list</tt> where <tt>(transformStates states f)</tt>
	      returns the result of applying transformation <tt>f</tt>
	      to every state in <tt>states</tt>.
	    </p>

<pre class="code">
# let trans (x,y) = x^"/"^(string_of_int y);;
val trans : string * int -> string = <fun>
# trans ("hello",10);;
- : string = "hello/10"

# transformStates [] trans;;
- : string list = []
# transformStates [("a",1);("b",2);("c",3)] trans;;
- : string list = ["a/1"; "b/2"; "c/3"]
</pre>
	  </li>


	  <li> <p>Code a function <tt class="code">find_original</tt> of
	      type <tt class="code">'a list -> ('a -> 'b) -> 'b ->
		'a</tt> where <tt>(find_original states f target)</tt>
	      returns the state <tt>s</tt> in <tt>states</tt> for
	      which <tt>(f s)</tt> is <tt>target</tt>. In other words,
	      it returns the original state that transforms
	      to <tt>target</tt>. 
	    </p>

<pre class="code">
# let trans (x,y) = x^"/"^(string_of_int y);;
val trans : string * int -> string = <fun>
# trans ("hello",10);;
- : string = "hello/10"

# find_original [("a",1);("b",2);("c",3)] trans "a/1";;
- : string * int = ("a", 1)
# find_original [("a",1);("b",2);("c",3)] trans "b/2";;
- : string * int = ("b", 2)
# find_original [("a",1);("b",2);("c",3)] trans "c/3";;
- : string * int = ("c", 3)
# find_original [("a",1);("b",2);("c",3)] trans "d/3";;
Exception: Failure "cannot find original value".
</pre>
	  </li>


	  <li> <p>Code a function <tt class="code">transformDelta</tt> of
	      type <tt class="code">'a list -> ('a * 'b
	      -> 'a * 'b * int) -> ('a -> 'c) -> ('c * 'b -> 'c * 'b *
		int) </tt> where <tt>(transformDelta states delta
	      f)</tt> takes a a list of <tt>states</tt> and a Turing
	      machine transition function <tt>delta</tt> as well as a
	      state transformation function <tt>f</tt> and
	      returns <i>a new transition function</i> with same
	      transitions as <tt>delta</tt> except using the
	      transformed states instead of the original states. Thus,
	      if <tt>delta(p,a)</tt> is <tt>(q,b,d)</tt>, then the new
	      transition function takes <tt>(f p,a)</tt> to <tt>(f
	      q,b,d)</tt>. 
	    </p>
	    
	    <p><b>Hint:</b> you may find
	      function <tt>find_original</tt> useful. Just
	      sayin'. </p>

	    <p><b>Also:</b> if you get the answer to this one right and you
	    understand what you're doing, then you've understood
	    everything there is to understand about higher-order
	      functions. Kudos.</p>

<pre class="code">
# let trans (x,y) = x^"/"^(string_of_int y);;
val trans : string * int -> string = <fun>
# trans ("hello",10);;
- : string = "hello/10"

# let delta x = match x with
                | (("a",1),"0") -> (("b",2),"0",0)
                | (("a",1),"1") -> (("c",3),"1",0)
                | (("b",2),"0") -> (("c",3),"0",0)
                | (("b",2),"1") -> (("a",1),"1",0)
                | (("c",3),"0") -> (("a",1),"0",1)
                | (("c",3),"1") -> (("b",2),"1",1)
                | (_,sym) -> (("a",1),sym,1)  ;;
val delta : (string * int) * string -> (string * int) * string * int = <fun>
# delta(("a",1),"0");;
- : (string * int) * string * int = (("b", 2), "0", 0)
# delta(("b",2),"0");;
- : (string * int) * string * int = (("c", 3), "0", 0)
# delta(("c",3),"0");;
- : (string * int) * string * int = (("a", 1), "0", 1)
# let new_delta = transformDelta [("a",1);("b",2);("c",3)] delta trans;;
val new_delta : string * string -> string * string * int = <fun>
# new_delta("a/1","0");;
- : string * string * int = ("b/2", "0", 0)
# new_delta("b/2","0");;
- : string * string * int = ("c/3", "0", 0)
# new_delta("c/3","0");;
- : string * string * int = ("a/1", "0", 1)
</pre>
	  </li>


	  <li> <p>Code a function <tt class="code">transform</tt> of
	      type <tt class="code">'a tm -> ('a -> 'b) -> 'b tm</tt>
	      where <tt>(transform m f)</tt> returns a Turing
	      machine that acts just like Turing machine <tt>m</tt> except that it
	      uses the states obtained by transforming the states
	      of <tt>m</tt> by <tt>f</tt>. 
	    </p>

	    <p>
	      As the example in the introduction shows, you can use
	      <tt>transform</tt> to transform a Turing machine with structured
	      states (i.e., states represented using tuples) into a
	      Turing machines with strings as states which you can
	      feed to function <tt>run</tt>.
	    </p>

	    <p>
	      For a simple output, run the <tt>add1</tt> machine as in
	      the introduction.</p>

	  </li>



	</ol>
      </li>

      <li> <p><b>Designing Turing Machines with Structured States</b></p>

        <p>In this question, I will ask you to design Turing
	  machines. Unless you want to drive yourself insane, you are
	  strongly encouraged to use structured states (exactly what
	  you take those states to be is up to &mdash; I recommend
	  tuples of some sort), and to use the <tt>transform</tt>
	  function you created in Problem 2 to transform them
	  into <tt>string tm</tt>. </p>

	<ol class="letter">

	  <li> <p>Design a total Turing machine <tt class="code">permutation</tt> of
	      type <tt class="code">string tm</tt> which
	      accepts all strings over alphabet <tt>{a, ..., z,#}</tt>
	      of the form <tt><i>u</i>#<i>v</i></tt>
	      where <tt><i>u</i></tt> and <tt><i>v</i></tt> contain
	      only letters and are permutations of each other. 
	    </p>


	    <p>The following strings should be accepted:
	    </p>
	    <pre>
   #
   a#a
   kk#kk
   hello#elhol
   obb#bob
   germany#mnayrge</pre>

	    <p>The following strings should be rejected:
	    </p>

	    <pre>
   &epsilon;
   a#
   #a
   aaa#aaaa
   aaaa#aaa
   hello#hell
   hell#hello
   aab#bba
   a#a#a
   hello</pre>

	  </li>


	  <li> <p>Code a function <tt class="code">copies</tt> of
	      type <tt class="code">int -> string tm</tt>
	      where <tt>(copies n)</tt> returns a Turing machine 
	      over alphabet <tt>{0,1,#}</tt> that accepts strings of
	      the form <tt><i>u</i>#<i>u</i>#...#<i>u</i></tt>
	      where <tt><i>u</i></tt> is a string over <tt>{0,1}</tt>
	      and there are <tt>n</tt> copies
	      of <tt><i>u</i></tt>. This requires <tt>n</tt> to be
	      greater than 0. (Report an error if <tt>n&le;0</tt>.)
	    </p>

	    <p>Thus, <tt>(copies 1)</tt> should accept the following
	    strings:
	    </p>

<pre>
   &epsilon;
   1000
   0101010101</pre>
	    <p>and reject:</p>
<pre>
   0#1
   10#10
   10#10#10</pre>
	    <p>while <tt>(copies 3)</tt> should accept the following
	    strings:
	    </p>
	    <pre>
   ##
   01#01#01
   1001#1001#1001</pre>
	    <p>and reject:</p>
	    <pre>
   &epsilon;
   #
   ###
   0#0
   10#10#10#10</pre>
	    <p>You get the gist.</p>


	  </li>


	</ol>
	
      </li>

    </ol>

  </body>
</html>

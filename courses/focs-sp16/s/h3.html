<html>

<body>
<pre>

(* 
 * String <-> characters utility functions:
 *
 *   explode : string -> char list
 *      returns the list of characters making up a string
 *
 *   implode : char list -> string
 *      concatenates the list of characters into a string
 *
 *)

let explode (str) = 
  let rec acc (index,result) = 
    if (index<0) then
      result
    else
      acc(index-1, (String.get str index)::result)
  in
    acc(String.length(str)-1, [])


let implode cs = 
  List.fold_right (fun a r -> (String.make 1 a)^r) cs ""


(*
 *  The type of a finite automaton
 * 
 *  When the transition relation is a function
 *  (i.e., every p,a has q such that (p,a,q) is in 
 *  delta) then this is a deterministic finite automaton  
 * 
 *)

type 'a fa = { states: 'a list;
               alphabet: char list;
               delta: ('a * char * 'a) list;
               start : 'a;
               accepting : 'a list }


(* QUESTION 1 *)


let findTransitions (fa,q,a) = 
  let rec loop (trs) = 
    match trs with 
    | [] -> []
    | (p',a',q')::trs' when p'=q && a=a' -> (p',a',q')::(loop trs')
    | _::trs' -> loop trs' in
  loop (fa.delta)


let isDFA (fa) = 
  (* loop over all symbols and all states:
     for every symbol and for every state,
     check that there is one and only one transition out of that
     state and that symbol *)
  let rec checkStates (states,a) = 
    match states with 
      [] -> true
    | x::xs -> (match findTransitions(fa,x,a) with
                  [] -> false
                | [_] -> checkStates(xs,a)
                | _ -> false) in 
  let rec checkSymbols (syms) = 
     match syms with
       [] -> true
     | x::xs -> checkStates(fa.states,x) && checkSymbols(xs) in
  checkSymbols (fa.alphabet)


let isAccepting (fa,s) = 
  List.mem s fa.accepting

let step (fa,q,a) = 
  match findTransitions (fa,q,a) with
    [] -> failwith "no transition!"
  | (_,_,q')::_ -> q'


let rec steps (fa,q,syms) = 
   match syms with
     [] -> q
   | x::xs -> steps(fa,step(fa,q,x),xs) 


let rec acceptDFA (fa,input) = 
   if isDFA(fa)
     then isAccepting(fa,steps(fa,fa.start,explode(input)))
   else failwith "Finite automaton is not deterministic"



(* QUESTION 2 *)

let dfa_q2_a = { states = [1;2;3;99];
		 alphabet = ['a';'b'];
		 delta = [ (1,'a',1);
			   (1,'b',2);
			   (2,'a',1);
			   (2,'b',3);
			   (3,'a',1);
			   (3,'b',99);
			   (99,'a',99);
			   (99,'b',99)];
		 start = 1;
		 accepting = [1;2;3]}

let dfa_q2_b = { states = [ "s";"1a";"2a";"3a";"sink";
			    "1b";"2b";"3b"];
		 alphabet = ['a';'b'];
		 delta = [ ("s",'a',"1a");
			   ("s",'b',"1b");
			   ("1a",'a',"2a");
			   ("1a",'b',"1b");
			   ("2a",'a',"3a");
			   ("2a",'b',"1b");
			   ("3a",'a',"sink");
			   ("3a",'b',"1b");
			   ("1b",'a',"1a");
			   ("1b",'b',"2b");
			   ("2b",'a',"1a");
			   ("2b",'b',"3b");
			   ("3b",'a',"1a");
			   ("3b",'b',"sink");
			   ("sink",'a',"sink");
			   ("sink",'b',"sink")];
		 start = "s";
		 accepting = ["s";"1a";"2a";"3a";"1b";"2b";"3b"]}

let dfa_q2_c = { states = ["s";"1a";"2a";"3a";"sink";
			    "1b";"2b";"3b"];
		 alphabet = ['a';'b'];
		 delta = [ ("s",'a',"1a");
			   ("s",'b',"1b");
			   ("1a",'a',"2a");
			   ("1a",'b',"sink");
			   ("2a",'a',"3a");
			   ("2a",'b',"sink");
			   ("3a",'a',"3a");
			   ("3a",'b',"1b");
			   ("1b",'a',"sink");
			   ("1b",'b',"2b");
			   ("2b",'a',"sink");
			   ("2b",'b',"3b");
			   ("3b",'a',"1a");
			   ("3b",'b',"3b");
			   ("sink",'a',"sink");
			   ("sink",'b',"sink")];
		 start = "s";
		 accepting = ["3a";"3b"]}

let nfa_q2_d = { states = ["s"; "1a";"2a";"3a";"acc";"bs"];
		 alphabet = ['a';'b'];
		 delta = [ ("s",'a',"1a");
			   ("s",'b',"bs");
			   ("1a",'a',"2a");
			   ("1a",'b',"bs");
			   ("2a",'a',"3a");
			   ("2a",'a',"acc");
			   ("2a",'b',"bs");
			   ("3a",'a',"3a");
			   ("3a",'a',"acc");
			   ("3a",'b',"3a");
			   ("bs",'a',"bs");
			   ("bs",'b',"bs") ];
		 start = "s";
		 accepting = ["1a";"2a";"acc";"bs"] }


(* QUESTION 3 *)

let rec keepTarget (trs) = 
   match trs with
   | [] -> []
   | (_,_,q)::trs -> let r = keepTarget(trs) in
                     if List.mem q r then r else q::r

let rec isAcceptingAny (fa,qs) = 
  match qs with
  | [] -> false
  | q::qs -> isAccepting(fa,q) || isAcceptingAny(fa,qs)

let rec stepAll (fa,qs,a) = 
   match qs with
   | [] -> []
   | q::qs -> (keepTarget(findTransitions(fa,q,a)))@(stepAll(fa,qs,a))

let rec stepsAll (fa,qs,syms) = 
   match syms with
   | [] -> qs
   | sym::syms -> stepsAll(fa,stepAll(fa,qs,sym),syms)

let acceptNFA (fa,input) = 
  let s = explode input in
  isAcceptingAny(fa,stepsAll(fa,[fa.start],s))



(* 
 * A sample DFA for testing
 *
 * It accepts the language of all strings over {a,b} with a
 * multiple-of-3 number of a's.
 *
 *)

let dfaThreeA = { 
  states = ["start";"one";"two"];
  alphabet = ['a';'b'];
  delta = [ ("start",'a',"one");
	    ("one",'a',"two");
	    ("two",'a',"start");
	    ("start",'b',"start");
	    ("one",'b',"one");
	    ("two",'b',"two") ];
  start = "start";
  accepting = ["start"]
} 

(* A sample NFA for testing
 *
 * It accepts the language of all strings over {a,b,c} 
 * whose last three symbols are b's.
 *
 *)

let nfaLastThreeB = {
  states = [0;1;2;3];
  alphabet = ['a';'b';'c'];
  delta = [ (0,'a',0);
	    (0,'b',0);
	    (0,'c',0);
	    (0,'b',1);
	    (1,'b',2);
	    (2,'b',3); ];
  start = 0;
  accepting = [3]
} 




(* This function is the base function that langDFA and
 * langNFA use -- it basically loops through all the strings
 * of length up to n, and prints those that are accepted by the
 * finite automaton.
 *
 * This is being way too clever to try to not blow the stack 
 * while enumerating all strings up to a given length. Basically.
 * we enumerate all integer, convert them to base K (where K is the
 * size of the alphabet) and then replace every digit base K by the
 * letter of the alphabet at the corresponding index in the alphabet. 
 *
 * The key is that we can enumerate integers super easily
 *
 *)

let langFA accept (fa,n) = 

  let rec expt a n = if n <= 0 then 1 else a*(expt a (n-1)) in
  
  let rec take n default l = 
    if n <= 0 then []
    else (match l with
          | [] -> default::(take (n-1) default l)
          | x::xs -> x::(take (n-1) default xs)) in
  
  let to_base_n base size n = 
    let rec loop n = 
      if n <= 0 then []
      else if n mod base = 0 then 0::(loop (n / base))
      else (n mod base)::(loop ((n - n mod base) / base))  in
    take size 0 (loop n)  in
  
  let to_string alphabet size n = 
    let base = List.length alphabet in
    let num_base = to_base_n base size n in
    implode (List.map (fun i -> List.nth alphabet i) num_base) in
  
    if n < 0 then ()
    else
      let print_str s = if s = "" then print_string "  <epsilon>\n"
  	              else print_string ("  "^s^"\n")  in
      let rec loop i = 
        if i <= n then 
  	  let ts = to_string fa.alphabet i  in
  	  let bound = expt (List.length fa.alphabet) i in
  	  let rec loop2 j = 
  	    if j < bound then (if accept(fa,ts j) 
                                 then print_str (ts j)
                               else ();
  			       loop2 (j+1))
  	    else ()  in
  	  (loop2 0; loop (i+1))
        else ()  in
      loop 0

(* 
 * Tester functions that dump the language accepted by a
 * finite automaton, either deterministic or not
 *
 *)
 
let langDFA x = langFA acceptDFA x
let langNFA x = langFA acceptNFA x


</pre>
</body>

</html>

<html>

<body>
<pre>


(* QUESTION 1 *)

let rec prepend (letter, lang) = 
  match lang with
    [] -> []
  | s::ss -> (letter^s)::(prepend(letter,ss))


let rec concatenate (alphabet, lang) = 
  match alphabet with
    [] -> []
  | (b::bs) -> (prepend (b,lang))@(concatenate(bs,lang))


(* remove duplicates in list *)

let rec remove_dups xs =  
  match xs with
    [] -> []
  | x::xs' -> if List.mem x xs' then remove_dups xs'
              else x::(remove_dups xs')


(* append two lists, removing duplicates *)

let rec append_no_dups (xs,ys) = 
  match xs with 
    [] -> remove_dups ys
  | x::xs' -> if List.mem x ys then append_no_dups(xs',ys)
              else x::(append_no_dups(xs',ys))


let rec all_strings (alphabet, n) = 
  if n = 0 then [""]
  else let sub = all_strings(alphabet,n-1) in
       append_no_dups(sub,concatenate(alphabet, sub))



(* QUESTION 2 *)

let rec restrict (xs,n) = 
   match xs with
     [] -> []
   | (x::xs) -> if String.length x > n then restrict (xs,n) 
                else x::(restrict (xs,n))


let rec langUnion (xs,ys,n) = 
   match xs with
     [] -> restrict (ys,n)
   | x::xs -> if String.length x > n then langUnion(xs,ys,n)
              else x::langUnion(xs,ys,n)


let rec concat_string_to_lang (x,ys,n) =
   match ys with
     [] -> []
   | y::ys -> let s = x^y in 
              if String.length s > n then concat_string_to_lang(x,ys,n)
              else s::concat_string_to_lang(x,ys,n)


let rec langConcat (xs,ys,n) = 
   match xs with
     [] -> []
   | x::xs -> concat_string_to_lang (x,ys,n)@langConcat(xs,ys,n)


(* This uses the observation that all strings of length up to k
 * in A^* are in A^0 U A^1 U A^2 U ... U A^k
 *)

let rec langStar (xs,n) = 
   let rec loop (xs,n,iter) = 
     if iter = 0 then [""]
     else if iter = 1 then restrict(xs,n)
     else langUnion(xs,langConcat(xs,loop (xs,n,iter-1),n),n)  in
   ""::(loop (xs,n,n))



type re = 
    Empty 
  | Unit 
  | Letter of string 
  | Plus of re * re 
  | Times of re * re 
  | Star of re

let lang (s,n) = 
  let fromChar c = String.make 1 c in
  let explode s = 
    let rec loop i result = 
      if i < 0 then result
      else loop (i-1) (s.[i]::result) in
    loop (String.length s - 1) []  in
  let isalpha = function 'A'..'Z'|'a'..'z' -> true | _ -> false in
  let expect c cs = 
    match cs with 
      f::cs when f = c -> Some cs
    | _ -> None in
  let expect_alpha cs = 
    match cs with
      f::cs when isalpha f -> Some (f,cs)
    | _ -> None  in
  let rec parse_R cs = 
    match parse_R1 cs with
      None -> None
    | Some (r1,cs) -> 
        (match expect '+' cs with
           None -> Some (r1,cs)
         | Some cs -> 
             (match parse_R cs with
                None -> None
              | Some (r2,cs) -> Some (Plus(r1,r2),cs)))
  and parse_R1 cs = 
    match parse_R2 cs with
      None -> None
    | Some (r1,cs) -> 
        (match parse_R1 cs with
           None -> Some (r1,cs)
         | Some (r2,cs) -> Some (Times(r1,r2),cs))  
  and parse_R2 cs = 
    match parse_R3 cs with
      None -> None
    | Some (r1,cs) -> 
        (match expect '*' cs with
           None -> Some (r1,cs)
         | Some cs -> Some (Star(r1),cs))
  and parse_R3 cs = 
    match expect_alpha cs with
      Some (a,cs) -> Some (Letter(fromChar(a)),cs)
    | None -> 
        (match expect '1' cs with
           Some cs -> Some (Unit, cs)
         | None -> 
             (match expect '0' cs with
                Some cs -> Some (Empty,cs)
              | None -> parse_parens cs))
  and parse_parens cs = 
    match expect '(' cs with
      None -> None
    | Some cs -> 
        (match parse_R cs with
           None -> None
         | Some (r,cs) -> 
             (match expect ')' cs with
                None -> None
              | Some cs -> Some (r,cs)))  in
  let parse s = 
    let cs = explode s in
    match parse_R cs with
      Some (re,[]) -> re
    | _ -> failwith ("Cannot parse "^s)  in
  let rec eval re = 
    match re with
      Empty -> []
    | Unit -> [""]
    | Letter (a) -> [a]
    | Plus (r1,r2) -> langUnion(eval r1,eval r2,n)
    | Times (r1,r2) -> langConcat(eval r1,eval r2,n)
    | Star r -> langStar(eval r,n)  in
  eval (parse s)


let dump l = 
  List.iter (fun s -> match s with "" -> print_string "  <empty>\n" 
                                 | s -> print_string ("  "^s^"\n")) l


(* QUESTION 3 *)

let regexp_a = "(a+b)(a+b)(a+b)"
let regexp_b = "((a+b)(a+b)(a+b))*"
let regexp_c = "b*ab*"
let regexp_d = "b*ab*(ab*ab*)*"
let regexp_e = "a*(baa*)*"


</pre>
</body>

</html>

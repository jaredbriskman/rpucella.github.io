<!DOCTYPE html>
<html>

  <head>
    
    <meta charset="utf-8">
    <title>Homework 3</title>

    <link rel="stylesheet" href="alt.css" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,800,700' rel='stylesheet' type='text/css'>

    <script src="autoscroll.js"></script>
    
    <style>

      hr { margin-top: 50px; }

        code,tt,pre {
          font-size: 130%;
        }
	
        div.lect {
	  padding-top: 0;
       	  padding-left: 3em;
	  margin-top:0;
        }
    	p.ann { 
    	  padding-left: 3em;
    	  text-indent: -3em; 
    	}
	p.ann_ctd{
	  padding-left: 3em;
        }
    	span.hdr {
   	  padding-right: 1em
    	}

	.hidden {
	  visibility: hidden;
        }

        tt.code {
           background: #e6e6e6;
        }

	pre.code {
	   border: 1px solid #c6c6c6;
	border-radius: 5px;
	padding: 10px;
	font-size:100%;
	}

/* from
    http://www.456bereastreet.com/archive/201105/styling_ordered_list_numbers/
 */

ol {
    counter-reset:li; /* Initiate a counter */
    margin-left:0; /* Remove the default left margin */
    padding-left:0; /* Remove the default left padding */
    padding-top:1em;
}
ol > li {
    position:relative; /* Create a positioning context */
    margin:0 0 6px 2em; /* Give each list item a left margin to make
    room for the numbers */
    padding:4px 8px; /* Add some spacing around the content */
    list-style:none; /* Disable the normal item numbering */
    /*border-top:2px solid #666;
    background:#f6f6f6; */
}
ol > li:before {
    counter-increment:li; /* Increment the counter by 1 */
    /* Position and style the number */
    position:absolute;
    top:-2px;
    left:-2em;
    -moz-box-sizing:border-box;
    -webkit-box-sizing:border-box;
    box-sizing:border-box;
    width:2em;
    /* Some space between the number and the content in browsers that
    support
       generated content but not positioning it (Camino 2 is one
    example) */
    margin-right:8px;
    padding:4px;
/*    border-top:2px solid #666;
    color:#fff;
    background:#666; 
    font-weight:bold; */
/*    font-family:"Helvetica Neue", Arial, sans-serif;
    text-align:center; */
}

ol.letter > li:before {
    content:"(" counter(li,lower-alpha) ")"; /* Use the counter as content */
}

ol.number > li:before {
    content:"(" counter(li,decimal) ")"; /* Use the counter as content */
}

li ol,
li ul {margin-top:6px;}

li > p { margin-top:0;}

    </style>

  </head>


  <body>

    <div class="navbar">

      <div class="home">
	<a href="../../index.html"><img src="../../home.png" style="height: 1.6em;"></a>
      </div>

      <ul>
	<li><a href="index.html"><b>Foundations of Computer Science SP16</b></a></li> 
	<li class="hidden"><a class="scrollto" href="#announcements">Announcements</a></li>
	<li class="hidden"><a class="scrollto" href="#info">Course Info</a></li>
	<li class="hidden"><a class="scrollto" href="#lectures">Lectures</a></li>
	<li class="hidden"><a class="scrollto" href="#homeworks">Homeworks</a></li>
      </ul>
    </div>


    <!-- padding -->
    <div id="top" style="height: 7em;"></div>
    
    <h1 class="clear">Homework 3</h1>
    
    <p class="subtitle">Due date: Friday, February 12 (midnight)</p>

    <p><b>Note on integrity:</b> This homework is meant to be done
    individually. You may discuss problems with fellow students, but
    all work must be entirely your own, and should not be from any
    other course, present, past, or future. If you use a solution from
    another source you must cite it &mdash; this includes when that source
      is someone else helping you.</p>

    <p>Every source file you submit should begin with a block comment
      that lists your <span style="text-decoration:underline;">name</span>, your <span style="text-decoration:underline;">email address</span>, and any <span style="text-decoration:underline;">remarks</span> that you
      wish to make to the instructor.</p>

    <p>All programming is to be done in OCaml v4.</p>

    <p>Feel free to define helper functions if you need them.</p>

    <p>Please code your answers by modifying the
      file <a href="homework3.ml"><tt>homework3.ml</tt></a> provided.</p>

    <p>Electronic submission instructions:</p>

    <ul>
      <li>Download the file <a href="hw3-checker.ml"><tt>hw3-checker.ml</tt></a> into the same directory as your homework solution.</li>
      <li>Start a <i>new</i> OCaml shell.</li>
      <li>Load your homework code via <tt>#use "homework3.ml";;</tt></li>
      <li>Load the homework checker via <tt>#use "hw3-checker.ml";;</tt></li>
      <li>The homework checker checks that you've implemented all functions (or provided stubs for them) and that those functions have the type that I asked you to give them. If the checker says your types are OK, then you're fine. If the checker gives you an error, fix it. If you believe that the checker gives you an error wrongly, send me an email.</li>
      <li>When you're ready to submit, send an email with your file <tt>homework3.ml</tt> as an attachment to <tt>focs.sp16@gmail.com</tt> with subject <i>Homework 3 submission</i>.</li>
    </ul>

    <hr>

    <p>Consider the following type for finite automata:</p>
    <pre>
   type 'a fa = { states: 'a list;
                  alphabet: char list;
                  delta: ('a * char * 'a) list;
                  start : 'a;
                  accepting : 'a list }
</pre>
<p>A finite automaton  is described by a record with fields holding the various
components of the automaton: the set of states, the alphabet, the
transition relation &Delta;, the start state, and the set of final states. Lists are  
used to represent sets. The transition relation is represented using
  list of triples (<i>p</i>,<i>a</i>,<i>q</i>), stating that in
  state <i>p</i>, reading symbol 
  <i>a</i> makes the machine transition to state <i>q</i>. The automaton itself is
parameterized over the type of states. (That means that you can use
               strings, or integers, or anything you want to represent
               states.)  
</p>

<p>For information how to work with records in OCaml, <a href="http://www.cs.cornell.edu/courses/cs3110/2011sp/recitations/rec02-ocaml/ocaml.htm">check out this
    link</a> and scroll down to the <i>Records</i> section. Note that
    aside from pattern matching, you can also access the fields of a
  record using the <tt>.</tt> notation: <tt>record.fld</tt> will
  return the value of field <tt>fld</tt> of <tt>record</tt>.
</p>

<p>Here is an example of a finite automaton that accepts the the
  language of all strings over <tt>{a,b,c}</tt> whose last three
  symbols are <tt>b</tt>s. </p>

<pre>
   let nfaLastThreeB = {
     states = [0;1;2;3];
     alphabet = ['a';'b';'c'];
     delta = [ (0,'a',0);
               (0,'b',0);
               (0,'c',0);
               (0,'b',1);
               (1,'b',2);
               (2,'b',3); ];
     start = 0;
     accepting = [3]
   } 
</pre>

<p>Recall that a finite automaton is <i>deterministic</i> if its
  transition relation describes a function: that is, for every state <i>q</i>
  of the automaton and every symbol <i>a</i> of the alphabet, there
  is <i>exactly</i> one transition in &Delta; of the form
  (<i>q</i>,<i>a</i>,<i>p</i>) for some state <i>p</i>.</p>

<p>Here is an example of a deterministic finite automaton that accepts
  the set of all strings over <tt>{a,b}</tt> that contains a number
  of <tt>a</tt>s that is a multiple of 3. 
</p>

<pre>
   let dfaThreeA = { 
     states = ["start";"one";"two"];
     alphabet = ['a';'b'];
     delta = [ ("start",'a',"one");
               ("one",'a',"two");
               ("two",'a',"start");
               ("start",'b',"start");
               ("one",'b',"one");
               ("two",'b',"two") ];
     start = "start";
     accepting = ["start"]
   } 
</pre>
<p>Note the use of a sink state that simply eats every symbol of
  the string and never accepts. Think of it as the "error" state. You
  will generally need something like that when designing deterministic finite automata because determinism requires
  a target state for every symbol in every state.</p>

    <hr>
    
    <ol class="number">
      <li> <p><b>Deterministic Finite Automata</b></p>

	<ol class="letter">

<!--
	  <li> <p>Code a function <tt class="code">???</tt> of
	      type <tt class="code">???</tt> which...
	    </p>

	    <pre class="code">
</pre>
	  </li>
-->

	  <li> <p>Code a function <tt class="code">findTransitions</tt> of
	      type <tt class="code">'a fa * 'a * char -> ('a * char *
		'a) list</tt> which takes a finite
	      automaton <i>m</i>, a state <i>q</i> of <i>m</i>,
	      and a symbol <i>a</i> in the alphabet of <i>m</i>,
	      and returns the list of all transition in <i>m</i>
	      from <i>q</i> labeled <i>a</i>.</p>
	    
	    <pre class="code">
# findTransitions (dfaThreeA,"start",'a');;
- : (string * char * string) list = [("start", 'a', "one")]
# findTransitions (dfaThreeA,"start",'b');;
- : (string * char * string) list = [("start", 'b', "start")]
# findTransitions (dfaThreeA,"one",'b');;
- : (string * char * string) list = [("one", 'b', "one")]
# findTransitions (nfaLastThreeB,0,'a');;
- : (int * char * int) list = [(0, 'a', 0)]
# findTransitions (nfaLastThreeB,0,'b');;
- : (int * char * int) list = [(0, 'b', 0); (0, 'b', 1)]
</pre>
	  </li>


	  <li> <p>Code a function <tt class="code">isAccepting</tt> of
	      type <tt class="code">'a fa * 'a -> bool</tt> which
	      takes a finite automaton <i>m</i> and a state <i>q</i>
	      of <i>m</i> and returns true when <i>q</i> is an
	      accepting states and false otherwise.</p>
	    
	    <pre class="code">
# isAccepting (dfaThreeA,"start");;
- : bool = true
# isAccepting (dfaThreeA,"one");;
- : bool = false
# isAccepting (dfaThreeA,"two");;
- : bool = false
# isAccepting (nfaLastThreeB,3);;
- : bool = true
# isAccepting (nfaLastThreeB,0);;
- : bool = false
</pre>
	  </li>

	  <li> <p>Code a function <tt class="code">step</tt> of
	      type <tt class="code">'a fa * 'a * char -> 'a</tt> which
	      takes a <i>deterministic</i> finite automaton <i>m</i>, a
		  state <i>q</i> of <i>m</i>, and a symbol <i>a</i> of
		the alphabet of <i>m</i>, and returns the state
	      of <i>m</i> resulting from the one transition
	      from <i>q</i> that
	      applies.</p>

	    <pre class="code">
# step (dfaThreeA, "start",'a');;
- : string = "one"
# step (dfaThreeA, "start",'b');;
- : string = "start"
# step (dfaThreeA, "one",'a');;
- : string = "two"
# step (dfaThreeA, "one",'b');;
- : string = "one"
# step (dfaThreeA, "two",'a');;
- : string = "start"
# step (dfaThreeA, "two",'b');;
- : string = "two"
</pre>
	  </li>


	  <li> <p>Code a function <tt class="code">steps</tt> of
	      type <tt class="code">'a fa * 'a * char list -> 'a</tt>
	      which takes a <i>deterministic</i> finite automaton <i>m</i>, a
		  state <i>q</i> of <i>m</i>, and a list of
	      symbols <i>l</i> of 
		the alphabet of <i>m</i>, and returns the state
		of <i>m</i> resulting from following the transitions
	      of <i>m</i> from <i>q</i> according to the symbols
	      in <i>l</i>.</p>
	    </p>

	    <pre class="code">
# steps (dfaThreeA, "start", []);;
- : string = "start"
# steps (dfaThreeA, "start", ['a']);;
- : string = "one"
# steps (dfaThreeA, "start", ['a';'b']);;
- : string = "one"
# steps (dfaThreeA, "start", ['a';'b';'a']);;
- : string = "two"
# steps (dfaThreeA, "one", []);;
- : string = "one"
# steps (dfaThreeA, "one", ['a']);;
- : string = "two"
# steps (dfaThreeA, "one", ['a';'b']);;
- : string = "two"
# steps (dfaThreeA, "one", ['a';'b';'a']);;
- : string = "start"
</pre>
	  </li>

	  <li> <p>Code a function <tt class="code">isDFA</tt> of
	      type <tt class="code">'a fa -> bool</tt> which takes a
	      finite automaton <i>m</i> and returns true if <i>m</i>
	      is deterministic, and false otherwise. Basically, it
	      checks whether every state and every symbol has exactly
	      one transition that applies.
	    </p>

	    <pre class="code">
# isDFA (dfaThreeA);;
- : bool = true
# isDFA (nfaLastThreeB);;
- : bool = false
# isDFA {states=[0;1]; 
         alphabet=['a']; 
         delta=[(0,'a',1)]; 
         start=0; 
         accepting=[1]};;
- : bool = false
</pre>
	  </li>

	  <li> <p>Code a function <tt class="code">acceptDFA</tt> of
	      type <tt class="code">'a fa * string -> bool</tt> which
	      takes a finite automaton <i>m</i> and a string <i>s</i>
	      over the alphabet of <i>m</i>, and if the automaton is
	      deterministic, returns true if <i>m</i>
	      accepts <i>s</i>, and false otherwise. If the automaton
	      is not deterministic, then report an error
	      with <tt>failwith</tt>.  
	    </p>

	    <p>You can use function <tt>explode</tt> (provided in the
	      homework code) to turn a string into a list of
	      characters.</p>

	    <p>For testing purposes, I've provided you also with a
	      function <tt>langDFA</tt> where <tt>langDFA(m,k)</tt>
	      prints out all the strings of length up to <tt>k</tt>
	      accepted by the deterministic finite
	      automaton <tt>m</tt>. Note that it calls your
	      function <tt>acceptDFA</tt>, so it won't work correctly
	      until you implement that.

	    <pre class="code">
# acceptDFA (dfaThreeA,"");;
- : bool = true
# acceptDFA (dfaThreeA,"a");;
- : bool = false
# acceptDFA (dfaThreeA,"b");;
- : bool = true
# acceptDFA (dfaThreeA,"aa");;
- : bool = false
# acceptDFA (dfaThreeA,"aaa");;
- : bool = true
# acceptDFA (dfaThreeA,"ababa");;
- : bool = true
# acceptDFA (dfaThreeA,"abababa");;
- : bool = false
# langDFA (dfaThreeA,6);;
  &lt;epsilon&gt;
  b
  bb
  aaa
  bbb
  baaa
  abaa
  aaba
  aaab
  bbbb
  bbaaa
  babaa
  abbaa
  baaba
  ababa
  aabba
  baaab
  abaab
  aabab
  aaabb
  bbbbb
  aaaaaa
  bbbaaa
  bbabaa
  babbaa
  abbbaa
  bbaaba
  bababa
  abbaba
  baabba
  ababba
  aabbba
  bbaaab
  babaab
  abbaab
  baabab
  ababab
  aabbab
  baaabb
  abaabb
  aababb
  aaabbb
  bbbbbb
- : unit = ()
</pre>
	  </li>


	</ol>
      </li>

      <li> <p><b>Designing Finite Automata</b></p>

        <p>In this question, I will ask you to come up with finite
	  automata. You can test your deterministic finite automata
	  with the code you wrote in Question 1. (For the one
	  nondeterministic finite automaton I ask about, you'll have
	  to test using what you do in Question 3.) </p>

	<p>For submission purposes, I ask you to define those finite
	  automata as constants using <tt>let</tt> with a fixed
	  name given below in each question. There is already a
	  placeholder in <tt>homework3.ml</tt> for those answers. Just
	  replace the placeholder with your definition.</p>


	<ol class="letter">

	  <li><p>
	      Come up with a <i>deterministic</i> finite automaton
	      <tt class="code">dfa_q2_a</tt> for
	      the language consisting of all strings over the
	      alphabet <tt>{a,b}</tt> in which there are never more
	      than two consecutive <tt>b</tt>s in a row.
	    </p>

<pre class="code">
# langDFA(dfa_q2_a,6);;
  &lt;epsilon&gt;
  a
  b
  aa
  ba
  ab
  bb
  aaa
  baa
  aba
  bba
  aab
  bab
  abb
  aaaa
  baaa
  abaa
  bbaa
  aaba
  baba
  abba
  aaab
  baab
  abab
  bbab
  aabb
  babb
  aaaaa
  baaaa
  abaaa
  bbaaa
  aabaa
  babaa
  abbaa
  aaaba
  baaba
  ababa
  bbaba
  aabba
  babba
  aaaab
  baaab
  abaab
  bbaab
  aabab
  babab
  abbab
  aaabb
  baabb
  ababb
  bbabb
  aaaaaa
  baaaaa
  abaaaa
  bbaaaa
  aabaaa
  babaaa
  abbaaa
  aaabaa
  baabaa
  ababaa
  bbabaa
  aabbaa
  babbaa
  aaaaba
  baaaba
  abaaba
  bbaaba
  aababa
  bababa
  abbaba
  aaabba
  baabba
  ababba
  bbabba
  aaaaab
  baaaab
  abaaab
  bbaaab
  aabaab
  babaab
  abbaab
  aaabab
  baabab
  ababab
  bbabab
  aabbab
  babbab
  aaaabb
  baaabb
  abaabb
  bbaabb
  aababb
  bababb
  abbabb
- : unit = ()
</pre>
	  </li>


	  <li><p>
	      Come up with a <i>deterministic</i> finite automaton
	      <tt class="code">dfa_q2_b</tt> for
	      the language consisting of all strings over the alphabet
	      <tt>{a,b}</tt> in which there are never more than
	      three consecutive <tt>a</tt>s or three
	      consecutive <tt>b</tt>s in a row.
	    </p>

<pre class="code">
# langDFA (dfa_q2_b,7);;
  &lt;epsilon&gt;
  a
  b
  aa
  ba
  ab
  bb
  aaa
  baa
  aba
  bba
  aab
  bab
  abb
  bbb
  baaa
  abaa
  bbaa
  aaba
  baba
  abba
  bbba
  aaab
  baab
  abab
  bbab
  aabb
  babb
  abbb
  abaaa
  bbaaa
  aabaa
  babaa
  abbaa
  bbbaa
  aaaba
  baaba
  ababa
  bbaba
  aabba
  babba
  abbba
  baaab
  abaab
  bbaab
  aabab
  babab
  abbab
  bbbab
  aaabb
  baabb
  ababb
  bbabb
  aabbb
  babbb
  aabaaa
  babaaa
  abbaaa
  bbbaaa
  aaabaa
  baabaa
  ababaa
  bbabaa
  aabbaa
  babbaa
  abbbaa
  baaaba
  abaaba
  bbaaba
  aababa
  bababa
  abbaba
  bbbaba
  aaabba
  baabba
  ababba
  bbabba
  aabbba
  babbba
  abaaab
  bbaaab
  aabaab
  babaab
  abbaab
  bbbaab
  aaabab
  baabab
  ababab
  bbabab
  aabbab
  babbab
  abbbab
  baaabb
  abaabb
  bbaabb
  aababb
  bababb
  abbabb
  bbbabb
  aaabbb
  baabbb
  ababbb
  bbabbb
  aaabaaa
  baabaaa
  ababaaa
  bbabaaa
  aabbaaa
  babbaaa
  abbbaaa
  baaabaa
  abaabaa
  bbaabaa
  aababaa
  bababaa
  abbabaa
  bbbabaa
  aaabbaa
  baabbaa
  ababbaa
  bbabbaa
  aabbbaa
  babbbaa
  abaaaba
  bbaaaba
  aabaaba
  babaaba
  abbaaba
  bbbaaba
  aaababa
  baababa
  abababa
  bbababa
  aabbaba
  babbaba
  abbbaba
  baaabba
  abaabba
  bbaabba
  aababba
  bababba
  abbabba
  bbbabba
  aaabbba
  baabbba
  ababbba
  bbabbba
  aabaaab
  babaaab
  abbaaab
  bbbaaab
  aaabaab
  baabaab
  ababaab
  bbabaab
  aabbaab
  babbaab
  abbbaab
  baaabab
  abaabab
  bbaabab
  aababab
  bababab
  abbabab
  bbbabab
  aaabbab
  baabbab
  ababbab
  bbabbab
  aabbbab
  babbbab
  abaaabb
  bbaaabb
  aabaabb
  babaabb
  abbaabb
  bbbaabb
  aaababb
  baababb
  abababb
  bbababb
  aabbabb
  babbabb
  abbbabb
  baaabbb
  abaabbb
  bbaabbb
  aababbb
  bababbb
  abbabbb
  bbbabbb
- : unit = ()
</pre>
	  </li>


	  <li><p>
	      Come up with a <i>deterministic</i> finite automaton
	      <tt class="code">dfa_q2_c</tt> for
	      the language consisting of all strings over the alphabet
	      <tt>{a,b}</tt> in which there are never less than
	      three consecutive <tt>a</tt>s or three
	      consecutive <tt>b</tt>s in a row.
	    </p>

<pre class="code">
# langDFA (dfa_q2_c,12);;
  aaa
  bbb
  aaaa
  bbbb
  aaaaa
  bbbbb
  aaaaaa
  bbbaaa
  aaabbb
  bbbbbb
  aaaaaaa
  bbbaaaa
  bbbbaaa
  aaaabbb
  aaabbbb
  bbbbbbb
  aaaaaaaa
  bbbaaaaa
  bbbbaaaa
  bbbbbaaa
  aaaaabbb
  aaaabbbb
  aaabbbbb
  bbbbbbbb
  aaaaaaaaa
  bbbaaaaaa
  bbbbaaaaa
  bbbbbaaaa
  aaabbbaaa
  bbbbbbaaa
  aaaaaabbb
  bbbaaabbb
  aaaaabbbb
  aaaabbbbb
  aaabbbbbb
  bbbbbbbbb
  aaaaaaaaaa
  bbbaaaaaaa
  bbbbaaaaaa
  bbbbbaaaaa
  aaabbbaaaa
  bbbbbbaaaa
  aaaabbbaaa
  aaabbbbaaa
  bbbbbbbaaa
  aaaaaaabbb
  bbbaaaabbb
  bbbbaaabbb
  aaaaaabbbb
  bbbaaabbbb
  aaaaabbbbb
  aaaabbbbbb
  aaabbbbbbb
  bbbbbbbbbb
  aaaaaaaaaaa
  bbbaaaaaaaa
  bbbbaaaaaaa
  bbbbbaaaaaa
  aaabbbaaaaa
  bbbbbbaaaaa
  aaaabbbaaaa
  aaabbbbaaaa
  bbbbbbbaaaa
  aaaaabbbaaa
  aaaabbbbaaa
  aaabbbbbaaa
  bbbbbbbbaaa
  aaaaaaaabbb
  bbbaaaaabbb
  bbbbaaaabbb
  bbbbbaaabbb
  aaaaaaabbbb
  bbbaaaabbbb
  bbbbaaabbbb
  aaaaaabbbbb
  bbbaaabbbbb
  aaaaabbbbbb
  aaaabbbbbbb
  aaabbbbbbbb
  bbbbbbbbbbb
  aaaaaaaaaaaa
  bbbaaaaaaaaa
  bbbbaaaaaaaa
  bbbbbaaaaaaa
  aaabbbaaaaaa
  bbbbbbaaaaaa
  aaaabbbaaaaa
  aaabbbbaaaaa
  bbbbbbbaaaaa
  aaaaabbbaaaa
  aaaabbbbaaaa
  aaabbbbbaaaa
  bbbbbbbbaaaa
  aaaaaabbbaaa
  bbbaaabbbaaa
  aaaaabbbbaaa
  aaaabbbbbaaa
  aaabbbbbbaaa
  bbbbbbbbbaaa
  aaaaaaaaabbb
  bbbaaaaaabbb
  bbbbaaaaabbb
  bbbbbaaaabbb
  aaabbbaaabbb
  bbbbbbaaabbb
  aaaaaaaabbbb
  bbbaaaaabbbb
  bbbbaaaabbbb
  bbbbbaaabbbb
  aaaaaaabbbbb
  bbbaaaabbbbb
  bbbbaaabbbbb
  aaaaaabbbbbb
  bbbaaabbbbbb
  aaaaabbbbbbb
  aaaabbbbbbbb
  aaabbbbbbbbb
  bbbbbbbbbbbb
- : unit = ()
</pre>
	  </li>

	  <li><p>
	      Come up with a finite automaton (most likely
	      nondeterministic) <tt class="code">nfa_q2_d</tt> for
	      the language consisting of all strings over the alphabet
	      <tt>{a,b}</tt> except for those that <i>do not end with
		an <tt>a</tt></i> when there
	      are no <tt>b</tt>s in the first three symbols of the
	      string. 
	    </p>

<pre class="code">
# langNFA (nfa_q2_d,7);;
  a
  b
  aa
  ba
  ab
  bb
  aaa
  baa
  aba
  bba
  aab
  bab
  abb
  bbb
  aaaa
  baaa
  abaa
  bbaa
  aaba
  baba
  abba
  bbba
  baab
  abab
  bbab
  aabb
  babb
  abbb
  bbbb
  aaaaa
  baaaa
  abaaa
  bbaaa
  aabaa
  babaa
  abbaa
  bbbaa
  aaaba
  baaba
  ababa
  bbaba
  aabba
  babba
  abbba
  bbbba
  baaab
  abaab
  bbaab
  aabab
  babab
  abbab
  bbbab
  baabb
  ababb
  bbabb
  aabbb
  babbb
  abbbb
  bbbbb
  aaaaaa
  baaaaa
  abaaaa
  bbaaaa
  aabaaa
  babaaa
  abbaaa
  bbbaaa
  aaabaa
  baabaa
  ababaa
  bbabaa
  aabbaa
  babbaa
  abbbaa
  bbbbaa
  aaaaba
  baaaba
  abaaba
  bbaaba
  aababa
  bababa
  abbaba
  bbbaba
  aaabba
  baabba
  ababba
  bbabba
  aabbba
  babbba
  abbbba
  bbbbba
  baaaab
  abaaab
  bbaaab
  aabaab
  babaab
  abbaab
  bbbaab
  baabab
  ababab
  bbabab
  aabbab
  babbab
  abbbab
  bbbbab
  baaabb
  abaabb
  bbaabb
  aababb
  bababb
  abbabb
  bbbabb
  baabbb
  ababbb
  bbabbb
  aabbbb
  babbbb
  abbbbb
  bbbbbb
  aaaaaaa
  baaaaaa
  abaaaaa
  bbaaaaa
  aabaaaa
  babaaaa
  abbaaaa
  bbbaaaa
  aaabaaa
  baabaaa
  ababaaa
  bbabaaa
  aabbaaa
  babbaaa
  abbbaaa
  bbbbaaa
  aaaabaa
  baaabaa
  abaabaa
  bbaabaa
  aababaa
  bababaa
  abbabaa
  bbbabaa
  aaabbaa
  baabbaa
  ababbaa
  bbabbaa
  aabbbaa
  babbbaa
  abbbbaa
  bbbbbaa
  aaaaaba
  baaaaba
  abaaaba
  bbaaaba
  aabaaba
  babaaba
  abbaaba
  bbbaaba
  aaababa
  baababa
  abababa
  bbababa
  aabbaba
  babbaba
  abbbaba
  bbbbaba
  aaaabba
  baaabba
  abaabba
  bbaabba
  aababba
  bababba
  abbabba
  bbbabba
  aaabbba
  baabbba
  ababbba
  bbabbba
  aabbbba
  babbbba
  abbbbba
  bbbbbba
  baaaaab
  abaaaab
  bbaaaab
  aabaaab
  babaaab
  abbaaab
  bbbaaab
  baabaab
  ababaab
  bbabaab
  aabbaab
  babbaab
  abbbaab
  bbbbaab
  baaabab
  abaabab
  bbaabab
  aababab
  bababab
  abbabab
  bbbabab
  baabbab
  ababbab
  bbabbab
  aabbbab
  babbbab
  abbbbab
  bbbbbab
  baaaabb
  abaaabb
  bbaaabb
  aabaabb
  babaabb
  abbaabb
  bbbaabb
  baababb
  abababb
  bbababb
  aabbabb
  babbabb
  abbbabb
  bbbbabb
  baaabbb
  abaabbb
  bbaabbb
  aababbb
  bababbb
  abbabbb
  bbbabbb
  baabbbb
  ababbbb
  bbabbbb
  aabbbbb
  babbbbb
  abbbbbb
  bbbbbbb
- : unit = ()
</pre>
	  </li>



	</ol>
      </li>

      <li> <p><b>Nondeterministic Finite Automata</b></p>

	<p>This question will reuse code from Question 1, most
	likely. Unless you want to do the work twice.</p>

	<ol class="letter">

	  <li> <p>Code a function <tt class="code">keepTarget</tt> of
	      type <tt class="code">('a * 'b * 'c) list -> 'c
	      list</tt> which takes a list of transitions (of the kind
	      found in the <tt>delta</tt> field of an automaton) and
	      returns the list of all states that those transitions
	      lead to, the targets. (See examples below.) For your own sanity,
	      please make sure you remove duplicates from the
	      resulting list.</p>
	    
	    <pre class="code">
# keepTarget [];;
- : 'a list = []
# keepTarget [(1,'a',2);(1,'b',3)];;
- : int list = [2; 3]
# keepTarget [(1,'a',2);(1,'b',3);(2,'a',2)];;
- : int list = [3; 2]
# keepTarget (dfaThreeA.delta);;
- : string list = ["start"; "one"; "two"]
# keepTarget (nfaLastThreeB.delta);;
- : int list = [0; 1; 2; 3]
</pre>
	  </li>


	  <li> <p>Code a function <tt class="code">isAcceptingAny</tt> of
	      type <tt class="code">'a fa * 'a list -> bool</tt> which
	      takes a finite automaton <i>m</i> and a list of states <i>qs</i>
	      of <i>m</i> and returns true when any of the states
	      in <i>qs</i> is an accepting state and false otherwise.</p>
	    
	    <pre class="code">
# isAcceptingAny (nfaLastThreeB, []);;
- : bool = false
# isAcceptingAny (nfaLastThreeB, [0]);;
- : bool = false
# isAcceptingAny (nfaLastThreeB, [0;1]);;
- : bool = false
# isAcceptingAny (nfaLastThreeB, [0;1;2]);;
- : bool = false
# isAcceptingAny (nfaLastThreeB, [0;1;2;3]);;
- : bool = true
# isAcceptingAny (nfaLastThreeB, [3]);;
- : bool = true
</pre>
	  </li>

	  <li> <p>Code a function <tt class="code">stepAll</tt> of
	      type <tt class="code">'a fa * 'a list * char -> 'a list</tt> which
	      takes a finite automaton <i>m</i>, a list of 
		  states<i>qs</i> of <i>m</i>, and a symbol <i>a</i> of
		the alphabet of <i>m</i>, and returns the list of all states
	      of <i>m</i> resulting from taking a transition from any
	      state in <i>qs</i> following symbol <i>a</i>. Again,
	      for your sanity, you will probably want to make sure there are
	      no repetitions in the resulting list.</p>

	    <pre class="code">
# stepAll (dfaThreeA,[],'a');;
- : string list = []
# stepAll (dfaThreeA,["start"],'a');;
- : string list = ["one"]
# stepAll (dfaThreeA,["start"],'b');;
- : string list = ["start"]
# stepAll (dfaThreeA,["start";"one"],'a');;
- : string list = ["one"; "two"]
# stepAll (dfaThreeA,["start";"one"],'b');;
- : string list = ["start"; "one"]
# stepAll (nfaLastThreeB,[0;1],'a');;
- : int list = [0]
# stepAll (nfaLastThreeB,[0;1],'b');;
- : int list = [0; 1; 2]
</pre>
	  </li>


	  <li> <p>Code a function <tt class="code">stepsAll</tt> of
	      type <tt class="code">'a fa * 'a list * char list -> 'a list</tt>
	      which takes a  finite automaton <i>m</i>, a list of 
		  states <i>qs</i> of <i>m</i>, and a list of
	      symbols <i>l</i> of 
		the alphabet of <i>m</i>, and returns the list of all states
		of <i>m</i> resulting from following the transitions
	      of <i>m</i> from any state in <i>qs</i> according to the
	      symbols in <i>l</i>.</p>
	    </p>

	    <pre class="code">
# stepsAll (dfaThreeA,[],[]);;
- : string list = []
# stepsAll (dfaThreeA,[],['a']);;
- : string list = []
# stepsAll (dfaThreeA,[],['a';'b']);;
- : string list = []
# stepsAll (dfaThreeA,["start"],[]);;
- : string list = ["start"]
# stepsAll (dfaThreeA,["start"],['a']);;
- : string list = ["one"]
# stepsAll (dfaThreeA,["start"],['a';'b']);;
- : string list = ["one"]
# stepsAll (dfaThreeA,["start"],['a';'a']);;
- : string list = ["two"]
# stepsAll (dfaThreeA,["start";"one"],['a';'a']);;
- : string list = ["two"; "start"]
# stepsAll (dfaThreeA,["start";"one"],['a';'a';'b']);;
- : string list = ["two"; "start"]
# stepsAll (dfaThreeA,["start";"one"],['a';'a';'b';'a']);;
- : string list = ["start"; "one"]
# stepsAll (nfaLastThreeB,[0;1],['a';'b';'b';'b']);;
- : int list = [0; 1; 2; 3]
</pre>
	  </li>


	  <li> <p>Code a function <tt class="code">acceptNFA</tt> of
	      type <tt class="code">'a fa * string -> bool</tt> which
	      takes a finite automaton <i>m</i> and a string <i>s</i>
	      over the alphabet of <i>m</i>, and returns true if <i>m</i>
	      accepts <i>s</i>, and false otherwise. Think of it as
	      implementing the "multiple pebbles" interpretation of
	      finite automata, following all paths in the automaton
	      that apply at the same time..  
	    </p>

	    <p>You can use function <tt>explode</tt> (provided in the
	      homework code) to turn a string into a list of
	      characters.</p>

	    <p>For testing purposes, I've provided you also with a
	      function <tt>langNFA</tt> where <tt>langNFA(m,k)</tt>
	      prints out all the strings of length up to <tt>k</tt>
	      accepted by the finite
	      automaton <tt>m</tt>. Note that it calls your
	      function <tt>acceptNFA</tt>, so it won't work correctly
	      until you implement that.

	    <pre class="code">
# acceptNFA (dfaThreeA,"babab");;
- : bool = false
# acceptNFA (dfaThreeA,"bababa");;
- : bool = true
# acceptNFA (dfaThreeA,"bababab");;
- : bool = true
# acceptNFA (nfaLastThreeB,"abb");;
- : bool = false
# acceptNFA (nfaLastThreeB,"abbb");;
- : bool = true
# langNFA (nfaLastThreeB,7);;
  bbb
  abbb
  bbbb
  cbbb
  aabbb
  babbb
  cabbb
  abbbb
  bbbbb
  cbbbb
  acbbb
  bcbbb
  ccbbb
  aaabbb
  baabbb
  caabbb
  ababbb
  bbabbb
  cbabbb
  acabbb
  bcabbb
  ccabbb
  aabbbb
  babbbb
  cabbbb
  abbbbb
  bbbbbb
  cbbbbb
  acbbbb
  bcbbbb
  ccbbbb
  aacbbb
  bacbbb
  cacbbb
  abcbbb
  bbcbbb
  cbcbbb
  accbbb
  bccbbb
  cccbbb
  aaaabbb
  baaabbb
  caaabbb
  abaabbb
  bbaabbb
  cbaabbb
  acaabbb
  bcaabbb
  ccaabbb
  aababbb
  bababbb
  cababbb
  abbabbb
  bbbabbb
  cbbabbb
  acbabbb
  bcbabbb
  ccbabbb
  aacabbb
  bacabbb
  cacabbb
  abcabbb
  bbcabbb
  cbcabbb
  accabbb
  bccabbb
  cccabbb
  aaabbbb
  baabbbb
  caabbbb
  ababbbb
  bbabbbb
  cbabbbb
  acabbbb
  bcabbbb
  ccabbbb
  aabbbbb
  babbbbb
  cabbbbb
  abbbbbb
  bbbbbbb
  cbbbbbb
  acbbbbb
  bcbbbbb
  ccbbbbb
  aacbbbb
  bacbbbb
  cacbbbb
  abcbbbb
  bbcbbbb
  cbcbbbb
  accbbbb
  bccbbbb
  cccbbbb
  aaacbbb
  baacbbb
  caacbbb
  abacbbb
  bbacbbb
  cbacbbb
  acacbbb
  bcacbbb
  ccacbbb
  aabcbbb
  babcbbb
  cabcbbb
  abbcbbb
  bbbcbbb
  cbbcbbb
  acbcbbb
  bcbcbbb
  ccbcbbb
  aaccbbb
  baccbbb
  caccbbb
  abccbbb
  bbccbbb
  cbccbbb
  acccbbb
  bcccbbb
  ccccbbb
- : unit = ()
</pre>
	  </li>


	</ol>
      </li>



    </ol>
	
    

  </body>
</html>

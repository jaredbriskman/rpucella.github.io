<!DOCTYPE html>
<html>

  <head>
    
    <meta charset="utf-8">
    <title>Homework 9</title>

    <link rel="stylesheet" href="alt.css" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,800,700' rel='stylesheet' type='text/css'>

    <script src="autoscroll.js"></script>
    
    <style>

      hr { margin-top: 50px; }

        code,tt,pre {
          font-size: 140%;
        }
	
        div.lect {
	  padding-top: 0;
       	  padding-left: 3em;
	  margin-top:0;
        }
    	p.ann { 
    	  padding-left: 3em;
    	  text-indent: -3em; 
    	}
	p.ann_ctd{
	  padding-left: 3em;
        }
    	span.hdr {
   	  padding-right: 1em
    	}

	.hidden {
	  visibility: hidden;
        }

        tt.code {
           background: #e6e6e6;
        }

	pre.code {
	   border: 1px solid #c6c6c6;
	border-radius: 5px;
	padding: 10px;
	font-size:100%;
	}

/* from
    http://www.456bereastreet.com/archive/201105/styling_ordered_list_numbers/
 */

ol {
    counter-reset:li; /* Initiate a counter */
    margin-left:0; /* Remove the default left margin */
    padding-left:0; /* Remove the default left padding */
    padding-top:1em;
}
ol > li {
    position:relative; /* Create a positioning context */
    margin:0 0 6px 2em; /* Give each list item a left margin to make
    room for the numbers */
    padding:4px 8px; /* Add some spacing around the content */
    list-style:none; /* Disable the normal item numbering */
    /*border-top:2px solid #666;
    background:#f6f6f6; */
}
ol > li:before {
    counter-increment:li; /* Increment the counter by 1 */
    /* Position and style the number */
    position:absolute;
    top:-2px;
    left:-2em;
    -moz-box-sizing:border-box;
    -webkit-box-sizing:border-box;
    box-sizing:border-box;
    width:2em;
    /* Some space between the number and the content in browsers that
    support
       generated content but not positioning it (Camino 2 is one
    example) */
    margin-right:8px;
    padding:4px;
/*    border-top:2px solid #666;
    color:#fff;
    background:#666; 
    font-weight:bold; */
/*    font-family:"Helvetica Neue", Arial, sans-serif;
    text-align:center; */
}

ol.letter > li:before {
    content:"(" counter(li,lower-alpha) ")"; /* Use the counter as content */
}

ol.number > li:before {
    content:"(" counter(li,decimal) ")"; /* Use the counter as content */
}

li ol,
li ul {margin-top:6px;}

li > p { margin-top:0;}

    </style>

  </head>


  <body>

    <div class="navbar">

      <div class="home">
	<a href="../../index.html"><img src="../../home.png" style="height: 1.6em;"></a>
      </div>

      <ul>
	<li><a href="index.html"><b>Foundations of Computer Science SP16</b></a></li> 
	<li class="hidden"><a class="scrollto" href="#announcements">Announcements</a></li>
	<li class="hidden"><a class="scrollto" href="#info">Course Info</a></li>
	<li class="hidden"><a class="scrollto" href="#lectures">Lectures</a></li>
	<li class="hidden"><a class="scrollto" href="#homeworks">Homeworks</a></li>
      </ul>
    </div>


    <!-- padding -->
    <div id="top" style="height: 7em;"></div>
    
    <h1 class="clear">Homework 9</h1>
    
    <p class="subtitle">Due date: Monday, April 25 (midnight)</p>

    <p><b>Note on integrity:</b> This homework is meant to be done
    individually. You may discuss problems with fellow students, but
    all work must be entirely your own, and should not be from any
    other course, present, past, or future. If you use a solution from
    another source you must cite it &mdash; this includes when that source
      is someone else helping you.</p>

    <p>Every source file you submit should begin with a block comment
      that lists your <span style="text-decoration:underline;">name</span>, your <span style="text-decoration:underline;">email address</span>, and any <span style="text-decoration:underline;">remarks</span> that you
      wish to make to the instructor.</p>

    <p>All programming is to be done in OCaml v4.</p>

    <p>Feel free to define helper functions if you need them.</p>

    <p>Please code your answers by modifying the
      file <a href="homework9.ml"><tt>homework9.ml</tt></a> provided.</p>

    <p>Electronic submission instructions:</p>

    <ul>
      <li>Download the file <a href="hw9-checker.ml"><tt>hw9-checker.ml</tt></a> into the same directory as your homework solution.</li>
      <li>Start a <i>new</i> OCaml shell.</li>
      <li>Load your homework code via <tt>#use "homework9.ml";;</tt></li>
      <li>Load the homework checker via <tt>#use "hw9-checker.ml";;</tt></li>
      <li>The homework checker checks that you've implemented all functions (or provided stubs for them) and that those functions have the type that I asked you to give them. If the checker says your types are OK, then you're fine. If the checker gives you an error, fix it. If you believe that the checker gives you an error wrongly, send me an email.</li>
      <li>When you're ready to submit, send an email with your file <tt>homework9.ml</tt> as an attachment to <tt>focs.sp16@gmail.com</tt> with subject <i>Homework 9 submission</i>.</li>
    </ul>

    <p>If your code fails because you did not follow the instructions above (in particular, because your code fails to type check when put in presence of my automated testing rig) I'll be unhappy.</p>


    <hr>

    <p>Recall the interface that I presented in class to
      work with infinite streams. Type <tt>'a stream</tt> represents a
      stream of elements of
    type <tt>'a</tt>, and the
    following operations are available on streams:</p>

    <pre>
cst    : 'a -> 'a stream
map    : ('a -> 'b) -> 'a stream -> 'b stream 
filter : ('a -> 'b -> bool) -> 'a stream -> 'b stream -> 'b stream
zip    : 'a stream -> 'b stream -> ('a * 'b) stream
split  : 'a stream -> ('a stream * 'a stream)    </pre>

    <p>These functions are straightforward: 
<ul>
<li><tt>cst <i>v</i></tt>
  creates an infinite constant stream of <tt><i>v</i></tt>s</li>
<li><tt>map <i>f</i> <i>s</i></tt> returns the stream obtained by
  applying function <tt><i>f</i></tt> to every element
  of <tt><i>s</i></tt>
<li><tt>filter <i>p</i> <i>ctl</i> <i>s</i></tt> returns the stream
  obtained by keeping only the elements of <tt><i>s</i></tt> for
  which <tt><i>p</i></tt> applied to a control
  element in <tt><i>ctl</i></tt> and the corresponding element
  in <tt><i>s</i></tt> is true</li>
<li><tt>zip <i>s1</i> <i>s2</i></tt> returns the stream obtained by
  pairing every corresponding element of <tt><i>s1</i></tt>
  and <tt><i>s2</i></tt>
<li><tt>split <i>s</i></tt> returns a <i>pair of streams</i>, the
  first stream being the constant stream of the first element
  of <tt><i>s</i></tt>, and the second stream being the stream of all
  but the first element of <tt><i>s</i></tt>.</li>
  </ul>
    </p>

    <p>The following function is the one that lets you build interesting streams:</p>
    <pre>
fby : 'a stream -> (unit -> 'a stream) -> 'a stream    </pre>
    <p>This function takes a stream <i>s</i> and a <i>function</i>
    returning some 
    stream <i>t</i>, and creates a new stream made up of the first
    element of <i>s</i> followed by the elements of the stream <i>t</i>
    obtained by applying the function. (The reason why the second
    argument of <tt>fby</tt> is a function is to prevent OCaml from
      evaluating the stream immediately. This is what makes it
    possible to work with infinite streams in a language like OCaml
    and not get into infinite loops.)</p>

    <p>To recall examples given in class, the stream of natural
    numbers can be defined as follows (note the use of a function: 
    feedback requires the use of a function because the only things in
    OCaml that can be recursive are functions, and feedback is
      implemented via recursion):</p>

    <pre>
let nats =
  let rec natsF () = fby (cst 0)
                         (fun () -> (map (fun x -> x+1) (natsF ()))) in
  natsF ()    </pre>

    <p>The function for computing partial sums of a stream, that is,
      where</p>
    <p>&nbsp;&nbsp;&nbsp;<tt>psums &lt;a1 a2 a3 ...&gt; = &lta1 (a1+a2) (a1+a2+a3)
	...&gt;</tt></p>
    <p>can be implemented as follows:</p>

    <pre>
let drop s = let (f,r) = split s in r

let rec psums s =
  fby s
      (fun () -> add (psums s) (drop s))    </pre>      

    <p>Streams cannot be displayed directly. To help us examine streams, I've provided you with two functions: 
    </p>
<pre>
prefix : int -> 'a stream -> 'a list
nth    : int -> 'a stream -> 'a    </pre>
<p>where <tt>prefix n s</tt> returns a list of the first <tt>n</tt>
elements of stream <tt>s</tt>, while <tt>nth n s</tt> returns
  the <tt>n</tt><sup>th</sup> element of stream <tt>s</tt>. Thus:</p>
<pre>
# prefix 10 nats;;
- : int list = [0; 1; 2; 3; 4; 5; 6; 7; 8; 9]
# prefix 10 (psums nats);;
- : int list = [0; 1; 3; 6; 10; 15; 21; 28; 36; 45]
# nth 100 nats;;
- : int = 100
# nth 100 (psums nats);;
- : int = 5050</pre>


    <hr>


    
    <ol class="number">

      <li> <p><b>Basic Stream Manipulation</b></p>

	<ol class="letter">

	  <li> <p>Code a function <tt class="code">scale</tt> of
	      type <tt class="code">int -> int stream -> int
		stream</tt> where <tt>scale n s</tt> returns the
	      stream obtained by multiplying every element
	      of <tt>s</tt> by <tt>n</tt>:</p>
	    <p><tt>scale n &lt;a1 a2 a3 ...&gt; = &lt;n*a1 n*a2 n*a3 ...&gt;</tt></p>
	    </p>

<pre class="code">
# prefix 10 (scale 2 nats);;
- : int list = [0; 2; 4; 6; 8; 10; 12; 14; 16; 18]
# prefix 10 (scale 3 evens);;
- : int list = [0; 6; 12; 18; 24; 30; 36; 42; 48; 54]
# prefix 10 (scale 4 odds);;
- : int list = [4; 12; 20; 28; 36; 44; 52; 60; 68; 76]
# prefix 10 (scale 0 nats);;
- : int list = [0; 0; 0; 0; 0; 0; 0; 0; 0; 0]</pre>
	  </li>


	  <li> <p>Code a function <tt class="code">mult</tt> of
	      type <tt class="code">int stream -> int stream -> int
		stream</tt> where <tt>mult s1 s2</tt> returns the
	      stream obtained by multiplying the corresponding
	      elements of <tt>s1</tt> and <tt>s2</tt>:</p>
	    <p><tt>mult &lt;a1 a2 a3 ...&gt; &lt;b1 b2 b3 ...&gt; =
		&lt;a1*b1 a2*b2 a3*b3 ...&gt;</tt></p>
	    </p>

<pre class="code">
# prefix 10 (mult nats nats);;
- : int list = [0; 1; 4; 9; 16; 25; 36; 49; 64; 81]
#  prefix 10 (mult nats evens);;
- : int list = [0; 2; 8; 18; 32; 50; 72; 98; 128; 162]
#  prefix 10 (mult nats odds);;
- : int list = [0; 3; 10; 21; 36; 55; 78; 105; 136; 171]
#  prefix 10 (mult (cst 4) nats);;
- : int list = [0; 4; 8; 12; 16; 20; 24; 28; 32; 36]
#  prefix 10 (mult (cst 0) nats);;
- : int list = [0; 0; 0; 0; 0; 0; 0; 0; 0; 0]</pre>
	  </li>

	  <li> <p>Code a function <tt class="code">unzip</tt> of
	      type <tt class="code">('a * 'b) stream -> ('a stream *
		'b stream)</tt> where <tt>unzip s</tt> takes a stream
	      of pairs <tt>s</tt> and returns <i>a pair of
	      streams</i>, the first being the stream of all first
	      elements of the pairs in <tt>s</tt>, the second being
	      the stream of all second elements of pairs in <tt>s</tt>:
	    </p>

	    <p><tt>unzip &lt;(a1,b1) (a2,b2) (a3,b3) ...&gt; = (&lt;a1
		a2 a3...&gt;, &lt;b1 b2 b3 ...&gt;)</tt></p>

<pre class="code">
# prefix 10 (let (s1,s2) = unzip(cst(66,99)) in s1);;
- : int list = [66; 66; 66; 66; 66; 66; 66; 66; 66; 66]
# prefix 10 (let (s1,s2) = unzip(cst(66,99)) in s2);;
- : int list = [99; 99; 99; 99; 99; 99; 99; 99; 99; 99]

# prefix 10 (let (s1,s2) = unzip(zip nats evens) in s1);;
- : int list = [0; 1; 2; 3; 4; 5; 6; 7; 8; 9]
# prefix 10 (let (s1,s2) = unzip(zip nats evens) in s2);;
- : int list = [0; 2; 4; 6; 8; 10; 12; 14; 16; 18]

# prefix 10 (let (s1,s2) = unzip(map (fun (x,y) -> (y,x)) (zip nats evens)) in s1);;
- : int list = [0; 2; 4; 6; 8; 10; 12; 14; 16; 18]
# prefix 10 (let (s1,s2) = unzip(map (fun (x,y) -> (y,x)) (zip nats evens)) in s2);;
- : int list = [0; 1; 2; 3; 4; 5; 6; 7; 8; 9]</pre>
	  </li>
	  <li> <p>Code a function <tt class="code">fold</tt> of
	      type <tt class="code">('a -> 'b -> 'b) -> 'b stream ->
		'a stream -> 'b stream</tt> where <tt>fold f init_s
	      s</tt> returns the stream obtained by the result of
	      calling <tt>f</tt> over each element of <tt>s</tt> and
	      passing in the previous value of the resulting
	      stream. The initial "previous" value is the first
	      element of <tt>init_s</tt>:
	    </p>

	    <p><tt>fold f &lt;i1 i2 i3 ...&gt; &lt;a1 a2 a3 ...&gt; =<br>
		&lt;(f a1 i1) (f a2 (f a1 i1)) (f a3 (f a2 (f a1 i1))) ...&gt;</tt></p>

<pre class="code">
# prefix 10 (fold (fun a r -> a+r) (cst 0) nats);;
- : int list = [0; 1; 3; 6; 10; 15; 21; 28; 36; 45]
# prefix 10 (fold (fun a r -> a+r) (cst 10) evens);;
- : int list = [10; 12; 16; 22; 30; 40; 52; 66; 82; 100]
# prefix 10 (fold (fun a r -> abs(a-r)) (cst 0) nats);;
- : int list = [0; 1; 1; 2; 2; 3; 3; 4; 4; 5]
# prefix 10 (fold (fun a r -> a*r) (cst 0) nats);;
- : int list = [0; 0; 0; 0; 0; 0; 0; 0; 0; 0]
# prefix 10 (fold (fun a r -> a*r) (cst 1) nats);;
- : int list = [0; 0; 0; 0; 0; 0; 0; 0; 0; 0]
# prefix 10 (fold (fun a r -> a*r) (cst 1) odds);;
- : int list = [1; 3; 15; 105; 945; 10395; 135135; 2027025; 34459425; 654729075]</pre>
	  </li>

	  <li> <p>Code a function <tt class="code">running_max</tt> of
	      type <tt class="code">int stream -> int stream</tt>
	      where <tt>running_max s</tt> returns the stream consisting
	      of the maximum value in <tt>s</tt> from the start
	      of <tt>s</tt> up to the corresponding position:</p>
	    
	    <p><tt>running_max &lt;a1 a2 a3 ...&gt; = &lt;max(a1)
		max(a1,a2) max(a1,a2,a3) ...&gt;</tt></p>

<pre class="code">
# prefix 10 (running_max nats);;
- : int list = [0; 1; 2; 3; 4; 5; 6; 7; 8; 9]
# prefix 10 (running_max odds);;
- : int list = [1; 3; 5; 7; 9; 11; 13; 15; 17; 19]
# prefix 10 (running_max (map (fun x -> (-x)) nats));;
- : int list = [0; 0; 0; 0; 0; 0; 0; 0; 0; 0]
# prefix 10 (running_max (map (fun x -> if x mod 2 = 0 then x else -x) nats));;
- : int list = [0; 0; 2; 2; 4; 4; 6; 6; 8; 8]
# prefix 30 (running_max ampl);;
- : int list = [0; 1; 1; 1; 1; 1; 2; 2; 2; 2; 2; 2; 2; 2; 2; 3; 3; 3; 3; 3; 3; 3; 3; 3; 3; 3; 3; 3; 4; 4]</pre>
	  </li>

<li> <p><b>(Challenging)</b>  Code a function <tt class="code">stutter</tt> of
	      type <tt class="code">'a stream -> 'a stream</tt>
    where <tt>stutter s</tt> returns the stream consisting of every
    element of <tt>s</tt> repeated twice in a row:</p>

  <p><tt>sutter &lt;a1 a2 a3 ...&gt; = &lt;a1 a1 a2 a2 a3 a3 ...&gt;</tt></p>
    
	    </p>

<pre class="code">
# prefix 10 (stutter nats);;
- : int list = [0; 0; 1; 1; 2; 2; 3; 3; 4; 4]
# prefix 10 (stutter s_a);;
- : string list = ["a0"; "a0"; "a1"; "a1"; "a2"; "a2"; "a3"; "a3"; "a4"; "a4"]
# prefix 10 (stutter (zip s_a s_b));;
- : (string * string) list = [("a0", "b0"); ("a0", "b0"); ("a1", "b1"); ("a1", "b1"); ("a2", "b2");
("a2", "b2"); ("a3", "b3"); ("a3", "b3"); ("a4", "b4"); ("a4", "b4")]
# prefix 20 (stutter (stutter nats));;
- : int list = [0; 0; 0; 0; 1; 1; 1; 1; 2; 2; 2; 2; 3; 3; 3; 3; 4; 4; 4; 4]</pre>
	  </li>

	</ol>

      </li>


<li> <p><b>Numerical Analysis</b></p>

  <p>
Many problems in numerical analysis involve finding better and better
approximations to a desired value (such as &pi; or <i>e</i>,
or the solution to a differential equation) until the difference
between successive approximations gets small enough that we decide
that we have converged and report that we have found the value we're
looking for. 
  </p>

<p>Infinite streams help in this context because we can represent the 
  successive approximations to a value by a stream of those
  approximations.</p>

<p>
In this question, we will mostly be dealing with streams of floating 
point numbers. To make your life a bit easier, you may want to code 
functions <tt>scalef</tt>, <tt>addf</tt>, and <tt>psumsf</tt> of type
<pre>
  scalef : float -> float stream -> float stream
  addf   : float stream -> float stream -> float stream
  psumsf : float stream -> float stream
</pre>
that basically do what <tt>scale</tt>, <tt>add</tt>,
and <tt>psums</tt> do, but with floating point numbers instead of
integers. 
</p>

	<ol class="letter">

	  <li> <p>How do you compute the value of &pi;? One way is to
	      use trigonometry. One of the earliest approaches uses the
	      fact that <i>tan</i> &pi;/4 = 1. Using <i>arctan</i>,
	      the inverse <i>tan</i> function, 
	      we can express this as &pi;/4 = <i>arctan</i> 1, that
	      is, &pi; = 4 <i>arctan</i> 1.</p>
	    
	    <p>Why
	      does that help us? The Taylor expansion of <i>arctan</i> at x
	      tells us that </p>
	    <p> &nbsp;&nbsp;&nbsp;<i>arctan</i> x = x/1
	      - x<sup>3</sup>/3 + x<sup>5</sup>/5
	      - x<sup>7</sup>/7 + ...</p>
	    <p>This is an infinite sum, but it can be approximated by
	      the stream of partial sums</p>
	    <p> &nbsp;&nbsp;&nbsp;&lt;x/1 &nbsp;&nbsp; (x/1 - x<sup>3</sup>/3)
	      &nbsp;&nbsp;(x/1 - x<sup>3</sup>/3 + x<sup>5</sup>/5)
	      &nbsp;&nbsp;(x/1 - x<sup>3</sup>/3 + x<sup>5</sup>/5 - x<sup>7</sup>/7)
	      &nbsp;&nbsp;...&gt; &nbsp;&nbsp;&nbsp; (*)</p>
	    <p>which gets closer and closer to <i>arctan</i> x.</p>

	    <p>Code a function <tt class="code">arctan</tt> with type
	      <tt class="code">float -> float stream</tt>
	      where <tt>arctan x</tt> returns a stream of approximations to
	      <i>arctan</i> x given by (*) above</p>

	    <pre class="code">
# prefix 10 (arctan 0.0);;
- : float list = [0.; 0.; 0.; 0.; 0.; 0.; 0.; 0.; 0.; 0.]
# prefix 10 (arctan 1.0);;
- : float list =
[1.; 0.666666666666666741; 0.866666666666666696; 0.723809523809523903;
 0.834920634920635063; 0.744011544011544124; 0.820934620934621107;
 0.754267954267954455; 0.813091483679719174; 0.760459904732350811]
# prefix 10 (arctan 0.5);;
- : float list =
[0.5; 0.458333333333333315; 0.464583333333333293; 0.46346726190476184;
 0.463684275793650735; 0.463639886589105266; 0.463649276613143702;
 0.463647242107935342; 0.463647690895848952; 0.463647590509078777]
# prefix 10 (scalef 4.0 (arctan 1.0));;
- : float list =
[4.; 2.66666666666666696; 3.46666666666666679; 2.89523809523809561;
 3.33968253968254025; 2.97604617604617649; 3.28373848373848443;
 3.01707181707181782; 3.25236593471887669; 3.04183961892940324]
# nth 1000 (scalef 4.0 (arctan 1.0));;
- : float = 3.14259165433954424	    </pre>

	    <p>The last example shows that this way of computing &pi; converges very
	      slowly. After 1000 terms into the stream, we're still only at
	      3.142591... which is pretty far from 3.141592...</p>

	    <p>A more efficient way to compute &pi; is to use the following formula:</p>
	    
	    <p>&nbsp;&nbsp;&nbsp; &pi;/4 = 4 <i>arctan</i> (1/5)
	      - <i>arctan</i> (1/239)</p>

	    <p>and thus</p>
	    
	    <p>&nbsp;&nbsp;&nbsp; &pi; = 16 <i>arctan</i> (1/5) -
	      4 <i>arctan</i> (1/239) &nbsp;&nbsp;&nbsp;(**)</p>

	    <p>Again, we know each of the <i>arctan</i> can be approximated by the stream
	      (*), and thus &pi; can be
	      approximated by the difference of the two streams, each properly scaled. </p>

	    <p>Code an expression  <tt class="code">pi</tt> with type <tt class="code">float stream</tt>
	      which is a stream providing
	      approximations to &pi; using (**)</p>

<pre class="code">
# prefix 10 pi;;
- : float list =
[3.18326359832636; 3.14059702932606033; 3.14162102932503462;
 3.14159177218217733; 3.14159268240439937; 3.14159265261530862;
 3.141592653623555; 3.14159265358860251; 3.14159265358983619;
 3.14159265358979223]
# nth 100 pi;;
- : float = 3.141592653589794</pre>
	  </li>


	  <li> 
	    <p>Newton's method is a way to find a zero of a formula with one
	      unknown, such as 10x+20. Recall that a zero of a formula f(x) is a
	      value v that makes f(v)=0. To compute &radic;10,
	      for instance, we can use Newton's method to find a zero of
	      x<sup>2</sup>-10. To compute &#x221b;20 we find a zero of
	      x<sup>3</sup>-20, and so on.  </p>

	    <p>What is Newton's method? It says that to find a zero of f(x), we
	    need the derivative of f, written f'(x), as well as an initial
	    guess x<sub>0</sub>. The guess doesn't have to be a good guess. Once we have a
	      guess x<sub>0</sub>, we can improve the guess by computing x<sub>1</sub> as follows:</p>

	  <p>&nbsp;&nbsp;&nbsp;x<sub>1</sub> = x<sub>0</sub> -
	  f(x<sub>0</sub>)/f'(x<sub>0</sub>)</p>

	    <p>We can repeatedly improve guesses using:</p>
	    <p> &nbsp;&nbsp;&nbsp;
	    x<sub>n+1</sub> = x<sub>n</sub> -
	    f(x<sub>n</sub>)/f'(x<sub>n</sub>)
	    &nbsp;&nbsp;&nbsp;(***)</p>

	    <p>where x<sub>i</sub> is the i<sup>th</sup> guess. Each
	      guess gets closer and closer to a zero of f(x).</p>

	    <p>Code a function <tt class="code">newton</tt> with type
	      <tt class="code">(float -> float) -> (float -> float) ->
		float -> float stream</tt> where <tt>newton f df
		guess</tt> returns the stream of guesses given by 
	      (***) for function <tt>f</tt> with its derivative <tt>df</tt>, and initial
	      guess <tt>guess</tt>.
	    </p>

<pre class="code">
# prefix 10 (newton (fun x -> 3.0 *. x -. 2.0) (fun x -> 3.0) 1.0);;
- : float list =
[1.; 0.666666666666666741; 0.666666666666666741; 0.666666666666666741;
 0.666666666666666741; 0.666666666666666741; 0.666666666666666741;
 0.666666666666666741; 0.666666666666666741; 0.666666666666666741]

# let sqrt v = newton (fun x -> x *. x -. v) (fun x -> 2.0 *. x) 1.0;;
val sqrt : float -> float stream = <fun>

# prefix 10 (sqrt 4.0);;
- : float list =
[1.; 2.5; 2.05; 2.00060975609756087; 2.00000009292229475;
 2.00000000000000222; 2.; 2.; 2.; 2.]
# prefix 10 (sqrt 9.0);;
- : float list =
[1.; 5.; 3.4; 3.0235294117647058; 3.00009155413138; 3.00000000139698386; 3.;
 3.; 3.; 3.]
# prefix 10 (sqrt 2.0);;
- : float list =
[1.; 1.5; 1.41666666666666674; 1.41421568627450989; 1.41421356237468987;
 1.41421356237309515; 1.41421356237309492; 1.41421356237309515;
 1.41421356237309492; 1.41421356237309515]
# prefix 10 (sqrt 3.0);;
- : float list =
[1.; 2.; 1.75; 1.73214285714285721; 1.7320508100147276; 1.73205080756887719;
 1.73205080756887742; 1.73205080756887719; 1.73205080756887742;
 1.73205080756887719]
# prefix 10 (sqrt 144.0);;
- : float list =
[1.; 72.5; 37.2431034482758605; 20.5547955554420376; 13.7802299905638;
 12.11499150672641; 12.0005457307424379; 12.0000000124086874; 12.; 12.]</pre>
	  </li>


	  <li> <p>Given that we talked about derivatives in (b), how about
  computing derivatives? It is itself an approximate process. More
  specifically, the value of the derivative of a function f at a
	  point x<sub>0</sub> can be approximated by the
	      sequence:</p>

  <p>&nbsp;&nbsp;&nbsp;
    &lt;<sup>f(x<sub>0</sub>+1)-f(x<sub>0</sub>)</sup> &frasl; <sub>1</sub>
    &nbsp;&nbsp;
    <sup>f(x<sub>0</sub>+&frac12;)-f(x<sub>0</sub>)</sup> &frasl; <sub>&frac12;</sub>
    &nbsp;&nbsp;
    <sup>f(x<sub>0</sub>+&frac13;)-f(x<sub>0</sub>)</sup> &frasl; <sub>&frac13;</sub>
    &nbsp;&nbsp;...&gt;&nbsp;&nbsp;&nbsp;(****)</p>
  <p>where the n<sup>th</sup> term in the sequence is:</p>
  <p>&nbsp;&nbsp;&nbsp; <sup>f(x<sub>0</sub>+(1/n))-f(x<sub>0</sub>)</sup>
    &frasl; <sub>(1/n)</sub></p>

	    <p>Code a function <tt class="code">derivative</tt> with type
	      <tt class="code">(float -> float) -> float -> float stream</tt>
	      where <tt>derivative f x</tt> returns the stream of approximations of the
	      derivative of <tt>f</tt> at point <tt>x</tt> given by (****).
	    </p>

<pre class="code">
# let d = derivative (fun x -> x *. x) 4.0;;
val d : float stream = <abstr>
   (* The derivative of x^2 is just 2x *)

# prefix 10 d;;
- : float list =
[9.; 8.5; 8.33333333333332504; 8.25; 8.20000000000000284;
 8.16666666666668561; 8.14285714285715656; 8.125; 8.11111111111107519;
 8.09999999999998721]
# nth 400 d;;
- : float = 8.00249376558566539
# nth 1000 d;;
- : float = 8.00099900099941408

# prefix 10 (derivative (fun x -> x *. x +. 10.0) 4.0);;
    (* The derivative of x^2 + 10 is still just 2x *)
- : float list =
[9.; 8.5; 8.33333333333332504; 8.25; 8.20000000000000284;
 8.16666666666668561; 8.14285714285715656; 8.125; 8.11111111111107519;
 8.09999999999998721]
# prefix 10 (derivative (fun x -> 3.0 *. x) 4.0);;
    (* The derivative of 3x is 3 *)
- : float list =
[3.; 3.; 3.; 3.; 3.00000000000000711; 3.; 3.00000000000001421; 3.;
 2.99999999999998934; 2.99999999999998934]

# let d = derivative (fun x-> x *. x *. x +. x *. x +. 2.0 *. x) 2.0;;
val d : float stream = <abstr>
   (* The derivative of x^3 + x^2 + 2x is 3x^2 + 2x + 2 *)

# prefix 10 d;;
- : float list =
[26.; 21.75; 20.4444444444444606; 19.8125; 19.4400000000000261;
 19.1944444444444144; 19.0204081632652766; 18.890625; 18.7901234567901305;
 18.7100000000000222]
# nth 200 d;;
- : float = 18.0348506225091967
# nth 1000 d;;
- : float = 18.0069940049968906</pre>
	  </li>
</li>

	  <li> <p> All of the above questions return streams yielding better and
	      better approximations to a desired value. By picking out an
	      element of the stream far enough down, we can find a good
	      approximation to the value we want.</p>

	    <p>But how far do we go? Approximations get closer and closer to the
	      value they approximate, which means that the difference between
	      successive approximations gets smaller and smaller. So we can look into
	      the stream and try to find the first approximation which differs from
	      the next approximation by a small enough margin to decide
	      that we have converged to the desired value, and take that as the
	      desired approximation. Since we can make the margin as small as we
	      want, we can get approximation that are as close as we want to the
	      actual value we seek. (All of this assuming that the
	      stream actually converges to the desired value. What
	      happens if the stream does <i>not</i> converge?)</p>

	    <p>Code a function <tt class="code">limit</tt> with type
	      <tt class="code">float -> float stream -> float stream</tt>
	      where <tt>limit epsilon s</tt> returns the elements of
	      stream <tt>s</tt> that differ from their subsequent
	      element by less than <tt>epsilon</tt> (in absolute value).</p>

<pre class="code">
# prefix 10 (limit 0.00001 (map (fun n -> 1.0 /. (float (n+1))) nats));;
- : float list =
[0.00316455696202531641; 0.00315457413249211347; 0.00314465408805031463;
 0.00313479623824451398; 0.003125; 0.00311526479750778807;
 0.00310559006211180103; 0.0030959752321981426; 0.00308641975308641958;
 0.00307692307692307692]
# prefix 10 (limit 0.0000000001 pi);;
- : float list =
[3.141592653623555; 3.14159265358860251; 3.14159265358983619;
 3.14159265358979223; 3.141592653589794; 3.141592653589794;
 3.141592653589794; 3.141592653589794; 3.141592653589794; 3.141592653589794]
# prefix 10 (limit 0.0000000001 (newton (fun x -> x *. x -. 10.0) (fun x -> 2.0 *. x) 1.0));;
- : float list =
[3.16227766016837952; 3.16227766016837908; 3.16227766016837952;
 3.16227766016837908; 3.16227766016837952; 3.16227766016837908;
 3.16227766016837952; 3.16227766016837908; 3.16227766016837952;
 3.16227766016837908]
# prefix 10 (limit 0.0000001 (derivative (fun x -> x *. x) 4.0));;
- : float list =
[8.00031625552450265; 8.00031615555879583; 8.00031605562637;
 8.00031595577122445; 8.00031585596800454; 8.00031575622316637;
 8.00031565656377097; 8.00031555696997; 8.00031545740871763;
 8.00031535793515]</pre>
	  </li>


	</ol>
      </li>



      <li> <p><b>Working with Infinite Streams</b></p>

	<p>Suppose you are given two streams of values, A = <tt>&lt;a0
	    a1 a2
	    a3 ...&gt;</tt> and B = <tt>&lt;b0 b1 b2 b3 ...&gt;</tt> and you want to create a single stream of
	  all pairs of elements from A and B. How would you go about it? </p>

	<p>Clearly, you cannotsimply list all the
	  elements of B paired with <tt>a0</tt>, followed by all the
	  elements of B paired with <tt>a1</tt>, followed by all the
	  elements of B paired with <tt>a2</tt>, and so on: since the
	  streams are infinite, our resulting stream would start with the 
	  infinite number of elements from B paired with <tt>a0</tt>, and no
	  matter how far down into the resulting stream we go, we would never get to
	  an element paired with <tt>a1</tt> or <tt>a2</tt> or <tt>a3</tt>.

	<p>So is there a way to get a stream with all the pairs of elements from
	  A and B in such a way that for any element <tt>a</tt> from A and element
	  <tt>b</tt> from B, we need only go down a finite number of positions in
	  the resulting stream to find <tt>(a,b)</tt>?</p>

	<p>The answer is yes &mdash; there are many ways to do it. Here is a
	  particularly simple one. Notionally, construct the infinite
	  two-dimensional table: 
	  <pre>
 (a0,b0)  (a0,b1)  (a0,b2)  (a0,b3)  ...
 (a1,b0)  (a1,b1)  (a1,b2)  (a1,b3)  ...
 (a2,b0)  (a2,b1)  (a2,b2)  (a2,b3)  ...
 (a3,b0)  (a3,b1)  (a3,b2)  (a3,b3)  ...
   ...      ...      ...      ...	  </pre>
and traverse it diagonally as follows: start with each element of
the first row, from left to right, and for each element list the
	  elements obtained by going diagonally in the south-western direction. </p>

	<p>Thus, in the above table, the first <i>diagonal stripe</i>
	  traversed is just <tt>(a0,b0)</tt>. The second diagonal
	  stripe traversed is <tt>(a0,b1), (a1,b0)</tt>. 
	  The third diagonal stripe traversed
	  is <tt>(a0,b2), (a1,b1), (a2,b0)</tt>. 
	  The fourth diagonal stripe traversed is <tt>(a0,b3),
	  (a1,b2), (a2,b1), (a3,b0)</tt>. And so 
	  on. A stream that simply lists all the elements of the first
	  diagonal stripe,
	  followed by all the elements of the second diagonal stripe, followed by all the
	  elements of the third diagonal stripe, etc, ends up listing all the elements of
	  the table, which is what we want.
	</p>

	<p>In the questions below, we are going to be working with
	streams of lists. There is nothing conceptually different
	about them, but it probably means that the functions you are
	  going to pass to primitives like <tt>map</tt>
	and <tt>filter</tt> on streams will be a bit more
	interesting. Dataflow networks remain a good way to think
	about the high-level structure of your code.</p>

	<ol class="letter">

	  <li> <p>Code a function <tt class="code">rev_prefixes</tt> of
	      type <tt class="code">'a stream -> 'a list stream</tt>
	      where <tt>rev_prefixes s</tt> returns the stream of
	      reverse prefixes of <tt>s</tt>: </p>

	    <p><tt>rev_prefixes &lt;a0 a1 a2 a3 ...&gt; =
		&lt;[a0]
		[a1;a0] [a2;a1;a0] [a3;a2;a1;a0] ...&gt;</tt></p>

<pre class="code">
# prefix 10 (rev_prefixes s_a);;
- : string list list =
[["a0"]; ["a1"; "a0"]; ["a2"; "a1"; "a0"]; ["a3"; "a2"; "a1"; "a0"];
 ["a4"; "a3"; "a2"; "a1"; "a0"]; ["a5"; "a4"; "a3"; "a2"; "a1"; "a0"];
 ["a6"; "a5"; "a4"; "a3"; "a2"; "a1"; "a0"];
 ["a7"; "a6"; "a5"; "a4"; "a3"; "a2"; "a1"; "a0"];
 ["a8"; "a7"; "a6"; "a5"; "a4"; "a3"; "a2"; "a1"; "a0"];
 ["a9"; "a8"; "a7"; "a6"; "a5"; "a4"; "a3"; "a2"; "a1"; "a0"]]</pre>
	  </li>


	  <li> <p>Code a function <tt class="code">prefixes</tt> of
	      type <tt class="code">'a stream -> 'a list stream</tt>
	      where <tt>prefixes s</tt> returns the stream of
	      prefixes of <tt>s</tt>: </p>

	    <p><tt>prefixes &lt;a0 a1 a2 a3 ...&gt; =
		&lt;[a0]
		[a0;a1] [a0;a1;a2] [a0;a1;a2;a3] ...&gt;</tt></p>

	    <p>(Curious: why did I decide to define these functions in that order?)</p>

<pre class="code">
# prefix 10 (prefixes s_a);;
- : string list list =
[["a0"]; ["a0"; "a1"]; ["a0"; "a1"; "a2"]; ["a0"; "a1"; "a2"; "a3"];
 ["a0"; "a1"; "a2"; "a3"; "a4"]; ["a0"; "a1"; "a2"; "a3"; "a4"; "a5"];
 ["a0"; "a1"; "a2"; "a3"; "a4"; "a5"; "a6"];
 ["a0"; "a1"; "a2"; "a3"; "a4"; "a5"; "a6"; "a7"];
 ["a0"; "a1"; "a2"; "a3"; "a4"; "a5"; "a6"; "a7"; "a8"];
 ["a0"; "a1"; "a2"; "a3"; "a4"; "a5"; "a6"; "a7"; "a8"; "a9"]]</pre>
	  </li>

	  <li> <p>Code a function <tt class="code">stripes</tt> of
	      type <tt class="code">'a stream -> 'b stream -> ('a *
		'b) stream</tt> where <tt>stripes s1 s2</tt> returns
	      the stream of stripes of <tt>s1</tt> and <tt>s2</tt> as
	      described above,
	      where each stripe is given as a list. 
	    </p>

<pre class="code">
# prefix 10 (stripes s_a s_b);;
- : (string * string) list list =
[[("a0", "b0")]; [("a0", "b1"); ("a1", "b0")];
 [("a0", "b2"); ("a1", "b1"); ("a2", "b0")];
 [("a0", "b3"); ("a1", "b2"); ("a2", "b1"); ("a3", "b0")];
 [("a0", "b4"); ("a1", "b3"); ("a2", "b2"); ("a3", "b1"); ("a4", "b0")];
 [("a0", "b5"); ("a1", "b4"); ("a2", "b3"); ("a3", "b2"); ("a4", "b1");
  ("a5", "b0")];
 [("a0", "b6"); ("a1", "b5"); ("a2", "b4"); ("a3", "b3"); ("a4", "b2");
  ("a5", "b1"); ("a6", "b0")];
 [("a0", "b7"); ("a1", "b6"); ("a2", "b5"); ("a3", "b4"); ("a4", "b3");
  ("a5", "b2"); ("a6", "b1"); ("a7", "b0")];
 [("a0", "b8"); ("a1", "b7"); ("a2", "b6"); ("a3", "b5"); ("a4", "b4");
  ("a5", "b3"); ("a6", "b2"); ("a7", "b1"); ("a8", "b0")];
 [("a0", "b9"); ("a1", "b8"); ("a2", "b7"); ("a3", "b6"); ("a4", "b5");
  ("a5", "b4"); ("a6", "b3"); ("a7", "b2"); ("a8", "b1"); ("a9", "b0")]]</pre>
	  </li>

	  <li> <p><b>(Challenging &mdash; this one had me stumped for
		a good 20 minutes</b>) Code a
		function <tt class="code">flatten</tt> of
	      type <tt class="code">'a list stream -> 'a stream</tt>
	      where <tt>flatten s</tt> returns the stream of all elements of all the
	      lists in <tt>s</tt> in order:</p>

	    <p><tt>flatten &lt;[a1;a2;a3] [b1;b2;b3] [c1;c2;c3] ...&gt
		=<br> &lt;a1 a2 a3 b1 b2 b3 c1 c2 c3 ...&gt;</tt></p>

	    <p><b>Hint:</b> you may want to filter out all the empty
	      lists from the stream as a first step. Also: recursion!</p>

<pre class="code">
# prefix 10 (flatten (map (fun n -> [n]) nats));;
- : int list = [0; 1; 2; 3; 4; 5; 6; 7; 8; 9]
# prefix 10 (flatten (map (fun n -> [n;n+1]) nats));;
- : int list = [0; 1; 1; 2; 2; 3; 3; 4; 4; 5]
# prefix 10 (flatten (map (fun n -> [n;n+1;n+2]) nats));;
- : int list = [0; 1; 2; 1; 2; 3; 2; 3; 4; 3]
# prefix 10 (flatten (map (fun n -> if n mod 3 = 0 then [] else [n;n+1;n+2]) nats));;
- : int list = [1; 2; 3; 2; 3; 4; 4; 5; 6; 5]</pre>
	  </li>

	  <li> <p>Code a function <tt class="code">pairs</tt> of
	      type <tt class="code">'a stream -> 'b stream -> ('a *
		'b) stream</tt> where <tt>pairs s1 s2</tt> returns the
	      stream of <i>all</i> possible pairs of elements
	      from <tt>s1</tt> and <tt>s2</tt>, using the stripes
	      method outlined above.
	    </p>

<pre class="code">
# prefix 20 (pairs s_a s_b);;
- : (string * string) list =
[("a0", "b0"); ("a0", "b1"); ("a1", "b0"); ("a0", "b2"); ("a1", "b1");
 ("a2", "b0"); ("a0", "b3"); ("a1", "b2"); ("a2", "b1"); ("a3", "b0");
 ("a0", "b4"); ("a1", "b3"); ("a2", "b2"); ("a3", "b1"); ("a4", "b0");
 ("a0", "b5"); ("a1", "b4"); ("a2", "b3"); ("a3", "b2"); ("a4", "b1")]</pre>
	  </li>
		  
	</ol>
	
      </li>

    </ol>

  </body>
</html>

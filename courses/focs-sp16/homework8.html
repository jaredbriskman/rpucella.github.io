<!DOCTYPE html>
<html>

  <head>
    
    <meta charset="utf-8">
    <title>Homework 8</title>

    <link rel="stylesheet" href="alt.css" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,800,700' rel='stylesheet' type='text/css'>

    <script src="autoscroll.js"></script>
    
    <style>

      hr { margin-top: 50px; }

        code,tt,pre {
          font-size: 140%;
        }
	
        div.lect {
	  padding-top: 0;
       	  padding-left: 3em;
	  margin-top:0;
        }
    	p.ann { 
    	  padding-left: 3em;
    	  text-indent: -3em; 
    	}
	p.ann_ctd{
	  padding-left: 3em;
        }
    	span.hdr {
   	  padding-right: 1em
    	}

	.hidden {
	  visibility: hidden;
        }

        tt.code {
           background: #e6e6e6;
        }

	pre.code {
	   border: 1px solid #c6c6c6;
	border-radius: 5px;
	padding: 10px;
	font-size:100%;
	}

/* from
    http://www.456bereastreet.com/archive/201105/styling_ordered_list_numbers/
 */

ol {
    counter-reset:li; /* Initiate a counter */
    margin-left:0; /* Remove the default left margin */
    padding-left:0; /* Remove the default left padding */
    padding-top:1em;
}
ol > li {
    position:relative; /* Create a positioning context */
    margin:0 0 6px 2em; /* Give each list item a left margin to make
    room for the numbers */
    padding:4px 8px; /* Add some spacing around the content */
    list-style:none; /* Disable the normal item numbering */
    /*border-top:2px solid #666;
    background:#f6f6f6; */
}
ol > li:before {
    counter-increment:li; /* Increment the counter by 1 */
    /* Position and style the number */
    position:absolute;
    top:-2px;
    left:-2em;
    -moz-box-sizing:border-box;
    -webkit-box-sizing:border-box;
    box-sizing:border-box;
    width:2em;
    /* Some space between the number and the content in browsers that
    support
       generated content but not positioning it (Camino 2 is one
    example) */
    margin-right:8px;
    padding:4px;
/*    border-top:2px solid #666;
    color:#fff;
    background:#666; 
    font-weight:bold; */
/*    font-family:"Helvetica Neue", Arial, sans-serif;
    text-align:center; */
}

ol.letter > li:before {
    content:"(" counter(li,lower-alpha) ")"; /* Use the counter as content */
}

ol.number > li:before {
    content:"(" counter(li,decimal) ")"; /* Use the counter as content */
}

li ol,
li ul {margin-top:6px;}

li > p { margin-top:0;}

    </style>

  </head>


  <body>

    <div class="navbar">

      <div class="home">
	<a href="../../index.html"><img src="../../home.png" style="height: 1.6em;"></a>
      </div>

      <ul>
	<li><a href="index.html"><b>Foundations of Computer Science SP16</b></a></li> 
	<li class="hidden"><a class="scrollto" href="#announcements">Announcements</a></li>
	<li class="hidden"><a class="scrollto" href="#info">Course Info</a></li>
	<li class="hidden"><a class="scrollto" href="#lectures">Lectures</a></li>
	<li class="hidden"><a class="scrollto" href="#homeworks">Homeworks</a></li>
      </ul>
    </div>


    <!-- padding -->
    <div id="top" style="height: 7em;"></div>
    
    <h1 class="clear">Homework 8</h1>
    
    <p class="subtitle">Due date: Saturday, April 9 (midnight)</p>

    <p><b>Note on integrity:</b> This homework is meant to be done
    individually. You may discuss problems with fellow students, but
    all work must be entirely your own, and should not be from any
    other course, present, past, or future. If you use a solution from
    another source you must cite it &mdash; this includes when that source
      is someone else helping you.</p>

    <p>Every source file you submit should begin with a block comment
      that lists your <span style="text-decoration:underline;">name</span>, your <span style="text-decoration:underline;">email address</span>, and any <span style="text-decoration:underline;">remarks</span> that you
      wish to make to the instructor.</p>

    <p>All programming is to be done in OCaml v4.</p>

    <p>Feel free to define helper functions if you need them.</p>

    <p>Please code your answers by modifying the
      file <a href="homework8.ml"><tt>homework8.ml</tt></a> provided.</p>

    <p>Electronic submission instructions:</p>

    <ul>
<!--      <li>Download the file <a href="hw8-checker.ml"><tt>hw8-checker.ml</tt></a> into the same directory as your homework solution.</li> -->
      <li>Start a <i>new</i> OCaml shell.</li>
      <li>Load your homework code via <tt>#use "homework8.ml";;</tt></li>
<!--      <li>Load the homework checker via <tt>#use "hw8-checker.ml";;</tt></li>
      <li>The homework checker checks that you've implemented all functions (or provided stubs for them) and that those functions have the type that I asked you to give them. If the checker says your types are OK, then you're fine. If the checker gives you an error, fix it. If you believe that the checker gives you an error wrongly, send me an email.</li>-->
      <li>Make sure the file loads without errors.</li>
      <li>When you're ready to submit, send an email with your file <tt>homework8.ml</tt> as an attachment to <tt>focs.sp16@gmail.com</tt> with subject <i>Homework 8 submission</i>.</li>
    </ul>

    <p>If your code fails because you did not follow the instructions above (in particular, because your code fails to type check when put in presence of my automated testing rig) I'll be unhappy.</p>


    <hr>


    <p>This homework is about the lambda calculus. I've implemented
    some code for you to enter and simplify &lambda;-terms using the
    rules we saw in class. The result is not very fast, but it
    works.</p>

    <p>A &lambda;-term is just a string in OCaml. The syntax of &lambda;-terms is
      the one we saw in class, adapted to the ASCII character set:
      <ul>
	<li>An identifier can be any sequence of alphanumeric
	  characters (including <tt>_</tt>, and starting with a
	  letter), such as <tt>x</tt> or <tt>arg_2</tt>
	<li>A lambda is written <tt>/identifier.M</tt>
	  where <tt>M</tt> is a term, such
	  as <tt>/x.x</tt> or <tt>/arg.plus arg arg</tt>
	<li>An application is written <tt>M N</tt>, where <tt>M</tt>
	  and <tt>N</tt> are terms</li>
	<li>Terms can be wrapped in parentheses, such
	  as <tt>(/x.x)</tt> or <tt>(ident1 (/y.y))</tt>.
	</li>
      </ul>
    </p>

    <p>To simplify a &lambda;-term, I gave you a
    function <tt>simplify</tt> that repeatedly simplifies redexes
    until the term reaches a normal form. (If a normal form is not
      reached after a given number of steps, you'll get an error.)</p>

    <pre>
# simplify default_defs "/x.x";;
Term already in normal form
- : string = "/x.x"
# simplify default_defs "(/x.x) z";;
- : string = "z"
# simplify default_defs "(/x.(/y. y y) x) z";;
- : string = "z z"</pre>

    <p>    A variant of <tt>simplify</tt> called <tt>simplify_verbose</tt>
      reports all intermediate &lambda;-terms that arise during a
      simplification. That can be quite helpful for debugging.</p>

    <pre>
# simplify_verbose default_defs "(/x.(/y.y y) x) z";;
   (/x.(/y.y y) x) z
 = (/y.y y) z
 = z z
- : string = "z z"    </pre>

    <p>What about the first argument of <tt>simplify</tt>
      and <tt>simplify_verbose</tt>? Recall that when I presented the
      lambda calculus in class, I started defining &lambda;-terms as abbreviations, for &lambda;-terms such as <tt>true</tt> and <tt>false</tt>, to help
      us when
      writing down more interesting &lambda;-terms. The
      first argument to <tt>simplify</tt>
      and <tt>simplify_verbose</tt> is a sequence of definitions, each
      of the form <i>(name,def)</i> where <i>name</i> is the name of
      the &lambda;-term being defined, and <i>def</i> is the
      definition. For example, here are the definitions
      of <tt>true</tt> and <tt>false</tt>:
    </p>

    <pre>
    ("true", "/x./y.x")
    ("false", "/x./y.y")    </pre>

    <p>To make your life easier, I've provided you with
    a <tt>default_defs</tt> set of definitions that pretty much
    defines everything we did in class, including natural number
      arithmetic, complete with a predecessor function</p>

<pre>
let default_defs = [ ("true","/x./y.x");
		     ("false","/x./y.y");
		     ("if","/c./x./y.c x y");
		     ("and","/b./c.b c false");
		     ("or","/b./c.b true c");
		     ("not","/b.b false true");
		     ("_0","/f./x.x");
		     ("_1","/f./x.(f x)");
		     ("_2","/f./x.(f (f x))");
		     ("_3","/f./x.(f (f (f x)))");
		     ("_4","/f./x.(f (f (f (f x))))");
		     ("_5","/f./x.(f (f (f (f (f x )))))");
		     ("succ","/n./f./x.(n f) (f x)");
		     ("plus","/m./n./f./x.(m f) (n f x)");
		     ("times","/m./n./f./x.m (n f) x");
		     ("iszero","/n.n (/x.false) true");
		     ("pred","/n./f./x.n (/g.(/h.h (g f))) (/u.x) (/u.u)");
		     ("Y","/f.(/x.f (x x)) (/x.f (x x))");
                     ("fact","Y (/fact./n.(iszero n) _1 (times n (fact (pred n))))") ]   </pre>

    <p>You'll note that you have only the first 6 natural numbers defined
      as literals. This means that if you want to use natural number 8 somewhere, for instance, you will either
      have to create it by hand, or use the arithmetic operations:
    </p>

    <pre>
# simplify_verbose default_defs "plus _4 _4";;
   (/m./n./f./x.m f (n f x)) (/f./x.f (f (f (f x)))) (/f./x.f (f (f (f x))))
 = (/n./f./x.(/f./x.f (f (f (f x)))) f (n f x)) (/f./x.f (f (f (f x))))
 = /f./x.(/f./x.f (f (f (f x)))) f ((/f./x.f (f (f (f x)))) f x)
 = /f./x.(/x.f (f (f (f x)))) ((/f./x.f (f (f (f x)))) f x)
 = /f./x.f (f (f (f ((/f./x.f (f (f (f x)))) f x))))
 = /f./x.f (f (f (f ((/x.f (f (f (f x)))) x))))
 = /f./x.f (f (f (f (f (f (f (f x)))))))
- : string = "/f./x.f (f (f (f (f (f (f (f x)))))))"    </pre>

    <p>When you simplify a term, all definitions are expanded out
    before simplification occurs. This means that when you get 
       the simplified &lambda;-term back, it will be expressed in
    terms of the expanded out definitions. Thus, if you want to check
      that the number 8 you create above is zero or not, you'll get
      the resulting <tt>false</tt> in terms of how it is defined:</p>

    <pre>
# simplify_verbose default_defs "iszero (plus _4 _4)";;
   (/n.n (/x./x./y.y) (/x./y.x)) ((/m./n./f./x.m f (n f x)) (/f./x.f (f (f (f x)))) (/f./x.f (f (f (f x)))))
 = (/m./n./f./x.m f (n f x)) (/f./x.f (f (f (f x)))) (/f./x.f (f (f (f x)))) (/x./x./y.y) (/x./y.x)
 = (/n./f./x.(/f./x.f (f (f (f x)))) f (n f x)) (/f./x.f (f (f (f x)))) (/x./x./y.y) (/x./y.x)
 = (/f./x.(/f./x.f (f (f (f x)))) f ((/f./x.f (f (f (f x)))) f x)) (/x./x./y.y) (/x./y.x)
 = (/x.(/f./x.f (f (f (f x)))) (/x./x./y.y) ((/f./x.f (f (f (f x)))) (/x./x./y.y) x)) (/x./y.x)
 = (/f./x.f (f (f (f x)))) (/x./x./y.y) ((/f./x.f (f (f (f x)))) (/x./x./y.y) (/x./y.x))
 = (/x.(/x./x./y.y) ((/x./x./y.y) ((/x./x./y.y) ((/x./x./y.y) x)))) ((/f./x.f (f (f (f x)))) (/x./x./y.y) (/x./y.x))
 = (/x./x./y.y) ((/x./x./y.y) ((/x./x./y.y) ((/x./x./y.y) ((/f./x.f (f (f (f x)))) (/x./x./y.y) (/x./y.x)))))
 = /x./y.y
- : string = "/x./y.y"    </pre>

    <p>Don't worry, by the time you're done with this homework, your brain will be rewired so that you'll read <tt>/x./y.y</tt> as <tt>false</tt> and <tt>/x./y.x</tt> as <tt>true</tt>. You're welcome.</p> 


    <p>A tricky point about definitions: every definition in the list of
    definitions can only refer to previously defined terms. This means two things. First, that you can't write recursive definitions.
      If you want recursion, you need to use the <tt>Y</tt> combinator &mdash; see <tt>fact</tt> in the default definitions for an example. It also means that the order
    of definitions is important, just like in OCaml. What's tricky is that
    if you mess it up, the simplification process will not complain. An undefined identifier
    is just that, an identifier, and it is passed around as an identifier. This makes debugging
      somewhat painful. For instance, suppose you mess up the <tt>plus</tt> in the previous example:</p>

    <pre>
# simplify_verbose default_defs "iszero (pluss _4 _4)";;
   (/n.n (/x./x./y.y) (/x./y.x)) (pluss (/f./x.f (f (f (f x)))) (/f./x.f (f (f (f x)))))
 = pluss (/f./x.f (f (f (f x)))) (/f./x.f (f (f (f x)))) (/x./x./y.y) (/x./y.x)
- : string = "pluss (/f./x.f (f (f (f x)))) (/f./x.f (f (f (f x)))) (/x./x./y.y) (/x./y.x)"    </pre>

    <p>Yeah, that's not great. The clue that something went wrong is the <tt>pluss</tt> there at the beginning.</p>

    <p>You can of course create your own definitions that you can pass to <tt>simplify</tt> or <tt>simplify_verbose</tt>. For instance, you can define <tt>_8</tt> and use it:</p>

    <pre>
# simplify_verbose (default_defs @ [("_8","plus _4 _4")]) "iszero _8";;
   (/n.n (/x./x./y.y) (/x./y.x)) ((/m./n./f./x.m f (n f x)) (/f./x.f (f (f (f x)))) (/f./x.f (f (f (f x)))))
 = (/m./n./f./x.m f (n f x)) (/f./x.f (f (f (f x)))) (/f./x.f (f (f (f x)))) (/x./x./y.y) (/x./y.x)
 = (/n./f./x.(/f./x.f (f (f (f x)))) f (n f x)) (/f./x.f (f (f (f x)))) (/x./x./y.y) (/x./y.x)
 = (/f./x.(/f./x.f (f (f (f x)))) f ((/f./x.f (f (f (f x)))) f x)) (/x./x./y.y) (/x./y.x)
 = (/x.(/f./x.f (f (f (f x)))) (/x./x./y.y) ((/f./x.f (f (f (f x)))) (/x./x./y.y) x)) (/x./y.x)
 = (/f./x.f (f (f (f x)))) (/x./x./y.y) ((/f./x.f (f (f (f x)))) (/x./x./y.y) (/x./y.x))
 = (/x.(/x./x./y.y) ((/x./x./y.y) ((/x./x./y.y) ((/x./x./y.y) x)))) ((/f./x.f (f (f (f x)))) (/x./x./y.y) (/x./y.x))
 = (/x./x./y.y) ((/x./x./y.y) ((/x./x./y.y) ((/x./x./y.y) ((/f./x.f (f (f (f x)))) (/x./x./y.y) (/x./y.x)))))
 = /x./y.y
- : string = "/x./y.y"    </pre>

    <p>In fact, all the questions below ask you to create
    definitions. For each question, you should put all your
    definitions into list of definitions that is self-contained,
    meaning that I can pass it (and only it) to <tt>simplify</tt> to test your
    definitions. In practice, this means that these definitions will
    extend the default definitions. Feel free to add definitions for helper functions if you need them. 

    <hr>
    
    <ol class="number">

      <!-- -----------------------------------------------------------
      -->
      <li> <p><b>Warm Up</b></p>

	<p><i>This question asks you to create definitions of
	&lambda;-terms with a given name. There are already
	placeholders for those definitions that you should replace
	with your own. Remember that each definition is a name and a
	&lambda;-term. All these definitions are automatically added to a list of
	definitions <tt>q1_defs</tt>, which is what I'll be
	    testing. Any supporting definitions you need must go in <tt>q1_defs</tt>. </i></p>

	<ol class="letter">

<!--
	  <li> <p>Code a function <tt class="code">???</tt> of
	      type <tt class="code">???</tt> which...
	    </p>

<pre class="code">
</pre>
	  </li>
-->

          <li><p>Code a &lambda;-term with name <tt class="code">minus</tt> which
              takes two natural numbers <i>m</i> and <i>n</i> as arguments
              (like <tt>plus</tt>) and returns the natural
              number <i>m - n</i>. If <i>m - n &lt 0</i>, <tt>minus</tt>
              should return 0. All natural numbers should be in the
              usual Church encoding given in class.
	    </p>

	    <pre class="code">
# simplify q1_defs "minus _0 _0";;
- : string = "/f./x.x"
# simplify q1_defs "minus _1 _1";;
- : string = "/f./x.x"
# simplify q1_defs "minus _2 _1";;
- : string = "/f./x.f x"
# simplify q1_defs "minus _3 _1";;
- : string = "/f./x.f (f x)"
# simplify q1_defs "minus _3 _2";;
- : string = "/f./x.f x"
# simplify q1_defs "minus _2 _3";;
- : string = "/f./x.x"	    </pre>

	    <p><b>Turns out this one is a bit tricky, which is pretty
	    unfair. So let me give you the solution. It
	    is possible to write <tt>minus</tt> recursively, but that
	    will make many of the other functions that might depend
	    on <tt>minus</tt> run very slowly. A simpler solution is
	    obtained by noticing that <i>m - n </i> is the same as
	    applying <tt>pred</tt> <i>n</i> times to <i>m</i>. And the
		encoding of <i>n</i> basically lets you apply a
		function <i>n</i> times. So the simplest definition
		of <tt>minus</tt> is:
		<pre>
		   /m./n.n pred m		</pre>
		As I said, tricky. Sorry about that.
	    </b></p>

	  </li>

          <li><p>Code a &lambda;-term with name <tt class="code">geq</tt> which
              takes two natural numbers <i>m</i> and <i>n</i> as
              arguments (like <tt>plus</tt>) and returns <tt>true</tt>
              if <i>m &geq; n</i> and <tt>false</tt> otherwise. All
              Booleans and natural numbers should be in the
              usual Church encoding given in class.
	    </p>

	    <pre class="code">
# simplify q1_defs "geq _0 _0";;
- : string = "/x./y.x"
# simplify q1_defs "geq _1 _0";;
- : string = "/x./y.x"
# simplify q1_defs "geq _3 _1";;
- : string = "/x./y.x"
# simplify q1_defs "geq _1 _3";;
- : string = "/x./y.y"
# simplify q1_defs "geq _1 (plus _1 _1)";;
- : string = "/x./y.y"	  </pre>
	  </li>

          <li><p>Code a &lambda;-term with name <tt class="code">eq</tt> which
              takes two natural numbers <i>m</i> and <i>n</i> as
              arguments (like <tt>plus</tt>) and returns <tt>true</tt>
              if <i>m = n</i> and <tt>false</tt> otherwise. All
              Booleans and natural numbers should be in the
              usual Church encoding given in class.
	    </p>

	    <pre class="code">
# simplify q1_defs "eq _0 _0";;
- : string = "/x./y.x"
# simplify q1_defs "eq _0 _1";;
- : string = "/x./y.y"
# simplify q1_defs "eq _0 _2";;
- : string = "/x./y.y"
# simplify q1_defs "eq _1 _2";;
- : string = "/x./y.y"
# simplify q1_defs "eq _2 _2";;
- : string = "/x./y.x"
# simplify q1_defs "eq _3 _2";;
- : string = "/x./y.y"
# simplify q1_defs "eq _3 _3";;
- : string = "/x./y.x"    </pre>
	  </li>


	  <li><p>Let's encode pairs. Pairs are ways of packaging two
	  values together in such a way that we can recover the two
	      values later. The easiest way to encode a
	  pair <i>(x,y)</i> is to
	      represent it with a function that when given a
	      function <i>f</i> calls <i>f</i> with both <i>x</i>
	      and <i>y</i>. </p>

	    <p>Code a &lambda;-term <tt class="code">pair</tt> which
	      takes two arguments <i>x</i> and <i>y</i> (like <tt>plus</tt>) and returns a
	      &lambda;-term that represents the pair <i>(x,y)</i>. </p>

	    <p>To go
	      with <tt>pair</tt>, code a
	      &lambda;-term <tt class="code">match_pair</tt> which
	      takes a pair representing <i>(x,y)</i> and a
	      function <i>f</i> of
	      two arguments and calls <i>f</i> with <i>x</i>
	      and <i>y</i>. </p>

	    <p>(Very roughly speaking, <tt>match_pair p (/x./y.M)</tt>
	      behaves like <tt>match p with (x,y) -> M</tt> in OCaml.)</p>

	    <p>Your functions should satisfy the following
	      property: <tt>match_pair (pair a b) f</tt> = <tt>f a
		b</tt>. </p>

	    <pre class="code">
# simplify q1_defs "match_pair (pair x y) f";;
- : string = "f x y"
# simplify q1_defs "match_pair (pair _1 _2) plus";;
- : string = "/f./x.f (f (f x))"
# simplify q1_defs "match_pair (pair true false) or";;
- : string = "/x./y.x"
# simplify q1_defs "match_pair (pair true false) and";;
- : string = "/x./y.y"
# simplify q1_defs "(/p.match_pair p (/x./y.times (succ x) (succ y))) (pair _1 _2)";;
- : string = "/f./x.f (f (f (f (f (f x)))))"
# simplify q1_defs "(/p.match_pair p (/x./y.eq y (succ x))) (pair _1 _2)";;
- : string = "/x./y.x"
# simplify q1_defs "(/p.match_pair p (/x./y.eq y (succ x))) (pair _1 _3)";;
- : string = "/x./y.y"	    </pre>

	  </li>

	  <li>
	    <p>Code two &lambda;-terms <tt class="code">fst</tt> and
	      <tt class="code">snd</tt> which both take a pair and
	      respectively return the first and the second element of
	      the pair.
	    </p>

	    <pre class="code">
# simplify q1_defs "fst (pair a b)";;
- : string = "a"
# simplify q1_defs "snd (pair a b)";;
- : string = "b"
# simplify q1_defs "fst (pair _3 (plus _1 _1))";;
- : string = "/f./x.f (f (f x))"
# simplify q1_defs "snd (pair _3 (plus _1 _1))";;
- : string = "/f./x.f (f x)"	    </pre>	    
	  </li>

	  <li>
	    <p>Code two &lambda;-terms <tt class="code">update_fst</tt> and
	      <tt class="code">update_snd</tt> which both take a pair
	      and a value <i>v</i> and 
	      return the pair where the first (respectively, 
	      second) component has been changed to <i>v</i>
	    </p>

	    <pre class="code">
# simplify q1_defs "fst (update_fst (pair a b) c)";;
- : string = "c"
# simplify q1_defs "snd (update_fst (pair a b) c)";;
- : string = "b"
# simplify q1_defs "fst (update_snd (pair a b) c)";;
- : string = "a"
# simplify q1_defs "snd (update_snd (pair a b) c)";;
- : string = "c"	    </pre>	    
	  </li>	  

	</ol>

      </li>


      <!-- ----------------------------------------------------------- -->
      <li> <p><b>Integers</b></p>

	<p><i>This question asks you to create definitions of
	&lambda;-terms with a given name. There are already
	placeholders for those definitions that you should replace
	with your own. Remember that each definition is a name and a
	&lambda;-term. All these definitions are automatically added to a list of
	definitions <tt>q2_defs</tt>, which is what I'll be
	    testing. Any supporting definitions you need must go in <tt>q2_defs</tt>.</i></p>

	<p>We saw in class an encoding of natural numbers
	  0,1,2,3,... In this question, we consider an encoding of
	  intergers, ...,-3,-2,-1,0,1,2,3,... </p>

	<p>The encoding is dead simple. An integer is a pair of a
	sign and a natural number. The sign will be represented by a
	  Boolean value: <tt>true</tt> for positive integers,
	  and <tt>false</tt> for negative integers. Thus,
	  <i>(true,3)</i> is the representation of integer 3,
	  and <i>(false,2)</i> the representation of integer
	  -2. Integer 0 is always represented as (true,0).</p>

	<p>The functions you developed in Question 1 might come in
	  handy. Feel free to add them to <tt>q2_defs</tt> if you need to.</p>

	<ol class="letter">

	  <li>
	    <p>Code a &lambda;-term <tt class="code">int</tt> which
	      takes a natural number <i>n</i> and returns a (positive) integer
	      <i>n</i> in the encoding described above. 
	    </p>


	    <pre class="code">
# simplify q2_defs "fst (int _0)";;
- : string = "/x./y.x"
# simplify q2_defs "fst (int _1)";;
- : string = "/x./y.x"
# simplify q2_defs "fst (int _2)";;
- : string = "/x./y.x"
# simplify q2_defs "snd (int _0)";;
- : string = "/f./x.x"
# simplify q2_defs "snd (int _1)";;
- : string = "/f./x.f x"
# simplify q2_defs "snd (int _2)";;
- : string = "/f./x.f (f x)"	  </pre>

	  </li>	  
	  
	  <li>
	    <p>Code a &lambda;-term <tt class="code">neg_int</tt> which
	      takes an integer <i>n</i> in the encoding described
	      above, and returns its negation. Recall that the negation of 2 is
	      -2, and the negation of -3 is 3. 
	    </p>

	    <pre class="code">
# simplify q2_defs "fst (neg_int (int _3))";;
- : string = "/x./y.y"
# simplify q2_defs "snd (neg_int (int _3))";;
- : string = "/f./x.f (f (f x))"
# simplify q2_defs "fst (neg_int (neg_int (int _3)))";;
- : string = "/x./y.x"
# simplify q2_defs "snd (neg_int (neg_int (int _3)))";;
- : string = "/f./x.f (f (f x))"	  </pre>

	  </li>	  



	  <li>
	    <p>Code a &lambda;-term <tt class="code">plus_int</tt> which
	      takes two integers <i>m</i> and <i>n</i> in the encoding
	      described above and returns integer <i>m+n</i>. 
	    </p>


	    <pre class="code">
# simplify q2_defs "fst (plus_int (int _3) (int _2))";;
- : string = "/x./y.x"
# simplify q2_defs "snd (plus_int (int _3) (int _2))";;
- : string = "/f./x.f (f (f (f (f x))))"
# simplify q2_defs "fst (plus_int (int _3) (neg_int (int _2)))";;
- : string = "/x./y.x"
# simplify q2_defs "snd (plus_int (int _3) (neg_int (int _2)))";;
- : string = "/f./x.f x"
# simplify q2_defs "fst (plus_int (neg_int (int _3)) (int _2))";;
- : string = "/x./y.y"
# simplify q2_defs "snd (plus_int (neg_int (int _3)) (int _2))";;
- : string = "/f./x.f x"
# simplify q2_defs "fst (plus_int (neg_int (int _3)) (neg_int (int _2)))";;
- : string = "/x./y.y"
# simplify q2_defs "snd (plus_int (neg_int (int _3)) (neg_int (int _2)))";;
- : string = "/f./x.f (f (f (f (f x))))"	  </pre>

	  </li>	  


	  <li>
	    <p>Code a &lambda;-term <tt class="code">times_int</tt> which
	      takes two integers <i>m</i> and <i>n</i> in the encoding
	      described above and returns integer <i>m &times; n</i>. 
	    </p>


	    <pre class="code">
# simplify q2_defs "fst (times_int (int _3) (int _2))";;
- : string = "/x./y.x"
# simplify q2_defs "snd (times_int (int _3) (int _2))";;
- : string = "/f./x.f (f (f (f (f (f x)))))"
# simplify q2_defs "fst (times_int (int _3) (neg_int (int _2)))";;
- : string = "/x./y.y"
# simplify q2_defs "snd (times_int (int _3) (neg_int (int _2)))";;
- : string = "/f./x.f (f (f (f (f (f x)))))"
# simplify q2_defs "fst (times_int (neg_int (int _3)) (int _2))";;
- : string = "/x./y.y"
# simplify q2_defs "snd (times_int (neg_int (int _3)) (int _2))";;
- : string = "/f./x.f (f (f (f (f (f x)))))"
# simplify q2_defs "fst (times_int (neg_int (int _3)) (neg_int (int _2)))";;
- : string = "/x./y.x"
# simplify q2_defs "snd (times_int (neg_int (int _3)) (neg_int (int _2)))";;
- : string = "/f./x.f (f (f (f (f (f x)))))"	  </pre>

	  </li>	  


	</ol>

      </li>


      <!-- ----------------------------------------------------------- -->
      <li> <p><b>Lists</b></p>

	<p><i>This question asks you to create definitions of
	&lambda;-terms with a given name. There are already
	placeholders for those definitions that you should replace
	with your own. Remember that each definition is a name and a
	&lambda;-term. All these definitions are automatically added to a list of
	definitions <tt>q3_defs</tt>, which is what I'll be
	    testing. Any supporting definitions you need must go in <tt>q3_defs</tt>.</i></p>


	<ol class="letter">

	  <li><p>Let's encode lists. The encoding is a variant of that 
	      for pairs, with a twist. A pair was encoded as a
	  function that took a function <i>f</i> as an argument and
	  passed its two components to <i>f</i>. For lists, the twist
	      is that there are two kinds of lists that need to
	be handled differently: empty lists, and non-empty
	lists. Therefore, a list will be encoded differently if it is
	      an empty list or a non-empty list. But each of the
	      encodings is a function that takes <i>two</i> arguments
	      <i>a</i> and <i>f</i>. The encoding for an
	      empty list simply returns <i>a</i>. The encoding for a
	      non-empty list with head <i>h</i> and tail <i>t</i>
	      calls <i>f</i> with <i>h</i> and <i>t</i>. </p>

	    <p>Code a &lambda;-term <tt class="code">empty</tt> which
	      represents the empty list.</p>

	    <p>Code a &lambda;-term <tt class="code">cons</tt> which
	    takes two arguments <i>h</i> and <i>t</i>
	    (like <tt>plus</tt>) and returns the encoding of a list
	      with first element <i>h</i> followed by
	      elements <i>t</i>. Intuitively, <tt>cons h t</tt> plays
	      the role of <tt>h::t</tt> in OCaml.

	    <p>To go
	      with <tt>empty</tt> and <tt>cons</tt>, code a
	      &lambda;-term <tt class="code">match_list</tt> which
	      takes a list <i>L</i> and two other arguments <i>a</i>
	      and <i>f</i> and returns <i>a</i> if <i>L</i> is the
	      empty list otherwise calls <i>f</i> with the head
	      of <i>L</i> and the tail of <i>L</i> as arguments.</p>

	    <p>(Very roughly speaking, <tt>match_list lst a (/h./t.M)</tt>
	      behaves like <tt>match lst with [] -> a | h::t -> M</tt> in OCaml.)</p>

	    <p>Your functions should satisfy the following
	      property: <tt>match_list empty a f</tt> = <tt>a</tt>
	      and <tt>match_list (cons h t) a f</tt> = <tt>f h t</tt>. </p>

	    <pre class="code">
# simplify q3_defs "match_list empty a f";;
- : string = "a"
# simplify q3_defs "match_list (cons h t) a f";;
- : string = "f h t"
# simplify q3_defs "match_list (cons A empty) a (/h./t.h)";;
- : string = "A"
# simplify q3_defs "match_list (cons A (cons B empty)) a (/h./t.h)";;
- : string = "A"
# simplify q3_defs "match_list (cons A (cons B empty)) a (/h./t.match_list t a (/h./t.h))";;
- : string = "B"	    </pre>

	  </li>



	  <li>
	    <p>Code a &lambda;-term <tt class="code">length</tt> which
	      takes a list in the encoding described above and returns
	      a natural number representing its length. 
	    </p>

	    <pre class="code">
# simplify q3_defs "length empty";;
- : string = "/f./x.x"
# simplify q3_defs "length (cons A empty)";;
- : string = "/f./x.f x"
# simplify q3_defs "length (cons A (cons B empty))";;
- : string = "/f./x.f (f x)"
# simplify q3_defs "length (cons A (cons B (cons C empty)))";;
- : string = "/f./x.f (f (f x))"	  </pre>

	  </li>	  


	  <li>
	    <p>Code a &lambda;-term <tt class="code">sum</tt> which
	      takes a list of natural numbers in the encoding described above and returns
	      a natural number representing the sum of its elements.
	    </p>

	    <pre class="code">
# simplify q3_defs "sum empty";;
- : string = "/f./x.x"
# simplify q3_defs "sum (cons _1 empty)";;
- : string = "/f./x.f x"
# simplify q3_defs "sum (cons _1 (cons _3 empty))";;
- : string = "/f./x.f (f (f (f x)))"
# simplify q3_defs "sum (cons _1 (cons _3 (cons _5 empty)))";;
- : string = "/f./x.f (f (f (f (f (f (f (f (f x))))))))"	  </pre>

	  </li>	  


	  <li>
	    <p>Code a &lambda;-term <tt class="code">append</tt> which
	      takes two lists <i>L1</i> and <i>L2</i> in the encoding described above
	      (like <tt>plus</tt>) and returns the list made up of all
	      the elements of <i>L1</i> followed by all the elements
	      of <i>L2</i>. 
	    </p>

	    <pre class="code">
# simplify q3_defs "length (append empty empty)";;
- : string = "/f./x.x"
# simplify q3_defs "length (append empty (cons A (cons B empty)))";;
- : string = "/f./x.f (f x)"
# simplify q3_defs "length (append (cons C (cons D (cons E empty))) (cons A (cons B empty)))";;
- : string = "/f./x.f (f (f (f (f x))))"
# simplify q3_defs "sum (append empty empty)";;
- : string = "/f./x.x"
# simplify q3_defs "sum (append empty (cons _1 (cons _2 empty)))";;
- : string = "/f./x.f (f (f x))"
# simplify q3_defs "sum (append (cons _3 (cons _4 (cons _5 empty))) (cons _1 (cons _2 empty)))";;
- : string =
"/f./x.f (f (f (f (f (f (f (f (f (f (f (f (f (f (f x))))))))))))))"	  </pre>

	  </li>	  


	  <li>
	    <p>Code a &lambda;-term <tt class="code">map</tt> which
	      takes a function <i>f</i> and a list <i>L</i> in the
	      encoding described above and returns the list obtained
	      by applying function <i>f</i> to every element of <i>L</i>. 
	    </p>

	    <pre class="code">
# simplify q3_defs "length (map (/x.plus x x) empty)";;
- : string = "/f./x.x"
# simplify q3_defs "length (map (/x.plus x x) (cons _1 (cons _2 (cons _3 empty))))";;
- : string = "/f./x.f (f (f x))"
# simplify q3_defs "sum (map (/x.plus x x) (cons _1 (cons _2 (cons _3 empty))))";;
- : string = "/f./x.f (f (f (f (f (f (f (f (f (f (f (f x)))))))))))"
# simplify q3_defs "match_list (map (/x.plus x x) (cons _1 (cons _2 (cons _3 empty)))) X (/h./t.h)";;
- : string = "/f./x.f (f x)"	  </pre>

	  </li>	  


	</ol>
	
      </li>

    </ol>

  </body>
</html>

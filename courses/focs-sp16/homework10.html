<!DOCTYPE html>
<html>

  <head>
    
    <meta charset="utf-8">
    <title>Homework 10</title>

    <link rel="stylesheet" href="alt.css" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,800,700' rel='stylesheet' type='text/css'>

    <script src="autoscroll.js"></script>
    
    <style>

      hr { margin-top: 50px; }

        code,tt,pre {
          font-size: 140%;
        }
	
        div.lect {
	  padding-top: 0;
       	  padding-left: 3em;
	  margin-top:0;
        }
    	p.ann { 
    	  padding-left: 3em;
    	  text-indent: -3em; 
    	}
	p.ann_ctd{
	  padding-left: 3em;
        }
    	span.hdr {
   	  padding-right: 1em
    	}

	.hidden {
	  visibility: hidden;
        }

        tt.code {
           background: #e6e6e6;
        }

	pre.code {
	   border: 1px solid #c6c6c6;
	border-radius: 5px;
	padding: 10px;
	font-size:100%;
	}

/* from
    http://www.456bereastreet.com/archive/201105/styling_ordered_list_numbers/
 */

ol {
    counter-reset:li; /* Initiate a counter */
    margin-left:0; /* Remove the default left margin */
    padding-left:0; /* Remove the default left padding */
    padding-top:1em;
}
ol > li {
    position:relative; /* Create a positioning context */
    margin:0 0 6px 2em; /* Give each list item a left margin to make
    room for the numbers */
    padding:4px 8px; /* Add some spacing around the content */
    list-style:none; /* Disable the normal item numbering */
    /*border-top:2px solid #666;
    background:#f6f6f6; */
}
ol > li:before {
    counter-increment:li; /* Increment the counter by 1 */
    /* Position and style the number */
    position:absolute;
    top:-2px;
    left:-2em;
    -moz-box-sizing:border-box;
    -webkit-box-sizing:border-box;
    box-sizing:border-box;
    width:2em;
    /* Some space between the number and the content in browsers that
    support
       generated content but not positioning it (Camino 2 is one
    example) */
    margin-right:8px;
    padding:4px;
/*    border-top:2px solid #666;
    color:#fff;
    background:#666; 
    font-weight:bold; */
/*    font-family:"Helvetica Neue", Arial, sans-serif;
    text-align:center; */
}

ol.letter > li:before {
    content:"(" counter(li,lower-alpha) ")"; /* Use the counter as content */
}

ol.number > li:before {
    content:"(" counter(li,decimal) ")"; /* Use the counter as content */
}

li ol,
li ul {margin-top:6px;}

li > p { margin-top:0;}

    </style>

  </head>


  <body>

    <div class="navbar">

      <div class="home">
	<a href="../../index.html"><img src="../../home.png" style="height: 1.6em;"></a>
      </div>

      <ul>
	<li><a href="index.html"><b>Foundations of Computer Science SP16</b></a></li> 
	<li class="hidden"><a class="scrollto" href="#announcements">Announcements</a></li>
	<li class="hidden"><a class="scrollto" href="#info">Course Info</a></li>
	<li class="hidden"><a class="scrollto" href="#lectures">Lectures</a></li>
	<li class="hidden"><a class="scrollto" href="#homeworks">Homeworks</a></li>
      </ul>
    </div>


    <!-- padding -->
    <div id="top" style="height: 7em;"></div>
    
    <h1 class="clear">Homework 10</h1>
    
    <p class="subtitle">Due date: Friday, April 29 (midnight)</p>

    <p><b>Note on integrity:</b> This homework is meant to be done
    individually. You may discuss problems with fellow students, but
    all work must be entirely your own, and should not be from any
    other course, present, past, or future. If you use a solution from
    another source you must cite it &mdash; this includes when that source
      is someone else helping you.</p>

    <p>Every source file you submit should begin with a block comment
      that lists your <span style="text-decoration:underline;">name</span>, your <span style="text-decoration:underline;">email address</span>, and any <span style="text-decoration:underline;">remarks</span> that you
      wish to make to the instructor.</p>

    <p>All programming is to be done in OCaml v4.</p>

    <p>Feel free to define helper functions if you need them.</p>

    <p>Please code your answers by modifying the
      file <a href="homework10.ml"><tt>homework10.ml</tt></a> provided.</p>

    <p>Electronic submission instructions:</p>

    <ul>
      <li>Download the file <a href="hw10-checker.ml"><tt>hw10-checker.ml</tt></a> into the same directory as your homework solution.</li>
      <li>Start a <i>new</i> OCaml shell.</li>
      <li>Load your homework code via <tt>#use "homework10.ml";;</tt></li>
      <li>Load the homework checker via <tt>#use "hw10-checker.ml";;</tt></li>
      <li>The homework checker checks that you've implemented all functions (or provided stubs for them) and that those functions have the type that I asked you to give them. If the checker says your types are OK, then you're fine. If the checker gives you an error, fix it. If you believe that the checker gives you an error wrongly, send me an email.</li>
      <li>When you're ready to submit, send an email with your file <tt>homework10.ml</tt> as an attachment to <tt>focs.sp16@gmail.com</tt> with subject <i>Homework 10 submission</i>.</li>
    </ul>

    <p>If your code fails because you did not follow the instructions above (in particular, because your code fails to type check when put in presence of my automated testing rig) I'll be unhappy.</p>


    <hr>


    
    <ol class="number">

      <li> <p><b>Binary Trees</b></p>

	<p>A <i>binary tree</i> is a tree in which every node has at most
  two children (a left child and a right child). A binary tree may be
  empty. We will consider binary trees in which every node stores a
  value:</p> 
	
	<p><img src="bintree.png"></p>

      
<p>
  Here is an OCaml type for binary trees that can store values of
  type <tt>'a</tt> at the nodes:
</p>
<pre>
type 'a bintree = 
  | Empty
  | Node of 'a * 'a bintree * 'a bintree
</pre>

<p>
The sample tree above can be constructed using
<pre>
let sample = 
  Node (10, Node (3, Node (7, Empty, Empty),
                     Node (5, Empty, Empty)),
            Node (6, Node (99, Empty, 
                               Node (66, Empty, Empty)),
                     Empty))
</pre>
<p>
  A function <tt>pbt</tt> (for <i>print binary tree</i>) has been provided to
  print an <i>integer</i> binary tree. (If you have other kinds of
  binary trees, then you're going to have to define your own printing
  function.)
</p>
<pre>
# pbt sample;;
    6
            66
        99
10
        5
    3
        7
- : unit = ()
</pre>
<p>It will probably take you a bit of time before you can read this
  output easily, but it's basically the tree rotate counter-clockwise
  90 degrees: the root is on the left (10), and the tree grows down to the
  right. Create a few trees, and print them out to see what they look
  like. </p>

<p>Function over trees, just like functions over lists, are naturally
  recursive. That follows directly from the recursive nature of trees.
</p>

	<ol class="letter">

	  <li> <p>Code functions <tt class="code">size</tt>
	      and <tt class="code">height</tt> of
	      type <tt class="code">'a bintree -> int</tt>
	      and a function <tt class="code">sum</tt> of type 
	      <tt class="code">int bintree -> int</tt> that
	      respectively return the
	      number of nodes, the height, and the sum of the values
	      at the nodes in a binary tree.
	    </p>

<pre class="code">
# size Empty;;
- : int = 0
# size (Node(1,Empty,Empty));;
- : int = 1
# size sample;;
- : int = 7
# height Empty;;
- : int = 0
# height (Node(1,Empty,Empty));;
- : int = 1
# height sample;;
- : int = 4
# sum Empty;;
- : int = 0
# sum (Node(1,Empty,Empty));;
- : int = 1
# sum sample;;
- : int = 196</pre>
	  </li>


	  <li>
	    <p>The <i>fringe</i> of a tree is the list of all the leaves of
	      the tree (all the nodes that have no subtrees), from
	      left to right.</p>

	    <p>
	      Code a function <tt class="code">fringe</tt> of
	      type <tt class="code">'a bintree -> 'a list</tt> that
	      returns the fringe of a tree.
	    </p>

<pre class="code">
# fringe Empty;;
- : 'a list = []
# fringe (Node(1,Empty,Empty));;
- : int list = [1]
# fringe (Node(1,Node(2,Empty,Empty),Node(3,Empty,Empty)));;
- : int list = [2; 3]
# fringe sample;;
- : int list = [7; 5; 66]</pre>
	  </li>

	  <li> 
	    <p>Code a function <tt class="code">map</tt> of
	      type <tt class="code">('a -> 'b) -> 'a bintree -> 'b
		bintree</tt> where <tt>map f t</tt> returns a new tree
	      with the same shape as <tt>t</tt> but where the value of
	      every node has been transformed via function <tt>f</tt>.
	    </p>

<pre class="code">
# map (fun x -> x * x) Empty;;
- : int bintree = Empty
# map (fun x -> x * x) (Node (2,Empty,Empty));;
- : int bintree = Node (4, Empty, Empty)
# pbt (map (fun x -> x * x) (Node(2,Node(3,Empty,Empty),Node(4,Empty,Empty))));;
    16
4
    9
- : unit = ()
# pbt (map (fun x -> x * x) sample);;
    36
            4356
        9801
100
        25
    9
        49
- : unit = ()</pre>
	  </li>

	  <li> <p>Code a function <tt class="code">fold</tt> of
	      type <tt class="code">('a -> 'b -> 'b -> 'b) -> 'a bintree ->
		'b -> 'b</tt> that does for binary trees
	      what <tt>fold_right</tt> does for lists. In
	      particular, <tt>fold f t b</tt> should apply
	      function <tt>f</tt> to the root of tree <tt>t</tt>, being
	      passed the value at the root and the result of recursively
	      folding each of the left and right subtrees. Folding an
	      empty tree should return value <tt>b</tt>. 
	    </p>

<pre class="code">
# fold (fun v l r -> v+l+r) Empty 0;;
- : int = 0
# fold (fun v l r -> v+l+r) (Node(1,Empty,Empty)) 0;;
- : int = 1
# fold (fun v l r -> v+l+r) (Node(1,Empty,Empty)) 10;;
- : int = 21
# fold (fun v l r -> v+l+r) (Node(1,Node(2,Empty,Empty),Node(3,Empty,Empty))) 0;;
- : int = 6
# fold (fun v l r -> v+l+r) sample 0;;
- : int = 196</pre>

	    <p>A <i>traversal</i> for a tree is a listing of the
	      values in the tree in some specific order. 
	      A <i>preorder</i> traversal lists the value of a node
	      <i>before</i> the values of the nodes of its subtrees; a
	      <i>postorder</i> traversal lists the values of a node
	      after the values of its subtrees; and an <i>inorder</i>
	      traversal lists the value of a node before the values of
	      its right subtree but after the values of its left
	      subtree.</p>

	    <p>Code
	    function <tt class="code">preorder</tt>, <tt class="code">postorder</tt>,
	      and <tt class="code">inorder</tt>, each of
	      type <tt class="code">'a bintree -> 'a list</tt>, which
	    return the list of values in a binary tree according to
	    the given type of traversal. For full marks, implement
	      these functions using <tt>fold</tt>. 

<pre class="code">
# preorder Empty;;
- : 'a list = []
# preorder (Node(1,Empty,Empty));;
- : int list = [1]
# preorder (Node(1,Node(2,Empty,Empty),Node(3,Empty,Empty)));;
- : int list = [1; 2; 3]
# preorder sample;;
- : int list = [10; 3; 7; 5; 6; 99; 66]
# postorder Empty;;
- : 'a list = []
# postorder (Node(1,Empty,Empty));;
- : int list = [1]
# postorder (Node(1,Node(2,Empty,Empty),Node(3,Empty,Empty)));;
- : int list = [2; 3; 1]
# postorder sample;;
- : int list = [7; 5; 3; 66; 99; 6; 10]
# inorder Empty;;
- : 'a list = []
# inorder (Node(1,Empty,Empty));;
- : int list = [1]
# inorder (Node(1,Node(2,Empty,Empty),Node(3,Empty,Empty)));;
- : int list = [2; 1; 3]
# inorder sample;;
- : int list = [7; 3; 5; 10; 99; 66; 6]</pre>

	  </li>


	  <li> <p>A <i>binary search tree</i> is a binary tree with
	      the <i>search tree</i> property: for every subtree S,
	      every node in the left subtree of the root of S has value
	      less than (or equal to) the value of the root of S, and every node in
	      the right subtree of the root of S has value greater
	      than the value of the root of S.</p>

	    <p>Code a function <tt class="code">bst_insert</tt> of
	      type <tt class="code">'a bintree -> 'a -> 'a
		bintree</tt> where <tt>bst_insert t v</tt> returns a
	      new binary search tree obtained by inserting 
	      value <tt>v</tt> into binary search tree <tt>t</tt>.</p>

<pre class="code">
# bst_insert Empty 10;;
- : int bintree = Node (10, Empty, Empty)
# pbt (bst_insert (Node (5,Empty,Empty)) 2);;
5
    2
- : unit = ()
# pbt (bst_insert (Node (5,Empty,Empty)) 8);;
    8
5
- : unit = ()
# pbt (bst_insert (Node (5,Node(2,Empty,Empty),Node(8,Empty,Empty))) 10);;
        10
    8
5
    2
- : unit = ()
# pbt (bst_insert (Node (5,Node(2,Empty,Empty),Node(8,Empty,Empty))) 4);;
    8
5
        4
    2
- : unit = ()
# pbt (bst_insert (Node (5,Node(2,Empty,Empty),Node(8,Empty,Empty))) 1);;
    8
5
    2
        1
- : unit = ()
# pbt (bst_insert (Node (5,Node(2,Empty,Empty),Node(8,Empty,Empty))) 6);;
    8
        6
5
    2
- : unit = ()
</pre>

	    <p>Code a function <tt class="code">bst_lookup</tt> of
	      type <tt class="code">'a bintree -> 'a -> bool</tt>
	      which checks if a value is in a binary search tree. For
	      full marks, your code should take advantage of the
	      search tree property, and not look at every single node
	      of the tree.
	    </p>

<pre class="code">
# bst_lookup Empty 1;;
- : bool = false
# bst_lookup (Node (5,Empty,Empty)) 1;;
- : bool = false
# bst_lookup (Node (5,Empty,Empty)) 5;;
- : bool = true
# bst_lookup (Node (5,Node(2,Empty,Empty),Node(8,Empty,Empty))) 1;;
- : bool = false
# bst_lookup (Node (5,Node(2,Empty,Empty),Node(8,Empty,Empty))) 2;;
- : bool = true
# bst_lookup (Node (5,Node(2,Empty,Empty),Node(8,Empty,Empty))) 8;;
- : bool = true</pre>

	    <p>Code a function <tt class="code">bstify</tt> of type
	      <tt class="code">'a bintree -> 'a bintree</tt> that
	      takes a generic binary tree and returns a
	      binary <i>search</i> tree containing the same
	      nodes. Your resulting
	      tree need not be balanced. 
	    </p>

	    <p>(Note that because there are <i>so</i> many ways of
	    doing this, your results may not match mine below. As long as
	    your result is a binary search tree with the same nodes as
	      the original, it's all good.)</p>

<pre class="code">
# bstify Empty;;
- : 'a bintree = Empty
# bstify (Node(1,Empty,Empty));;
- : int bintree = Node (1, Empty, Empty)
# pbt (bstify (Node(4,Node(7,Empty,Empty),Node(5,Empty,Empty))));;
    7
        5
4
- : unit = ()
# pbt (bstify sample);;
    99
        66
10
        7
                6
            5
    3
- : unit = ()</pre>


	  </li>

	</ol>

      </li>

      <li> <p><b>AVL Trees (BONUS QUESTION) </b></p>

	<p><b>This question is entirely optional. Not doing it will not penalize you</b>. 
	  But if you do do it, I will use it to offset points you have lost on
	  this or another homework. (Up to 5 points.) </p> 

	<p>Remember AVL trees which I described in class and to which I
	      provided pointers on the course web site. An AVL tree
	      is a binary search tree that further satisfies
	      the <i>height balance</i> property: every subtree S is
	      such that the difference in height between its left
	      subtree and its right subtree is at most 1.</p>

	    <p>Code a function <tt class="code">avl_insert</tt> of type
	      <tt class="code">'a bintree -> 'a -> 'a bintree</tt>
	      which takes an AVL tree and a value,
	      and returns a new AVL tree with the value inserted. 
	    </p>

<pre class="code">
# pbt (avl_insert Empty 1);;
1
- : unit = ()
# pbt (avl_insert (avl_insert Empty 1) 2);;
    2
1
- : unit = ()
# pbt (avl_insert (avl_insert (avl_insert Empty 1) 2) 3);;
    3
2
    1
- : unit = ()
# pbt (avl_insert (avl_insert (avl_insert (avl_insert Empty 1) 2) 3) 4);;
        4
    3
2
    1
- : unit = ()
# pbt (avl_insert (avl_insert (avl_insert (avl_insert (avl_insert Empty 1) 2) 3) 4) 5);;
        5
    4
        3
2
    1
- : unit = ()
# pbt (avl_insert (avl_insert (avl_insert (avl_insert (avl_insert (avl_insert Empty 1) 2) 3) 4) 5) 6);;
        6
    5
4
        3
    2
        1
- : unit = ()</pre>

	  </li>


	</ol>

      </li>


    </ol>

  </body>
</html>

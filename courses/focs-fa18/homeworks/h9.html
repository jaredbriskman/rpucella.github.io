<!DOCTYPE html>
<html>

  <head>
    
    <meta charset="utf-8">
    <title>Homework 9</title>

    <link rel="stylesheet" href="../alt.css" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,800,700' rel='stylesheet' type='text/css'>

    <script src="autoscroll.js"></script>
    
    <style>

      hr { margin-top: 50px; }

        code,tt,pre {
          font-size: 110%;
        }
	
        div.lect {
	  padding-top: 0;
       	  padding-left: 3em;
	  margin-top:0;
        }
    	p.ann { 
    	  padding-left: 3em;
    	  text-indent: -3em; 
    	}
	p.ann_ctd{
	  padding-left: 3em;
        }
    	span.hdr {
   	  padding-right: 1em
    	}

	.hidden {
	  visibility: hidden;
        }

        tt.code {
           font-weight: bold;
        }

      div.code {
      border: 1px solid #c6c6c6;
      border-radius: 5px;
      padding: 0px;
      margin-bottom: 20px;
      }
      
      div.code p {
      margin:0px;
      padding:5px 10px;
      background:#eeeeee;
      font-style: italic;
      cursor:pointer;
      }

      div.code p:hover {
      background:#cccccc;
      }

      div.code pre { 
      display:none;
      padding: 10px;
      font-size:100%;
      }

      div.code.visible pre  {
      display:block;
      }

ol.question {
    padding-top:1em;
    list-style-type: decimal;
}

ol.subquestion {
    list-style-type: upper-alpha;
}

      ol.question > li {
      font-weight: bold;
      }

      ol.question > li > * {
      font-weight: normal;
      }
      
ol > li {
    padding:4px 8px; /* Add some spacing around the content */
}

li ol,
li ul {margin-top:6px;}

      li > p { margin-top:0;}


      table.diagram {
      border-collapse: collapse;
      }

      table.diagram td, table.diagram th {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: center;
      }

      table.diagram th {
    text-align: center;
    background-color: #666;
    color: white;
      }

      
    </style>

    <script>
      function toggleShowHide (p) { 
      var div = p.parentNode;
        if (div.className && div.className.startsWith("visible")) {
          div.className = "code";
      } else {
        div.className = "visible code";
      }
      }
    </script>


  </head>


  <body>

    <div class="navbar">

      <div class="home">
	<a href="../../../index.html"><img src="../../../home.png" style="height: 1.6em;"></a>
      </div>

      <ul>
	<li><a href="../index.html"><b>Foundations of Computer Science FA18</b></a></li> 
	<li class="hidden"><a class="scrollto" href="#announcements">Announcements</a></li>
	<li class="hidden"><a class="scrollto" href="#info">Course Info</a></li>
	<li class="hidden"><a class="scrollto" href="#lectures">Lectures</a></li>
	<li class="hidden"><a class="scrollto" href="#homeworks">Homeworks</a></li>
      </ul>
    </div>


    <!-- padding -->
    <div id="top" style="height: 5em;"></div>
    
    <h1 class="clear">Homework 9</h1>
    
    <p class="subtitle">Due date: Friday, November 30 (23h59)</p>

    <ul>
      <li><p>This homework is to be done
    individually. You may discuss problems with fellow students, but
    all submitted work must be entirely your own, and should not be from any
    other course, present, past, or future. If you use a solution from
    another source you must cite it &mdash; this includes when that source
	is someone else helping you.</p></li>
      <li><p><b>Please do not post your solutions on a public website or a public repository like GitHub.</b></p></li>

      <li><p>All programming is to be done in OCaml v4.</p></li>

      <li><p>Code your answers by modifying the
      file <a href="homework9.ml"><tt>homework9.ml</tt></a> provided. Add your
      <span style="text-decoration:underline;">name</span>, your <span style="text-decoration:underline;">email address</span>, and any <span style="text-decoration:underline;">remarks</span> that you
      wish to make to the instructor to the block comment at the head of the file.</p></li>

      <li><p><b>Please do not change the types in the signature of the
	function stubs I provide</b>. Doing so will make it
	impossible to load your code into the testing infrastructure,
	and make me unhappy.</p></li>

      <li><p>Feel free to define helper functions if you need them.</p></li>
    </ul>


    <hr>

    
    <p class="subtitle">Electronic submission instructions:</p>

    <ul>
      <li><p>Start a <i>new</i> OCaml shell.</p></li>
      <li><p>Load your homework code via <tt>#use "homework9.ml";;</tt></p></li>
      <li><p>If there are any error, do not submit. I can't test what I
	can't <tt>#use</tt>.</p></li>
      <li><p>When you're ready to submit, send an email with your file <tt>homework9.ml</tt> as an attachment to <tt>olin.submissions@gmail.com</tt> with subject <i>Homework 9 submission</i>.</p></li>
    </ul>


    <hr>

    <p>We are going to provide ways to construct dataflow networks as we saw in class, but textually. Consider the following primitive components that I described in class:
    </p>
<ul style="list-style: none;">
  <li><p><b>cst</b>: create a constant stream of values</p></li>
  <li><p><b>map</b>: map a function on an input stream to produce an output stream</p></li>
  <li><p><b>map2</b>: map a function over two input streams to produce an
      output stream</p></li>
  <li><p><b>fby</b>: take two input streams and produce an output stream made up
  of the first element of the first input stream followed by all the
      elements of the second input stream</p></li>
  <li><p><b>splitFirst</b>: take an input stream and produce an output stream
  made of the first element of the input stream repeatedly indefinitely, and <b>splitRest</b>: take an input stream and produce  an output stream
      made up of the input stream but starting at its second element. (Note that in class, I presented a single primitive component <i>split</i> that had two outputs &mdash; the above splits (!) that component into two, one per output.)</p></li>
  <li><p><b>filter</b>: take two input streams and produce an output stream by
  taking a pair of element of each stream and keeping the element of
      the second stream if a predicate applied to both elements returns true</p></li>
</ul>

<p>Consider the following dataflow network for computing the infinite
  stream of natural numbers starting from 0: 
</p>

  <center style="padding:20px;"><img src="nats.png"></center>

<p>

  The basic idea is pretty simple: we give a name to every wire in a
  dataflow network, and associate with each wire the primitive
  component that gives the wire its values. In the above diagram,
  there are basically three wires, called <i>a</i>, <i>b</i>,
  and <i>result</i>. Wire <i>a</i> gets its values from the constant
  component that always sends 0, wire <i>b</i> gets its values from
  the map component that adds 1 to its input, and the <i>result</i>
  component gets its values from the followed-by component. Each
  primitive component takes its inputs from wires (except for cst,
  which has no inputs). The followed-by component takes its inputs
  from wires <i>a</i> and <i>b</i>, and the map component takes its
  input from the <i>result</i> wire. (Note that the <i>result</i>
  wire forks into two, but since the same values flow on both forks,
  we give it a single name.)
</p>

<p>
This means that we can represent the above dataflow network using the
following list of wires and components giving values to those wires:
<ul style="list-style: none;">
  <li><i>result</i> = fby <i>a</i> <i>b</i></li>
  <li><i>a</i> = cst 0</li>
  <li><i>b</i> = map (fun x -> x +1) <i>result</i></li>
</ul>
The dataflow network as a whole has no inputs, and its output is
the <i>result</i> wire. In the notation of the homework, it is
constructed using the code:</p>
<pre>
  let nats = network [] "result" [
    ("result", fby "a" "b");
    ("a", cst 0);
    ("b", map (fun x -> x+1) "result")
  ]
</pre>
    <p>The order of the wire definitions does not matter.</p>

    <p>
The primitive components I give you include:
      <ul style="list-style: none;">
	<li><tt>cst : 'a -> 'a primitive</tt></li>
	<li><tt>map : ('a -> 'a) -> string -> 'a primitive</tt> </li>
	<li><tt>map2 : ('a -> 'a -> 'a) -> string -> string -> 'a
	    primitive</tt></li>
	<li><tt>fby : string -> string -> 'a primitive</tt></li>
	<li><tt>splitFirst : string -> 'a primitive</tt></li>
	<li><tt>splitRest : string -> 'a primitive</tt></li>
	<li><tt>filter : ('a -> 'a -> bool) -> string -> string -> 'a primitive</tt></li>
  </ul>
    </p>

</pre>
Function <tt>network</tt> with type <tt>string list -> string ->
  (string * 'a primitive) list -> 'a network</tt> is used to construct
  a network from primitives: the result
  of <tt>network <i>inputs</i> <i>output</i> <i>descr</i></tt> is a
  dataflow network with input wires <tt><i>inputs</i></tt>, output
  wire <tt><i>output</i></tt>, and description <tt><i>descr</i></tt>
  given as a list of pairs of a wire and the primitive component that
  gives it its value.
</p>

<p>Two other primitive exist, to allow you to reuse a network as a
  component inside another network:</p>

<ul style="list-style: none;">
  <li><tt>component : 'a network -> string list -> 'a
  primitive</tt></li>
  <li><tt>rcomponent : string list -> 'a primitive</tt></li>
</ul>

<p>
Primitive <tt>component <i>net</i> <i>args</i></tt> includes
dataflow network <i>net</i> in your network, attaching the wires
supplied as arguments in <i>args</i> to the input wires
of <tt>net</tt>. The output wire of <i>net</i> is the output wire of
the primitive. (Wires with the same name will be considered different in the dataflow network included, and should not clash &mdash; the same way you can use the same local variable names in a helper function that you're calling from another function and they will not clash.)
</p>


    <p>Similarly, primitive <tt>rcomponent <i>args</i></tt> includes
    the current network recursively inside the network, attaching the
      wires supplied as arguments in <i>args</i> to the input wires of
    the network. Again, the output wire of the recursively included
      network is the output wire of the primitive.</p>

<p>By way of example, consider the following super simple dataflow
  network to add two streams of integers, pointwise</p>
<pre>
  let add = network ["input1";"input2"] "result" [
    ("result", map2 (fun x y -> x+y) "input1" "input2")
  ]
</pre>

<p>You can use that component inside the dataflow network to compute
  the partial sums of a streams as we saw in class,
  taking a stream <i>a1 a2 a3 ...</i> and producing <i>a1 (a1+a2)
  (a1+a2+a3) ...</i>. This is the network I drew in class:
</p>

  <center style="padding:20px;"><img src="psums.png"></center>

<p>It can be captured as follows in the above syntax:
<pre>
  let psums = network ["input"] "result" [
    ("result", fby "input" "b");
    ("a", splitRest "input");
    ("b", component add ["a";"result"])
  ]
</pre>
Note the use of <tt>splitRest</tt> to get the "bottom" wire of the split component in the graphical representation. If we wanted the "top" wire, we would use <tt>splitFirst</tt>. 
</p>

<p>As an example of a recursive network, consider the sieve of
  Eratosthenes, again described in class:</p>
<pre>
  let sieve = 
    let notdivides c x = x mod c &lt;> 0  in
    network ["input"] "result" [
      ("top", splitFirst "input");
      ("bot", splitRest "input");
      ("result", fby "top" "rec_sieve");
      ("rec_sieve", rcomponent ["filtered"]);
      ("filtered", filter notdivides "top" "bot");
    ]
</pre>
<p>
Note the recursive use of the network. With <tt>sieve</tt>, you can
define a network to produce the prime numbers:</p>
<pre>
  let primes = network [] "result" [
    ("result", component sieve ["map"]);
    ("map", map (fun x -> x+2) "nats");
    ("nats", component nats [])
  ]
</pre>

    <p>How do you get a dataflow network to compute? For a <i><b>dataflow
	  network with no input streams</b></i>, you can simply use
      function <tt>prefix</tt>:</p>
<ul style="list-style: none;">
  <li><tt>prefix : int -> 'a network -> 'a list</tt></li>
</ul>where <tt>prefix <i>n</i> <i>net</i></tt> takes a number <i>n</i> and
a dataflow network <i>net</i> (having no input streams) and returns
the first <i>n</i> elements produced on the output wire
of <i>net</i>. Thus, for example:</p>
<pre>
# prefix 20 nats;;
- : int list =
[0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19]
# prefix 20 primes;;
- : int list =
[2; 3; 5; 7; 11; 13; 17; 19; 23; 29; 31; 37; 41; 43; 47; 53; 59; 61; 67; 71]
</pre>
<p>Another useful testing function is <tt>nth</tt>:</p>
<ul style="list-style: none;">
  <li><tt>nth : int -> 'a network -> 'a</tt></li>
</ul>where <tt>nth <i>n</i> <i>net</i></tt> takes a number <i>n</i> and
a dataflow network <i>net</i> (having no input streams) and returns
the <i>n</i><sup>th</sup> element of the stream produced on the output wire
of <i>net</i>. Thus, for example:</p>
<pre>
# nth 0 nats;;
- : int = 0
# nth 100 nats;;
- : int = 100
# nth 1000 nats;;
- : int = 1000
# nth 0 primes;;
- : int = 2
# nth 100 primes;;
- : int = 547
# nth 1000 primes;;
- : int = 7927
</pre>

<p>
What about networks that expect one or more input streams? We can't
apply <tt>prefix</tt> directly. What we can do is supply streams to
the input wires of the network. Function <tt>apply</tt> is provided for that purpose:
<ul style="list-style: none;">
  <li><tt>apply : 'a network -> 'a network list -> 'a network</tt></li>
</ul>
where <tt>apply <i>net</i> <i>input_nets</i></tt> takes a dataflow
network <tt><i>net</i></tt> and hooks up its inputs to the output of
each of the networks in list <tt><i>input_nets</i></tt>, each of which
better be a dataflow network without inputs. The result is a new
dataflow network with no inputs, which we can query the output wire of
using <tt>prefix</tt>. For example:</p>
<pre>
# prefix 20 (apply psums [nats]);;
- : int list =
[0; 1; 3; 6; 10; 15; 21; 28; 36; 45; 55; 66; 78; 91; 105; 120; 136; 153; 171; 190]
# prefix 20 (apply psums [primes]);;
- : int list =
[2; 5; 10; 17; 28; 41; 58; 77; 100; 129; 160; 197; 238; 281; 328; 381; 440; 501; 568; 639]
</pre>
    </p>

<p>One final note: the dataflow networks this code lets you write are
  what we might call <i>homogeneous dataflow networks</i>. Every wire
  in the network must carry values of the same type, represented by
  the type associate with a network. For instance, a dataflow network
  of type <tt>int network</tt> carries values of type <tt>int</tt>,
  while a <tt>float network</tt> carries values of
  type <tt>float</tt>. (These are the two types of networks that we
  use in this homework.) This imposes some practical limitations in
  what we can do without encoding data structures within values of a
  given type. This is not a limitation of dataflow networks proper,
  but rather how I decided to implement them in OCaml.</p>

    <hr>

    <ol class="question">

      <li> <p><b>Basic Stream Manipulation</b></p>

	<ol class="subquestion">

	  <li> <p>Code a dataflow network <tt class="code">scale</tt>
	      of type <tt class="code">int network</tt> with one input
	      such that <tt>scale</tt> takes an input stream and produces
	      a stream obtained by multiplying every element of the
	      input stream by <tt>n</tt>:</p>
	    <p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(scale n) &lt;a1 a2 a3 ...&gt; = &lt;n*a1 n*a2 n*a3 ...&gt;</tt></p>
	    </p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# prefix 20 (apply (scale 0) [nats]);;
- : int list = [0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0]
# prefix 20 (apply (scale 3) [nats]);;
- : int list =
[0; 3; 6; 9; 12; 15; 18; 21; 24; 27; 30; 33; 36; 39; 42; 45; 48; 51; 54; 57]
# prefix 20 (apply (scale 3) [evens]);;
- : int list =
[0; 6; 12; 18; 24; 30; 36; 42; 48; 54; 60; 66; 72; 78; 84; 90; 96; 102; 108;
 114]# prefix 20 (apply (scale 3) [stairs 4]);;
- : int list = [0; 3; 6; 9; 0; 3; 6; 9; 0; 3; 6; 9; 0; 3; 6; 9; 0; 3; 6; 9]
</pre>
</div>
	  </li>


	  <li> <p>Code a network <tt class="code">mult</tt> of
	      type <tt class="code">int network</tt> with two inputs such that <tt>mult</tt> produces the
	      stream obtained by multiplying the corresponding
	      elements of the input streams:</p>
	    <p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mult &lt;a1 a2 a3 ...&gt; &lt;b1 b2 b3 ...&gt; =
		&lt;a1*b1 a2*b2 a3*b3 ...&gt;</tt></p>
	    </p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# prefix 20 (apply mult [nats;nats]);;
- : int list =
[0; 1; 4; 9; 16; 25; 36; 49; 64; 81; 100; 121; 144; 169; 196; 225; 256; 289;
 324; 361]
# prefix 20 (apply mult [nats;evens]);;
- : int list =
[0; 2; 8; 18; 32; 50; 72; 98; 128; 162; 200; 242; 288; 338; 392; 450; 512;
 578; 648; 722]
# prefix 20 (apply mult [evens;evens]);;
- : int list =
[0; 4; 16; 36; 64; 100; 144; 196; 256; 324; 400; 484; 576; 676; 784; 900;
 1024; 1156; 1296; 1444]
# prefix 20 (apply mult [evens;stairs 4]);;
- : int list =
[0; 2; 8; 18; 0; 10; 24; 42; 0; 18; 40; 66; 0; 26; 56; 90; 0; 34; 72; 114]
</pre>
</div>
	  </li>


	  <li> <p>Code a function <tt class="code">fold</tt> of
	      type <tt class="code">('a -> 'a -> 'a) -> 'a
	      network</tt> where <tt>fold f</tt> returns a dataflow
	      network with two inputs <i>s</i> and <i>t</i> that produces the stream
	      obtained by the result of calling <tt>f</tt> over each
	      element of the <i>t</i>, passing in the
	      previous value of the resulting stream as well. The
	      initial "previous" value is the first element of <i>s</i>.
	    </p>

	    <p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fold f) &lt;i1 i2 i3 ...&gt; &lt;a1 a2 a3 ...&gt; =<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(f a1 i1) (f a2 (f a1 i1)) (f a3 (f a2 (f a1 i1))) ...&gt;</tt></p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# prefix 20 (apply (fold (fun a r -> a + r)) [nats; nats]);;
- : int list =
[0; 1; 3; 6; 10; 15; 21; 28; 36; 45; 55; 66; 78; 91; 105; 120; 136; 153; 171; 190]
# prefix 20 (apply (fold (fun a r -> a + r)) [nats; evens]);;
- : int list =
[0; 2; 6; 12; 20; 30; 42; 56; 72; 90; 110; 132; 156; 182; 210; 240; 272; 306; 342;
380]
# prefix 10 (apply (fold (fun a r -> a * r)) [odds;odds]);;
- : int list =
[1; 3; 15; 105; 945; 10395; 135135; 2027025; 34459425; 654729075]
- : unit = ()</pre>
	  </div>
	  </li>

<li> <p>Code a dataflow network <tt class="code">running_max</tt> 
	      type <tt class="code">int network</tt> with one input <i>s</i> which produces
     the stream consisting 
	      of the maximum value in <tt>s</tt> seen from the start of <tt>s</tt>:
	    
	    <p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;running_max &lt;a1 a2 a3 ...&gt; = &lt;max(a1)
		max(a1,a2) max(a1,a2,a3) ...&gt;</tt></p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# prefix 20 (apply running_max [nats]);;
- : int list =
[0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19]
# prefix 20 (apply running_max [stairs 3]);;
- : int list = [0; 1; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2]
# prefix 20 (apply running_max [stairs 5]);;
- : int list = [0; 1; 2; 3; 4; 4; 4; 4; 4; 4; 4; 4; 4; 4; 4; 4; 4; 4; 4; 4]
# let insert0s = network ["input"] "result" [
   ("result", fby "first" "a");
   ("zero", cst 0);
   ("a", fby "zero" "rec");
   ("first", splitFirst "input");
   ("rec", rcomponent ["rest"]);
   ("rest", splitRest "input")  ];;
val insert0s : int network = <abstr>
# prefix 20 (apply insert0s [nats]);;
- : int list = [0; 0; 1; 0; 2; 0; 3; 0; 4; 0; 5; 0; 6; 0; 7; 0; 8; 0; 9; 0]
# prefix 20 (apply running_max [apply insert0s [nats]]);;
- : int list = [0; 0; 1; 1; 2; 2; 3; 3; 4; 4; 5; 5; 6; 6; 7; 7; 8; 8; 9; 9]
# prefix 20 (apply running_max [apply insert0s [stairs 4]]);
  ;;
- : int list = [0; 0; 1; 1; 2; 2; 3; 3; 3; 3; 3; 3; 3; 3; 3; 3; 3; 3; 3; 3]
</pre>
	  </div>
	  </li>

<li> <p> Code a dataflow network <tt class="code">stutter</tt> of
    type <tt class="code">'a network</tt> with one input stream <i>s</i>
    which produces the stream consisting of every
    element of <tt>s</tt> "doubled up", that is, repeated twice in sequence:</p>

  <p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stutter &lt;a1 a2 a3 ...&gt; = &lt;a1 a1 a2 a2 a3 a3 ...&gt;</tt></p>
    
	    </p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# prefix 20 (apply stutter [nats]);;
- : int list = [0; 0; 1; 1; 2; 2; 3; 3; 4; 4; 5; 5; 6; 6; 7; 7; 8; 8; 9; 9]
# prefix 20 (apply stutter [evens]);;
- : int list =
[0; 0; 2; 2; 4; 4; 6; 6; 8; 8; 10; 10; 12; 12; 14; 14; 16; 16; 18; 18]
# prefix 20 (apply stutter [stairs 4]);;
- : int list = [0; 0; 1; 1; 2; 2; 3; 3; 0; 0; 1; 1; 2; 2; 3; 3; 0; 0; 1; 1]
# prefix 20 (apply stutter [apply stutter [stairs 4]]);;
- : int list = [0; 0; 0; 0; 1; 1; 1; 1; 2; 2; 2; 2; 3; 3; 3; 3; 0; 0; 0; 0]
</pre>
</div>
	  </li>

	</ol>

      </li>


<li> <p><b>Numerical Analysis</b></p>

  <p>
Many problems in numerical analysis involve finding better and better
approximations to a desired value (such as &pi; or <i>e</i>,
or the solution to a differential equation) until the difference
between successive approximations gets small enough that we decide
that we have converged and report that we have found the value we're
looking for. 
  </p>

<p>Infinite streams help in this context because we can represent the 
  successive approximations to a value by a stream of those
  approximations.</p>

<p>
In this question, we will mostly be dealing with streams of floating 
point numbers. To make your life a bit easier, you may want to code dataflow
networks such as <tt>natsf</tt>, <tt>scalef</tt>, <tt>addf</tt>, and <tt>psumsf</tt> 
that basically do what <tt>nats</tt>, <tt>scale</tt>, <tt>add</tt>,
and <tt>psums</tt> do, but with floating point numbers instead of
integers. 
</p>

	<ol class="subquestion">

	  <li> <p>How do you compute the value of &pi;? One way is to
	      use trigonometry. One of the earliest approaches uses the
	      fact that tan &pi;/4 = 1. Using arctan,
	      the inverse tan function, 
	      we can express this as &pi;/4 = arctan 1, that
	      is, &pi; = 4 arctan 1.</p>
	    
	    <p>Why
	      does that help us? The Taylor expansion of arctan at x
	      tells us that </p>
	    <p> &nbsp;&nbsp;&nbsp;arctan x = x/1
	      - x<sup>3</sup>/3 + x<sup>5</sup>/5
	      - x<sup>7</sup>/7 + ...</p>
	    <p>This is an infinite sum, but it can be approximated by
	      the stream of partial sums</p>
	    <p> &nbsp;&nbsp;&nbsp;&lt;x/1 &nbsp;&nbsp; (x/1 - x<sup>3</sup>/3)
	      &nbsp;&nbsp;(x/1 - x<sup>3</sup>/3 + x<sup>5</sup>/5)
	      &nbsp;&nbsp;(x/1 - x<sup>3</sup>/3 + x<sup>5</sup>/5 - x<sup>7</sup>/7)
	      &nbsp;&nbsp;...&gt; &nbsp;&nbsp;&nbsp; (*)</p>
	    <p>which gets closer and closer to arctan x.</p>

	    <p>Code a function <tt class="code">arctan</tt> with type
	      <tt class="code">float -> float network</tt>
	      where <tt>arctan x</tt> returns a dataflow network
	      producing the stream of approximations to
	      arctan x given by (*) above</p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
	    <pre class="code">
# prefix 20 (arctan 0.0);;
- : float list =
[0.; 0.; 0.; 0.; 0.; 0.; 0.; 0.; 0.; 0.; 0.; 0.; 0.; 0.; 0.; 0.; 0.; 0.; 0.;
 0.]
# prefix 20 (arctan 1.0);;
- : float list =
[1.; 0.666666666666666741; 0.866666666666666696; 0.723809523809523903;
 0.834920634920635063; 0.744011544011544124; 0.820934620934621107;
 0.754267954267954455; 0.813091483679719174; 0.760459904732350811;
 0.808078952351398483; 0.764600691481833294; 0.80460069148183333;
 0.767563654444796351; 0.802046413065486; 0.769788348549357;
 0.800091378852387236; 0.771519950280958655; 0.798546977307985628;
 0.77290595166696]
# prefix 20 (apply (scalef 4.0) [arctan 1.0]);;
- : float list =
[4.; 2.66666666666666696; 3.46666666666666679; 2.89523809523809561;
 3.33968253968254025; 2.97604617604617649; 3.28373848373848443;
 3.01707181707181782; 3.25236593471887669; 3.04183961892940324;
 3.23231580940559393; 3.05840276592733318; 3.21840276592733332;
 3.0702546177791854; 3.20818565226194385; 3.07915339419742784;
 3.20036551540954894; 3.08607980112383462; 3.19418790923194251;
 3.09162380666784]
# nth 1000 (apply (scalef 4.0) [arctan 1.0]);;
- : float = 3.14259165433954424
</pre>
</div>

	    <p>The last example shows that this way of computing &pi; converges very
	      slowly. After 1000 terms into the stream, we're still only at
	      3.142591... which is pretty far from 3.141592...</p>

	    <p>A more efficient way to compute &pi; is to use the following formula:</p>
	    
	    <p>&nbsp;&nbsp;&nbsp; &pi;/4 = 4 arctan (1/5)
	      - arctan (1/239)</p>

	    <p>and thus</p>
	    
	    <p>&nbsp;&nbsp;&nbsp; &pi; = 16 arctan (1/5) -
	      4 arctan (1/239) &nbsp;&nbsp;&nbsp;(**)</p>

	    <p>Again, we know each of the arctan can be approximated by the stream
	      (*), and thus &pi; can be
	      approximated by the difference of the two streams, each properly scaled. </p>

	    <p>Code a dataflow network <tt class="code">pi</tt> with type <tt class="code">float network</tt>
	      which produces the stream providing
	      approximations to &pi; using (**)</p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# prefix 20 pi;;
- : float list =
[3.18326359832636; 3.14059702932606033; 3.14162102932503462;
 3.14159177218217733; 3.14159268240439937; 3.14159265261530862;
 3.141592653623555; 3.14159265358860251; 3.14159265358983619;
 3.14159265358979223; 3.141592653589794; 3.141592653589794;
 3.141592653589794; 3.141592653589794; 3.141592653589794; 3.141592653589794;
 3.141592653589794; 3.141592653589794; 3.141592653589794; 3.141592653589794]
# nth 100 pi;;
- : float = 3.141592653589794
# nth 1000 pi;;
- : float = 3.141592653589794
</pre>
	  </div>
	  </li>


	  <li> 
	    <p>Newton's method is a way to find a zero of a formula with one
	      unknown, such as 10x+20. Recall that a zero of a formula f(x) is a
	      value v that makes f(v)=0. To compute &radic;10,
	      for instance, we can use Newton's method to find a zero of
	      x<sup>2</sup>-10. To compute &#x221b;20 we find a zero of
	      x<sup>3</sup>-20, and so on.  </p>

	    <p>What is Newton's method? It says that to find a zero of f(x), we
	    need the derivative of f, written f'(x), as well as an initial
	    guess x<sub>0</sub>. The guess doesn't have to be a good guess. Once we have a
	      guess x<sub>0</sub>, we can improve the guess by computing x<sub>1</sub> as follows:</p>

	  <p>&nbsp;&nbsp;&nbsp;x<sub>1</sub> = x<sub>0</sub> -
	  f(x<sub>0</sub>)/f'(x<sub>0</sub>)</p>

	    <p>We can repeatedly improve guesses using:</p>
	    <p> &nbsp;&nbsp;&nbsp;
	    x<sub>n+1</sub> = x<sub>n</sub> -
	    f(x<sub>n</sub>)/f'(x<sub>n</sub>)
	    &nbsp;&nbsp;&nbsp;(***)</p>

	    <p>where x<sub>i</sub> is the i<sup>th</sup> guess. Each
	      guess gets closer and closer to a zero of f(x).</p>

	    <p>Code a function <tt class="code">newton</tt> with type
	      <tt class="code">(float -> float) -> (float -> float) -> 
		float -> float network</tt> where <tt>newton f df
		guess</tt> returns a dataflow network that produces
		the stream of approximations of guesses given by 
	      (***) for function <tt>f</tt> with its
		derivative <tt>df</tt> and an initial
	      guess <tt>guess</tt>.
	    </p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# prefix 10 (newton (fun x -> 3. *. x -. 2.) (fun x -> 3.) 1.);;
- : float list =
[1.; 0.666666666666666741; 0.666666666666666741; 0.666666666666666741;
 0.666666666666666741; 0.666666666666666741; 0.666666666666666741;
 0.666666666666666741; 0.666666666666666741; 0.666666666666666741]

# let sqrt v = newton (fun x -> x *. x -. v) (fun x -> 2. *. x) 1.0;;
val sqrt : float -> float network = <fun>

# prefix 10 (sqrt 4.);;
- : float list =
[1.; 2.5; 2.05; 2.00060975609756087; 2.00000009292229475;
 2.00000000000000222; 2.; 2.; 2.; 2.]
# prefix 10 (sqrt 9.);;
- : float list =
[1.; 5.; 3.4; 3.0235294117647058; 3.00009155413138; 3.00000000139698386; 3.;
 3.; 3.; 3.]
# prefix 10 (sqrt 2.);;
- : float list =
[1.; 1.5; 1.41666666666666674; 1.41421568627450989; 1.41421356237468987;
 1.41421356237309515; 1.41421356237309492; 1.41421356237309515;
 1.41421356237309492; 1.41421356237309515]
# prefix 10 (sqrt 3.);;
- : float list =
[1.; 2.; 1.75; 1.73214285714285721; 1.7320508100147276; 1.73205080756887719;
 1.73205080756887742; 1.73205080756887719; 1.73205080756887742;
 1.73205080756887719]
# prefix 10 (sqrt 144.);;
- : float list =
[1.; 72.5; 37.2431034482758605; 20.5547955554420376; 13.7802299905638;
 12.11499150672641; 12.0005457307424379; 12.0000000124086874; 12.; 12.]
</pre>
	  </div>
	  </li>


	  <li> <p>Given that we talked about derivatives in (b), how about
  computing derivatives? It is itself an approximate process. More
  specifically, the value of the derivative of a function f at a
	  point x<sub>0</sub> can be approximated by the
	      sequence:</p>

  <p>&nbsp;&nbsp;&nbsp;
    &lt;<sup>f(x<sub>0</sub>+1)-f(x<sub>0</sub>)</sup> &frasl; <sub>1</sub>
    &nbsp;&nbsp;
    <sup>f(x<sub>0</sub>+&frac12;)-f(x<sub>0</sub>)</sup> &frasl; <sub>&frac12;</sub>
    &nbsp;&nbsp;
    <sup>f(x<sub>0</sub>+&frac13;)-f(x<sub>0</sub>)</sup> &frasl; <sub>&frac13;</sub>
    &nbsp;&nbsp;...&gt;&nbsp;&nbsp;&nbsp;(****)</p>
  <p>where the n<sup>th</sup> term in the sequence is:</p>
  <p>&nbsp;&nbsp;&nbsp; <sup>f(x<sub>0</sub>+(1/n))-f(x<sub>0</sub>)</sup>
    &frasl; <sub>(1/n)</sub></p>

	    <p>Code a function <tt class="code">derivative</tt> with type
	      <tt class="code">(float -> float) -> float -> float network</tt>
	      where <tt>derivative f x</tt> returns a dataflow
	      network that produces the  stream of approximations of the
	      derivative of <tt>f</tt> at point <tt>x</tt> given by (****).
	    </p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# prefix 10 (derivative (fun x-> x *. x) 4.0);;
   (* The derivative of x^2 is just 2x *)
- : float list =
[9.; 8.5; 8.33333333333332504; 8.25; 8.20000000000000284;
 8.16666666666668561; 8.14285714285715656; 8.125; 8.11111111111107519;
 8.09999999999998721]
# nth 1000 (derivative (fun x -> x *. x) 4.0);;
- : float = 8.00099900099941408
# prefix 10 (derivative (fun x-> x *. x +. 10.0) 4.0);;
    (* The derivative of x^2 + 10 is still just 2x *)
- : float list =
[9.; 8.5; 8.33333333333332504; 8.25; 8.20000000000000284;
 8.16666666666668561; 8.14285714285715656; 8.125; 8.11111111111107519;
 8.09999999999998721]
# prefix 10 (derivative (fun x -> 3.0 *. x) 4.0);;
    (* The derivative of 3x is 3 *)
- : float list =
[3.; 3.; 3.; 3.; 3.00000000000000711; 3.; 3.00000000000001421; 3.;
 2.99999999999998934; 2.99999999999998934]
# prefix 10 (derivative (fun x-> x *. x *. x +. x *. x +. 2.0 *. x) 2.0);;
   (* The derivative of x^3 + x^2 + 2x is 3x^2 + 2x + 2 *)
- : float list =
[26.; 21.75; 20.4444444444444606; 19.8125; 19.4400000000000261;
 19.1944444444444144; 19.0204081632652766; 18.890625; 18.7901234567901305;
 18.7100000000000222]
</pre>
	  </div>
	    <p><b>Though questions:</b> <i>Could you somehow modify function <tt>newton</tt> so that it doesn't require you to provide the first derivative of the function for which you want to find a root? Perhaps you could compute the derivative automatically using <tt>derivative</tt>? Also: <tt>derivative</tt> converges horribly. Could you think of a way to improve it?</i></p>
	  </li>
</li>

	  <li> <p> All of the above questions return streams yielding better and
	      better approximations to a desired value. By picking out an
	      element of the stream far enough down, we can find a good
	      approximation to the value we want.</p>

	    <p>But how far do we go? Approximations get closer and closer to the
	      value they approximate, which means that the difference between
	      successive approximations gets smaller and smaller. So we can look into
	      the stream and try to find the first approximation which differs from
	      the next approximation by a small enough margin to decide
	      that we have converged to the desired value, and take that as the
	      desired approximation. Since we can make the margin as small as we
	      want, we can get approximation that are as close as we want to the
	      actual value we seek. (All of this assuming that the
	      stream actually converges to the desired value. What
	      happens if the stream does <i>not</i> converge?)</p>

	    <p>Code a function <tt class="code">limit</tt> with type
	      <tt class="code">float -> float network</tt>
	      where <tt>limit epsilon s</tt> returns a dataflow
	      network with one input <i>s</i> which produces a stream
	      of elements of <tt>s</tt> that differ from their subsequent
	      element by less than <tt>epsilon</tt> (in absolute value).</p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
  <pre class="code">
# prefix 10 (apply (limit 0.00000000001) [pi]);;
- : float list =
[3.14159265358860251; 3.14159265358983619; 3.14159265358979223;
 3.141592653589794; 3.141592653589794; 3.141592653589794; 3.141592653589794;
 3.141592653589794; 3.141592653589794; 3.141592653589794]
# prefix 10 (apply (limit 0.00000000001)
               [newton (fun x -> x *. x -. 10.) (fun x -> 2. *. x) 1.]);;
- : float list =
[3.16227766016837952; 3.16227766016837908; 3.16227766016837952;
 3.16227766016837908; 3.16227766016837952; 3.16227766016837908;
 3.16227766016837952; 3.16227766016837908; 3.16227766016837952;
 3.16227766016837908]
# prefix 10 (apply (limit 0.0000001) [derivative (fun x -> x *. x) 4.]);;
- : float list =
[8.00031625552450265; 8.00031615555879583; 8.00031605562637;
 8.00031595577122445; 8.00031585596800454; 8.00031575622316637;
 8.00031565656377097; 8.00031555696997; 8.00031545740871763;
 8.00031535793515]
</pre>
	  </div>
	  </li>

	</ol>
      </li>

      <li> <p><b>Optional: super challenge</b></p>

	<p>This question is here purely for your entertainment, if
	  you like puzzles or challenges. <b>You do not have to submit anything.</b></p>

	<p>One question I wanted to give you was to create a dataflow
	  network <tt>prefixes</tt> with one input <i>s</i> that would produce a stream
	  of prefixes of <i>s</i>, so that 

	    <p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prefixes &lt;a1 a2 a3 a4
	    ...&gt; = &lt;a1 a1 a2 a1 a2 a3 a1 a2 a3 a4 ...&gt;</tt></p>
	    </p>

	<p>I spent about 5 hours on it, and couldn't do it, at least
	not without encoding something like lists into integers (which
	probably wouldn't play so well with the limited precision
	integers of OCaml.) I still don't know if it can be done or
	  not.</p>

	<p>The question: come up with a dataflow network to compute
	  the prefixes, if one exists.</p>

      </li>


    </ol>

  </body>
</html>

    

  </body>
</html>

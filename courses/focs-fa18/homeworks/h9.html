<!DOCTYPE html>
<html>

  <head>
    
    <meta charset="utf-8">
    <title>Homework 9</title>

    <link rel="stylesheet" href="../alt.css" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,800,700' rel='stylesheet' type='text/css'>

    <script src="autoscroll.js"></script>
    
    <style>

      hr { margin-top: 50px; }

        code,tt,pre {
          font-size: 110%;
        }
	
        div.lect {
	  padding-top: 0;
       	  padding-left: 3em;
	  margin-top:0;
        }
    	p.ann { 
    	  padding-left: 3em;
    	  text-indent: -3em; 
    	}
	p.ann_ctd{
	  padding-left: 3em;
        }
    	span.hdr {
   	  padding-right: 1em
    	}

	.hidden {
	  visibility: hidden;
        }

        tt.code {
           font-weight: bold;
        }

      div.code {
      border: 1px solid #c6c6c6;
      border-radius: 5px;
      padding: 0px;
      margin-bottom: 20px;
      }
      
      div.code p {
      margin:0px;
      padding:5px 10px;
      background:#eeeeee;
      font-style: italic;
      cursor:pointer;
      }

      div.code p:hover {
      background:#cccccc;
      }

      div.code pre { 
      display:none;
      padding: 10px;
      font-size:100%;
      }

      div.code.visible pre  {
      display:block;
      }

ol.question {
    padding-top:1em;
    list-style-type: decimal;
}

ol.subquestion {
    list-style-type: upper-alpha;
}

      ol.question > li {
      font-weight: bold;
      }

      ol.question > li > * {
      font-weight: normal;
      }
      
ol > li {
    padding:4px 8px; /* Add some spacing around the content */
}

li ol,
li ul {margin-top:6px;}

      li > p { margin-top:0;}


      table.diagram {
      border-collapse: collapse;
      }

      table.diagram td, table.diagram th {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: center;
      }

      table.diagram th {
    text-align: center;
    background-color: #666;
    color: white;
      }

      
    </style>

    <script>
      function toggleShowHide (p) { 
      var div = p.parentNode;
        if (div.className && div.className.startsWith("visible")) {
          div.className = "code";
      } else {
        div.className = "visible code";
      }
      }
    </script>


  </head>


  <body>

    <div class="navbar">

      <div class="home">
	<a href="../../../index.html"><img src="../../../home.png" style="height: 1.6em;"></a>
      </div>

      <ul>
	<li><a href="../index.html"><b>Foundations of Computer Science FA18</b></a></li> 
	<li class="hidden"><a class="scrollto" href="#announcements">Announcements</a></li>
	<li class="hidden"><a class="scrollto" href="#info">Course Info</a></li>
	<li class="hidden"><a class="scrollto" href="#lectures">Lectures</a></li>
	<li class="hidden"><a class="scrollto" href="#homeworks">Homeworks</a></li>
      </ul>
    </div>


    <!-- padding -->
    <div id="top" style="height: 5em;"></div>
    
    <h1 class="clear">Homework 9</h1>
    
    <p class="subtitle">Due date: Friday, November 16 (23h59)</p>

    <ul>
      <li><p>This homework is to be done
    individually. You may discuss problems with fellow students, but
    all submitted work must be entirely your own, and should not be from any
    other course, present, past, or future. If you use a solution from
    another source you must cite it &mdash; this includes when that source
	is someone else helping you.</p></li>
      <li><p><b>Please do not post your solutions on a public website or a public repository like GitHub.</b></p></li>

      <li><p>All programming is to be done in OCaml v4.</p></li>

      <li><p>Code your answers by modifying the
      file <a href="homework9.ml"><tt>homework9.ml</tt></a> provided. Add your
      <span style="text-decoration:underline;">name</span>, your <span style="text-decoration:underline;">email address</span>, and any <span style="text-decoration:underline;">remarks</span> that you
      wish to make to the instructor to the block comment at the head of the file.</p></li>

      <li><p><b>Please do not change the types in the signature of the
	function stubs I provide</b>. Doing so will make it
	impossible to load your code into the testing infrastructure,
	and make me unhappy.</p></li>

      <li><p>Feel free to define helper functions if you need them.</p></li>
    </ul>


    <hr>

    
    <p class="subtitle">Electronic submission instructions:</p>

    <ul>
      <li><p>Start a <i>new</i> OCaml shell.</p></li>
      <li><p>Load your homework code via <tt>#use "homework9.ml";;</tt></p></li>
      <li><p>If there are any error, do not submit. I can't test what I
	can't <tt>#use</tt>.</p></li>
      <li><p>When you're ready to submit, send an email with your file <tt>homework9.ml</tt> as an attachment to <tt>olin.submissions@gmail.com</tt> with subject <i>Homework 9 submission</i>.</p></li>
    </ul>


    <hr>

    <p>We are going to provide ways to construct dataflow networks as we saw in class, but textually. Consider the following primitive components that I described in class:
    </p>
<ul>
  <li>cst: create a constant stream of values</li>
  <li>map: map a function on an input stream to produce an output stream</li>
  <li>map2: map a function over two input streams to produce an
  output stream</li>
  <li>fby: take two input streams and produce an output stream made up
  of the first element of the first input stream followed by all the
  elements of the second input stream</li>
  <li>splitFirst: take an input stream and produce an output stream
  made of the first element of the input stream repeatedly indefinitely </li>
  <li>splitRest: take an input stream and produce  an output stream
  made up of the input stream but starting at its second element</li>
  <li>filter: take two input streams and produce an output stream by
  taking a pair of element of each stream and keeping the element of
  the second stream if a predicate apply to both elements returns true</li>
</ul>

<p>Consider the following dataflow network for computing the infinite
  stream of natural numbers starting from 0: 
</p>

  <center style="padding:20px;"><img src="nats.png"></center>

<p>

  The basic idea is pretty simple: we give a name to every wire in a
  dataflow network, and associate with each wire the primitive
  component that gives the wire its values. In the above diagram,
  there are basically three wires, called <i>a</i>, <i>b</i>,
  and <i>result</i>. Wire <i>a</i> gets its values from the constant
  component that always sends 0, wire <i>b</i> gets its values from
  the map component that adds 1 to its input, and the <i>result</i>
  component gets its values from the followed-by component. Each
  primitive component takes its inputs from wires (except for cst,
  which has no inputs). The followed-by component takes its inputs
  from wires <i>a</i> and <i>b</i>, and the map component takes its
  input from the <i>result</i> wire. (Note that the <i>result</i>
  wires forks into two, but since the same values flow on both forks,
  we give it a single name.)
</p>

<p>
This means that we can represent the above dataflow network using the
following list of wires and components giving values to those wires:
<ul style="list-style: none;">
  <li>result = fby a b</li>
  <li>a = cst 0</li>
  <li>b = map (fun x -> x +1) result</li>
</ul>
The dataflow network as a whole has no inputs, and its output is
the <i>result</i> wire. In the notation of the homework, it is
constructed using the code:</p>
<pre>
  let nats = network [] "result" [
    ("result", fby "a" "b");
    ("a", cst 0);
    ("b", map (fun x -> x+1) "result")
  ]
</pre>
    <p>The order of the wire definitions does not matter.</p>

    <p>
The primitive components I give you include:
      <ul style="list-style: none;">
	<li><tt>cst : 'a -> 'a primitive</tt></li>
	<li><tt>map : ('a -> 'a) -> string -> 'a primitive</tt> </li>
	<li><tt>map2 : ('a -> 'a -> 'a) -> string -> string -> 'a
	    primitive</tt></li>
	<li><tt>fby : string -> string -> 'a primitive</tt></li>
	<li><tt>splitFirst : string -> 'a primitive</tt></li>
	<li><tt>splitRest : string -> 'a primitive</tt></li>
	<li><tt>filter : ('a -> 'a -> bool) -> string -> string -> 'a primitive</tt></li>
  </ul>
    </p>

</pre>
Function <tt>network</tt> with type <tt>string list -> string ->
  (string * 'a primitive) list -> 'a network</tt> is used to construct
  a network from primitives: the result
  of <tt>network <i>inputs</i> <i>output</i> <i>descr</i></tt> is a
  dataflow network with input wires <tt><i>inputs</i></tt>, output
  wire <tt><i>output</i></tt>, and description <tt><i>descr</i></tt>
  given as a list of pairs of a wire and the primitive component that
  gives it its value.
</p>

<p>Two other primitive exist, to allow you to reuse a network as a
  component inside another network:</p>

<ul style="list-style: none;">
  <li><tt>component : 'a network -> string list -> 'a
  primitive</tt></li>
  <li><tt>rcomponent : string list -> 'a primitive</tt></li>
</ul>

<p>
Primitive <tt>component <i>net</i> <i>args</i></tt> includes
dataflow network <i>net</i> in your network, attaching the wires
supplied as arguments in <i>args</i> to the input wires
of <tt>net</tt>. The output wire of <i>net</i> is the output wire of
the primitive.
</p>


    <p>Similarly, primitive <tt>rcomponent <i>args</i></tt> includes
    the current network recursively inside the network, attaching the
      wires supplied as arguments in <i>args</i> to the input wires of
    the network. Again, the output wire of the recursively included
      network is the output wire of the primitive.</p>

<p>By way of example, consider the following super simple dataflow
  network to add two streams of integers, pointwise</p>
<pre>
  let add = network ["input1";"input2"] "result" [
    ("result", map2 (fun x y -> x+y) "input1" "input2")
  ]
</pre>

<p>You can use that component inside the dataflow network to compute
  the partial sums of a streams as we saw in class,
  taking a stream <i>a1 a2 a3 ...</i> and producing <i>a1 (a1+a2)
  (a1+a2+a3) ...</i>. This is the network I drew in class:
</p>

  <center style="padding:20px;"><img src="psums.png"></center>

<p>It can be captured as follows in the above syntax:
<pre>
  let psums = network ["input"] "result" [
    ("result", fby "input" "b");
    ("a", splitRest "input");
    ("b", component add ["a";"result"])
  ]
</pre>
Note the use of <tt>splitRest</tt> to get the "bottom" wire of the split component in the graphical representation. If we wanted the "top" wire, we would use <tt>splitFirst</tt>. 
</p>

<p>As an example of a recursive network, consider the sieve of
  Eratosthenes, again described in class:</p>
<pre>
  let sieve = 
    let notdivides c x = x mod c &lt;> 0  in
    network ["input"] "result" [
      ("top", splitFirst "input");
      ("bot", splitRest "input");
      ("result", fby "top" "rec_sieve");
      ("rec_sieve", rcomponent ["filtered"]);
      ("filtered", filter notdivides "top" "bot");
    ]
</pre>
<p>
Note the recursive use of the network. With <tt>sieve</tt>, you can
define a network to produce the prime numbers:</p>
<pre>
  let primes = network [] "result" [
    ("result", component sieve ["map"]);
    ("map", map (fun x -> x+2) "nats");
    ("nats", component nats [])
  ]
</pre>

    <p>How do you get a dataflow network to compute? For a <i><b>dataflow
	  network with no input streams</b></i>, you can simply use
      function <tt>prefix</tt>:</p>
<ul style="list-style: none;">
  <li><tt>prefix : int -> 'a network -> 'a list</tt></li>
</ul>where <tt>prefix <i>n</i> <i>net</i></tt> takes a number <i>n</i> and
a dataflow network <i>net</i> (having no input streams) and returns
the first <i>n</i> elements produced on the output wire
of <i>net</i>. Thus, for example:</p>
<pre>
# prefix 20 nats;;
- : int list =
[0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19]
# prefix 20 primes;;
- : int list =
[2; 3; 5; 7; 11; 13; 17; 19; 23; 29; 31; 37; 41; 43; 47; 53; 59; 61; 67; 71]
</pre>

<p>
What about networks that expect one or more input streams? We can't
apply <tt>prefix</tt> directly. What we can do is supply streams to
the input wires of the network. Function <tt>apply</tt> is provided for that purpose:
<ul style="list-style: none;">
  <li><tt>apply : 'a network -> 'a network list -> 'a network</tt></li>
</ul>
where <tt>apply <i>net</i> <i>input_nets</i></tt> takes a dataflow
network <tt><i>net</i></tt> and hooks up its inputs to the output of
each of the networks in list <tt><i>input_nets</i></tt>, each of which
better be a dataflow network without inputs. The result is a new
dataflow network with no inputs, which we can query the output wire of
using <tt>prefix</tt>. For example:</p>
<pre>
# prefix 20 (apply psums [nats]);;
- : int list =
[0; 1; 3; 6; 10; 15; 21; 28; 36; 45; 55; 66; 78; 91; 105; 120; 136; 153; 171; 190]
# prefix 20 (apply psums [primes]);;
- : int list =
[2; 5; 10; 17; 28; 41; 58; 77; 100; 129; 160; 197; 238; 281; 328; 381; 440; 501; 568; 639]
</pre>
    </p>

<p>One final note: the dataflow networks my code lets you write are
  what we might call <i>homogeneous dataflow networks</i>. Every wire
  in the network must carry values of the same type, represented by
  the type associate with a network. For instance, a dataflow network
  of type <tt>int network</tt> carries values of type <tt>int</tt>,
  while a <tt>float network</tt> carries values of
  type <tt>float</tt>. (These are the two types of networks that we
  use in this homework.) This imposes some practical limitations in
  what we can do without encoding data structures within values of a
  given type. This is not a limitation of dataflow networks proper,
  but rather how I decided to implement them in OCaml.</p>

    <hr>

    <ol class="question">

      <li> <p><b>Basic Stream Manipulation</b></p>

	<ol class="subquestion">

	  <li> <p>Code a dataflow network <tt class="code">scale</tt>
	      of type <tt class="code">int network</tt> with one input
	      such that <tt>scale</tt> takes an input stream and produces
	      a stream obtained by multiplying every element of the
	      input stream by <tt>n</tt>:</p>
	    <p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scale n &lt;a1 a2 a3 ...&gt; = &lt;n*a1 n*a2 n*a3 ...&gt;</tt></p>
	    </p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# pri (scale 2 nats);;
&lt; 0 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 ...>
- : unit = ()
# pri (scale 3 evens);;
&lt; 0 6 12 18 24 30 36 42 48 54 60 66 72 78 84 90 96 102 108 114 ...>
- : unit = ()
# pri (scale 4 odds);;
&lt; 4 12 20 28 36 44 52 60 68 76 84 92 100 108 116 124 132 140 148 156 ...>
- : unit = ()
# pri (scale 0 nats);;
&lt; 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ...>
- : unit = ()</pre>
</div>
	  </li>


	  <li> <p>Code a network <tt class="code">mult</tt> of
	      type <tt class="code">int network</tt> with two inputs such that <tt>mult</tt> produces the
	      stream obtained by multiplying the corresponding
	      elements of the input streams:</p>
	    <p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mult &lt;a1 a2 a3 ...&gt; &lt;b1 b2 b3 ...&gt; =
		&lt;a1*b1 a2*b2 a3*b3 ...&gt;</tt></p>
	    </p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# pri (mult nats nats);;
&lt; 0 1 4 9 16 25 36 49 64 81 100 121 144 169 196 225 256 289 324 361 ...>
- : unit = ()
# pri (mult nats evens);;
&lt; 0 2 8 18 32 50 72 98 128 162 200 242 288 338 392 450 512 578 648 722 ...>
- : unit = ()
# pri (mult nats odds);;
&lt; 0 3 10 21 36 55 78 105 136 171 210 253 300 351 406 465 528 595 666 741 ...>
- : unit = ()
# pri (mult (cst 4) nats);;
&lt; 0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 ...>
- : unit = ()
# pri (mult (cst 0) nats);;
&lt; 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ...>
- : unit = ()
</pre>
</div>
	  </li>



	  <li> <p>Code a function <tt class="code">fold</tt> of
	      type <tt class="code">('a -> 'a -> 'a) -> 'a
	      network</tt> where <tt>fold f</tt> returns a dataflow
	      network with two inputs <i>s</i> and <i>t</i> that produces the stream
	      obtained by the result of calling <tt>f</tt> over each
	      element of the <i>t</i>, passing in the
	      previous value of the resulting stream as well. The
	      initial "previous" value is the first element of <i>s</i>.
	    </p>

	    <p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fold f) &lt;i1 i2 i3 ...&gt; &lt;a1 a2 a3 ...&gt; =<br>
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(f a1 i1) (f a2 (f a1 i1)) (f a3 (f a2 (f a1 i1))) ...&gt;</tt></p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# pri (fold (fun a r -> a+r) (cst 0) nats);;
&lt; 0 1 3 6 10 15 21 28 36 45 55 66 78 91 105 120 136 153 171 190 ...>
- : unit = ()
# pri (fold (fun a r -> a+r) (cst 10) evens);;
&lt; 10 12 16 22 30 40 52 66 82 100 120 142 166 192 220 250 282 316 352 390 ...>
- : unit = ()
# pri (fold (fun a r -> a*r) (cst 2) nats);;
&lt; 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ...>
- : unit = ()
# pri (fold (fun a r -> a*r) (cst 2) odds);;
&lt; 2 6 30 210 1890 20790 270270 4054050 68918850 1309458150 27498621150 
  632468286450 15811707161250 426916093353750 12380566707258750 383797567925021250 
  3441947704670925442 564333184370304966 2433583747991732126 2676045803129794834 
  ...>
- : unit = ()
# prs (fold (fun a r -> r^a) (cst "") s_as);;
&lt; a0 a0a1 a0a1a2 a0a1a2a3 a0a1a2a3a4 a0a1a2a3a4a5 a0a1a2a3a4a5a6 a0a1a2a3a4a5a6a7 
  a0a1a2a3a4a5a6a7a8 a0a1a2a3a4a5a6a7a8a9 a0a1a2a3a4a5a6a7a8a9a10 
  a0a1a2a3a4a5a6a7a8a9a10a11 a0a1a2a3a4a5a6a7a8a9a10a11a12 
  a0a1a2a3a4a5a6a7a8a9a10a11a12a13 a0a1a2a3a4a5a6a7a8a9a10a11a12a13a14 
  a0a1a2a3a4a5a6a7a8a9a10a11a12a13a14a15 
  a0a1a2a3a4a5a6a7a8a9a10a11a12a13a14a15a16 
  a0a1a2a3a4a5a6a7a8a9a10a11a12a13a14a15a16a17 
  a0a1a2a3a4a5a6a7a8a9a10a11a12a13a14a15a16a17a18 
  a0a1a2a3a4a5a6a7a8a9a10a11a12a13a14a15a16a17a18a19 ...>
- : unit = ()</pre>
	  </div>
	  </li>

<li> <p>Code a dataflow network <tt class="code">running_max</tt> 
	      type <tt class="code">int network</tt> with one input <i>s</i> which produces
     the stream consisting 
	      of the maximum value in <tt>s</tt> seen from the start of <tt>s</tt>:
	    
	    <p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;running_max &lt;a1 a2 a3 ...&gt; = &lt;max(a1)
		max(a1,a2) max(a1,a2,a3) ...&gt;</tt></p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# pri (running_max odds);;
&lt; 1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 ...>
- : unit = ()
# pri (running_max odds);;
&lt; 1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 ...>
- : unit = ()
# pri (running_max (map (fun x -> (-x)) nats));;
&lt; 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ...>
- : unit = ()
# pri (running_max (map (fun x -> if x mod 2 = 0 then x else -x) nats));;
&lt; 0 0 2 2 4 4 6 6 8 8 10 10 12 12 14 14 16 16 18 18 ...>
- : unit = ()
# pri (running_max s_ampl);;
&lt; 0 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 ...>
- : unit = ()</pre>
	  </div>
	  </li>

<li> <p> Code a dataflow network <tt class="code">stutter</tt> of
    type <tt class="code">'a network</tt> with one input stream <i>s</i>
    which produces the stream consisting of every
    element of <tt>s</tt> "doubled up", that is, repeated twice in sequence:</p>

  <p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stutter &lt;a1 a2 a3 ...&gt; = &lt;a1 a1 a2 a2 a3 a3 ...&gt;</tt></p>
    
	    </p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# pri (stutter nats);;
&lt; 0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 ...>
- : unit = ()
# pri (stutter (stutter nats));;
&lt; 0 0 0 0 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 ...>
- : unit = ()
# prs (stutter s_as);;
&lt; a0 a0 a1 a1 a2 a2 a3 a3 a4 a4 a5 a5 a6 a6 a7 a7 a8 a8 a9 a9 ...>
- : unit = ()</pre>
</div>
	  </li>

	</ol>

      </li>


<li> <p><b>Numerical Analysis</b></p>

  <p>
Many problems in numerical analysis involve finding better and better
approximations to a desired value (such as &pi; or <i>e</i>,
or the solution to a differential equation) until the difference
between successive approximations gets small enough that we decide
that we have converged and report that we have found the value we're
looking for. 
  </p>

<p>Infinite streams help in this context because we can represent the 
  successive approximations to a value by a stream of those
  approximations.</p>

<p>
In this question, we will mostly be dealing with streams of floating 
point numbers. To make your life a bit easier, you may want to code dataflow
networks such as <tt>natsf</tt>, <tt>scalef</tt>, <tt>addf</tt>, and <tt>psumsf</tt> 
that basically do what <tt>nats</tt>, <tt>scale</tt>, <tt>add</tt>,
and <tt>psums</tt> do, but with floating point numbers instead of
integers. 
</p>

	<ol class="subquestion">

	  <li> <p>How do you compute the value of &pi;? One way is to
	      use trigonometry. One of the earliest approaches uses the
	      fact that tan &pi;/4 = 1. Using arctan,
	      the inverse tan function, 
	      we can express this as &pi;/4 = arctan 1, that
	      is, &pi; = 4 arctan 1.</p>
	    
	    <p>Why
	      does that help us? The Taylor expansion of arctan at x
	      tells us that </p>
	    <p> &nbsp;&nbsp;&nbsp;arctan x = x/1
	      - x<sup>3</sup>/3 + x<sup>5</sup>/5
	      - x<sup>7</sup>/7 + ...</p>
	    <p>This is an infinite sum, but it can be approximated by
	      the stream of partial sums</p>
	    <p> &nbsp;&nbsp;&nbsp;&lt;x/1 &nbsp;&nbsp; (x/1 - x<sup>3</sup>/3)
	      &nbsp;&nbsp;(x/1 - x<sup>3</sup>/3 + x<sup>5</sup>/5)
	      &nbsp;&nbsp;(x/1 - x<sup>3</sup>/3 + x<sup>5</sup>/5 - x<sup>7</sup>/7)
	      &nbsp;&nbsp;...&gt; &nbsp;&nbsp;&nbsp; (*)</p>
	    <p>which gets closer and closer to arctan x.</p>

	    <p>Code a function <tt class="code">arctan</tt> with type
	      <tt class="code">float -> float network</tt>
	      where <tt>arctan x</tt> returns a dataflow network
	      producing the stream of approximations to
	      arctan x given by (*) above</p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
	    <pre class="code">
# prf (arctan 0.0);;
&lt; 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. ...>
- : unit = ()
# prf (arctan 1.0);;
&lt; 1. 0.666666666667 0.866666666667 0.72380952381 0.834920634921 
  0.744011544012 0.820934620935 0.754267954268 0.81309148368 
  0.760459904732 0.808078952351 0.764600691482 0.804600691482 
  0.767563654445 0.802046413065 0.769788348549 0.800091378852 
  0.771519950281 0.798546977308 0.772905951667 ...>
- : unit = ()
# prf (scalef 4.0 (arctan 1.0));;
&lt; 4. 2.66666666667 3.46666666667 2.89523809524 3.33968253968 
  2.97604617605 3.28373848374 3.01707181707 3.25236593472 3.04183961893 
  3.23231580941 3.05840276593 3.21840276593 3.07025461778 3.20818565226 
  3.0791533942 3.20036551541 3.08607980112 3.19418790923 3.09162380667 ...>
- : unit = ()

# let rec dropN n s = if n = 0 then s else let (s1,s2) = split s in dropN (n-1) s2;;
val dropN : int -> 'a AbsStream.stream -> 'a AbsStream.stream = <fun>

# prf (dropN 1000 (scalef 4.0 (arctan 1.0)));;
&lt; 3.14259165434 3.14059464985 3.14258966232 3.1405966379 
  3.14258767822 3.14059861805 3.142585702 3.14060059034 3.14258373362 
  3.14060255482 3.14258177303 3.14060451154 3.14257982018 3.14060646054 
  3.14257787503 3.14060840186 3.14257593752 3.14061033556 3.14257400762 
  3.14061226167 ...>
- : unit = ()</pre>
</div>

	    <p>The last example shows that this way of computing &pi; converges very
	      slowly. After 1000 terms into the stream, we're still only at
	      3.142591... which is pretty far from 3.141592...</p>

	    <p>A more efficient way to compute &pi; is to use the following formula:</p>
	    
	    <p>&nbsp;&nbsp;&nbsp; &pi;/4 = 4 arctan (1/5)
	      - arctan (1/239)</p>

	    <p>and thus</p>
	    
	    <p>&nbsp;&nbsp;&nbsp; &pi; = 16 arctan (1/5) -
	      4 arctan (1/239) &nbsp;&nbsp;&nbsp;(**)</p>

	    <p>Again, we know each of the arctan can be approximated by the stream
	      (*), and thus &pi; can be
	      approximated by the difference of the two streams, each properly scaled. </p>

	    <p>Code a dataflow network <tt class="code">pi</tt> with type <tt class="code">float network</tt>
	      which produces the stream providing
	      approximations to &pi; using (**)</p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# prf (pi ());;
&lt; 3.18326359833 3.14059702933 3.14162102933 3.14159177218 3.1415926824 
  3.14159265262 3.14159265362 3.14159265359 3.14159265359 3.14159265359 
  3.14159265359 3.14159265359 3.14159265359 3.14159265359 3.14159265359 
  3.14159265359 3.14159265359 3.14159265359 3.14159265359 3.14159265359 ...>
- : unit = ()

# let rec dropN n s = if n = 0 then s else let (s1,s2) = split s in dropN (n-1) s2;;
val dropN : int -> 'a AbsStream.stream -> 'a AbsStream.stream = <fun>

# prf (dropN 100 (pi ()));;
&lt; 3.14159265359 3.14159265359 3.14159265359 3.14159265359 3.14159265359 
  3.14159265359 3.14159265359 3.14159265359 3.14159265359 3.14159265359 
  3.14159265359 3.14159265359 3.14159265359 3.14159265359 3.14159265359 
  3.14159265359 3.14159265359 3.14159265359 3.14159265359 3.14159265359 ...>
- : unit = ()
</pre>
	  </div>
	  </li>


	  <li> 
	    <p>Newton's method is a way to find a zero of a formula with one
	      unknown, such as 10x+20. Recall that a zero of a formula f(x) is a
	      value v that makes f(v)=0. To compute &radic;10,
	      for instance, we can use Newton's method to find a zero of
	      x<sup>2</sup>-10. To compute &#x221b;20 we find a zero of
	      x<sup>3</sup>-20, and so on.  </p>

	    <p>What is Newton's method? It says that to find a zero of f(x), we
	    need the derivative of f, written f'(x), as well as an initial
	    guess x<sub>0</sub>. The guess doesn't have to be a good guess. Once we have a
	      guess x<sub>0</sub>, we can improve the guess by computing x<sub>1</sub> as follows:</p>

	  <p>&nbsp;&nbsp;&nbsp;x<sub>1</sub> = x<sub>0</sub> -
	  f(x<sub>0</sub>)/f'(x<sub>0</sub>)</p>

	    <p>We can repeatedly improve guesses using:</p>
	    <p> &nbsp;&nbsp;&nbsp;
	    x<sub>n+1</sub> = x<sub>n</sub> -
	    f(x<sub>n</sub>)/f'(x<sub>n</sub>)
	    &nbsp;&nbsp;&nbsp;(***)</p>

	    <p>where x<sub>i</sub> is the i<sup>th</sup> guess. Each
	      guess gets closer and closer to a zero of f(x).</p>

	    <p>Code a function <tt class="code">newton</tt> with type
	      <tt class="code">(float -> float) -> (float -> float) -> 
		float -> float network</tt> where <tt>newton f df
		guess</tt> returns a dataflow network that produces
		the stream of approximations of guesses given by 
	      (***) for function <tt>f</tt> with its
		derivative <tt>df</tt> and an initial
	      guess <tt>guess</tt>.
	    </p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# prf (newton (fun x -> 3.0 *. x -. 2.0) (fun x -> 3.0) 1.0);;
&lt; 1. 0.666666666667 0.666666666667 0.666666666667 0.666666666667 
  0.666666666667 0.666666666667 0.666666666667 0.666666666667 
  0.666666666667 0.666666666667 0.666666666667 0.666666666667 
  0.666666666667 0.666666666667 0.666666666667 0.666666666667 
  0.666666666667 0.666666666667 0.666666666667 ...>
- : unit = ()

# let sqrt v = newton (fun x -> x *. x -. v) (fun x -> 2.0 *. x) 1.0;;
val sqrt : float -> float AbsStream.stream = <fun>

# prf (sqrt 4.0);;
&lt; 1. 2.5 2.05 2.0006097561 2.00000009292 2. 2. 2. 2. 2. 2. 2. 
  2. 2. 2. 2. 2. 2. 2. 2. ...>
- : unit = ()
# prf (sqrt 9.0);;
&lt; 1. 5. 3.4 3.02352941176 3.00009155413 3.0000000014 3. 3. 3. 
  3. 3. 3. 3. 3. 3. 3. 3. 3. 3. 3. ...>
- : unit = ()
# prf (sqrt 2.0);;
&lt; 1. 1.5 1.41666666667 1.41421568627 1.41421356237 1.41421356237 
  1.41421356237 1.41421356237 1.41421356237 1.41421356237 1.41421356237 
  1.41421356237 1.41421356237 1.41421356237 1.41421356237 1.41421356237 
  1.41421356237 1.41421356237 1.41421356237 1.41421356237 ...>
- : unit = ()
# prf (sqrt 3.0);;
&lt; 1. 2. 1.75 1.73214285714 1.73205081001 1.73205080757 1.73205080757 
  1.73205080757 1.73205080757 1.73205080757 1.73205080757 1.73205080757 
  1.73205080757 1.73205080757 1.73205080757 1.73205080757 1.73205080757 
  1.73205080757 1.73205080757 1.73205080757 ...>
- : unit = ()
# prf (sqrt 144.0);;
&lt; 1. 72.5 37.2431034483 20.5547955554 13.7802299906 12.1149915067 
  12.0005457307 12.0000000124 12. 12. 12. 12. 12. 12. 12. 12. 12. 12. 
  12. 12. ...>
- : unit = ()
</pre>
	  </div>
	  </li>


	  <li> <p>Given that we talked about derivatives in (b), how about
  computing derivatives? It is itself an approximate process. More
  specifically, the value of the derivative of a function f at a
	  point x<sub>0</sub> can be approximated by the
	      sequence:</p>

  <p>&nbsp;&nbsp;&nbsp;
    &lt;<sup>f(x<sub>0</sub>+1)-f(x<sub>0</sub>)</sup> &frasl; <sub>1</sub>
    &nbsp;&nbsp;
    <sup>f(x<sub>0</sub>+&frac12;)-f(x<sub>0</sub>)</sup> &frasl; <sub>&frac12;</sub>
    &nbsp;&nbsp;
    <sup>f(x<sub>0</sub>+&frac13;)-f(x<sub>0</sub>)</sup> &frasl; <sub>&frac13;</sub>
    &nbsp;&nbsp;...&gt;&nbsp;&nbsp;&nbsp;(****)</p>
  <p>where the n<sup>th</sup> term in the sequence is:</p>
  <p>&nbsp;&nbsp;&nbsp; <sup>f(x<sub>0</sub>+(1/n))-f(x<sub>0</sub>)</sup>
    &frasl; <sub>(1/n)</sub></p>

	    <p>Code a function <tt class="code">derivative</tt> with type
	      <tt class="code">(float -> float) -> float -> float network</tt>
	      where <tt>derivative f x</tt> returns a dataflow
	      network that produces the  stream of approximations of the
	      derivative of <tt>f</tt> at point <tt>x</tt> given by (****).
	    </p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# let rec dropN n s = if n = 0 then s else let (s1,s2) = split s in dropN (n-1) s2;;
val dropN : int -> 'a AbsStream.stream -> 'a AbsStream.stream = <fun>

# let d = derivative (fun x -> x *. x) 4.0;;
val d : float stream = <abstr>
   (* The derivative of x^2 is just 2x *)

# prf d;;
&lt; 9. 8.5 8.33333333333 8.25 8.2 8.16666666667 8.14285714286 8.125 
  8.11111111111 8.1 8.09090909091 8.08333333333 8.07692307692 8.07142857143 
  8.06666666667 8.0625 8.05882352941 8.05555555556 8.05263157895 8.05 ...>
- : unit = ()
# prf (dropN 1000 d);;
&lt; 8.000999001 8.00099800399 8.00099700897 8.00099601593 8.00099502488 
  8.00099403578 8.00099304866 8.00099206349 8.00099108028 8.00099009901 
  8.00098911968 8.00098814229 8.00098716683 8.0009861933 8.00098522167 
  8.00098425197 8.00098328417 8.00098231828 8.00098135427 8.00098039216 ...>
- : unit = ()

# prf (derivative (fun x -> x *. x +. 10.0) 4.0);;
    (* The derivative of x^2 + 10 is still just 2x *)
&lt; 9. 8.5 8.33333333333 8.25 8.2 8.16666666667 8.14285714286 8.125 
  8.11111111111 8.1 8.09090909091 8.08333333333 8.07692307692 8.07142857143 
  8.06666666667 8.0625 8.05882352941 8.05555555556 8.05263157895 8.05 ...>
- : unit = ()
# prf (derivative (fun x -> 3.0 *. x) 4.0);;
    (* The derivative of 3x is 3 *)
&lt; 3. 3. 3. 3. 3. 3. 3. 3. 3. 3. 3. 3. 3. 3. 3. 3. 3. 3. 3. 3. ...>
- : unit = ()

# let d = derivative (fun x-> x *. x *. x +. x *. x +. 2.0 *. x) 2.0;;
val d : float stream = <abstr>
   (* The derivative of x^3 + x^2 + 2x is 3x^2 + 2x + 2 *)

# prf d;;
&lt; 26. 21.75 20.4444444444 19.8125 19.44 19.1944444444 19.0204081633 
  18.890625 18.7901234568 18.71 18.6446280992 18.5902777778 18.5443786982 
  18.5051020408 18.4711111111 18.44140625 18.4152249135 18.3919753086 
  18.3711911357 18.3525 ...>
- : unit = ()
# prf (dropN 1000 d);;
&lt; 18.006994005 18.006987024 18.0069800568 18.0069731036 18.0069661642 
  18.0069592386 18.0069523268 18.0069454286 18.0069385442 18.0069316734 
  18.0069248161 18.0069179725 18.0069111423 18.0069043256 18.0068975224 
  18.0068907325 18.006883956 18.0068771928 18.0068704429 18.0068637063 ...>
</pre>
	  </div>
	  </li>
</li>

	  <li> <p> All of the above questions return streams yielding better and
	      better approximations to a desired value. By picking out an
	      element of the stream far enough down, we can find a good
	      approximation to the value we want.</p>

	    <p>But how far do we go? Approximations get closer and closer to the
	      value they approximate, which means that the difference between
	      successive approximations gets smaller and smaller. So we can look into
	      the stream and try to find the first approximation which differs from
	      the next approximation by a small enough margin to decide
	      that we have converged to the desired value, and take that as the
	      desired approximation. Since we can make the margin as small as we
	      want, we can get approximation that are as close as we want to the
	      actual value we seek. (All of this assuming that the
	      stream actually converges to the desired value. What
	      happens if the stream does <i>not</i> converge?)</p>

	    <p>Code a function <tt class="code">limit</tt> with type
	      <tt class="code">float -> float network</tt>
	      where <tt>limit epsilon s</tt> returns a dataflow
	      network with one input <i>s</i> which produces a stream
	      of elements of <tt>s</tt> that differ from their subsequent
	      element by less than <tt>epsilon</tt> (in absolute value).</p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# prf (limit 0.00001 (map (fun n -> 1.0 /. (float (n+1))) nats));;
&lt; 0.00316455696203 0.00315457413249 0.00314465408805 0.00313479623824 
  0.003125 0.00311526479751 0.00310559006211 0.0030959752322 
  0.00308641975309 0.00307692307692 0.00306748466258 0.00305810397554 
  0.0030487804878 0.00303951367781 0.0030303030303 0.00302114803625 
  0.00301204819277 0.003003003003 0.00299401197605 0.00298507462687 ...>
- : unit = ()
# prf (limit 0.0000000001 (pi ()));;
&lt; 3.14159265362 3.14159265359 3.14159265359 3.14159265359 3.14159265359 
  3.14159265359 3.14159265359 3.14159265359 3.14159265359 3.14159265359 
  3.14159265359 3.14159265359 3.14159265359 3.14159265359 3.14159265359 
  3.14159265359 3.14159265359 3.14159265359 3.14159265359 3.14159265359 ...>
- : unit = ()
# prf (limit 0.0000000001 (newton (fun x -> x *. x -. 10.0) (fun x -> 2.0 *. x) 1.0));;
&lt; 3.16227766017 3.16227766017 3.16227766017 3.16227766017 3.16227766017 
  3.16227766017 3.16227766017 3.16227766017 3.16227766017 3.16227766017 
  3.16227766017 3.16227766017 3.16227766017 3.16227766017 3.16227766017 
  3.16227766017 3.16227766017 3.16227766017 3.16227766017 3.16227766017 ...>
- : unit = ()
# prf (limit 0.0000001 (derivative (fun x -> x *. x) 4.0));;
&lt; 8.00031625552 8.00031615556 8.00031605563 8.00031595577 8.00031585597 
  8.00031575622 8.00031565656 8.00031555697 8.00031545741 8.00031535794 
  8.0003152585 8.00031515917 8.00031505985 8.00031496063 8.00031486146 
  8.00031476236 8.00031466331 8.00031456432 8.00031446541 8.00031436655 ...>
- : unit = ()</pre>
	  </div>
	  </li>

	</ol>
      </li>

      <li> <p><b>Optional: super challenge</b></p>

	<p>This question is here purely for your entertainment and if
	  you like puzzles or challenges.</p>

	<p>One question I wanted to give you was to create a dataflow
	  network <tt>prefixes</tt> with one input <i>s</i> that would produce a stream
	  of prefixes of <i>s</i>, so that 

	    <p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prefixes &lt;a1 a2 a3 a4
	    ...&gt; = &lt;a1 a1 a2 a1 a2 a3 a1 a2 a3 a4 ...&gt;</tt></p>
	    </p>

	<p>I spent about 5 hours on it, and couldn't do it, at least
	not without encoding something like lists into integers (which
	probably wouldn't play so well with the limited precision
	integers of OCaml.) I still don't know if it can be done or
	  not.</p>

	<p>The question: come up with a dataflow network to compute
	  the prefixes, if one exists.</p>

      </li>


    </ol>

  </body>
</html>

    

  </body>
</html>

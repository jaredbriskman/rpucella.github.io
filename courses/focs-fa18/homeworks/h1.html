<!DOCTYPE html>
<html>

  <head>
    
    <meta charset="utf-8">
    <title>Homework 1</title>

    <link rel="stylesheet" href="../alt.css" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,800,700' rel='stylesheet' type='text/css'>

    <script src="autoscroll.js"></script>
    
    <style>

      hr { margin-top: 50px; }

        code,tt,pre {
          font-size: 110%;
        }
	
        div.lect {
	  padding-top: 0;
       	  padding-left: 3em;
	  margin-top:0;
        }
    	p.ann { 
    	  padding-left: 3em;
    	  text-indent: -3em; 
    	}
	p.ann_ctd{
	  padding-left: 3em;
        }
    	span.hdr {
   	  padding-right: 1em
    	}

	.hidden {
	  visibility: hidden;
        }

        tt.code {
           font-weight: bold;
        }

      div.code {
      border: 1px solid #c6c6c6;
      border-radius: 5px;
      padding: 0px;
      margin-bottom: 20px;
      }
      
      div.code p {
      margin:0px;
      padding:5px 10px;
      background:#eeeeee;
      font-style: italic;
      cursor:pointer;
      }

      div.code p:hover {
      background:#cccccc;
      }

      div.code pre { 
      display:none;
      padding: 10px;
      font-size:100%;
      }

      div.code.visible pre  {
      display:block;
      }

ol.question {
    padding-top:1em;
    list-style-type: decimal;
}

ol.subquestion {
    list-style-type: upper-alpha;
}

      ol.question > li {
      font-weight: bold;
      }

      ol.question > li > * {
      font-weight: normal;
      }
      
ol > li {
    padding:4px 8px; /* Add some spacing around the content */
}

li ol,
li ul {margin-top:6px;}

li > p { margin-top:0;}
    </style>

    <script>
      function toggleShowHide (p) { 
      var div = p.parentNode;
        if (div.className && div.className.startsWith("visible")) {
          div.className = "code";
      } else {
        div.className = "visible code";
      }
      }
    </script>


  </head>


  <body>

    <div class="navbar">

      <div class="home">
	<a href="../../index.html"><img src="../../home.png" style="height: 1.6em;"></a>
      </div>

      <ul>
	<li><a href="../index.html"><b>Foundations of Computer Science FA18</b></a></li> 
	<li class="hidden"><a class="scrollto" href="#announcements">Announcements</a></li>
	<li class="hidden"><a class="scrollto" href="#info">Course Info</a></li>
	<li class="hidden"><a class="scrollto" href="#lectures">Lectures</a></li>
	<li class="hidden"><a class="scrollto" href="#homeworks">Homeworks</a></li>
      </ul>
    </div>


    <!-- padding -->
    <div id="top" style="height: 5em;"></div>
    
    <h1 class="clear">Homework 1</h1>
    
    <p class="subtitle">Due date: Wednesday, Sep 12 (23h59)</p>

    <ul>
      <li><p>This homework is to be done
    individually. You may discuss problems with fellow students, but
    all submitted work must be entirely your own, and should not be from any
    other course, present, past, or future. If you use a solution from
    another source you must cite it &mdash; this includes when that source
	is someone else helping you.</p></li>
      <li><p><b>Please do not post your solutions on a public website or a public repository like GitHub.</b></p></li>

      <li><p>All programming is to be done in OCaml v4.</p></li>

      <li><p>Code your answers by modifying the
      file <a href="homework1.ml"><tt>homework1.ml</tt></a> provided. Add your
      <span style="text-decoration:underline;">name</span>, your <span style="text-decoration:underline;">email address</span>, and any <span style="text-decoration:underline;">remarks</span> that you
      wish to make to the instructor to the block comment at the head of the file.</p></li>

      <li><p><b>Please do not change the types in the signature of the
	function stubs I provide</b>. Doing so will make it
	impossible to load your code into the testing infrastructure,
	and make me unhappy.</p></li>

      <li><p>Feel free to define helper functions if you need them.</p></li>
    </ul>


    <hr>

    
    <p class="subtitle">Electronic submission instructions:</p>

    <ul>
      <li><p>Start a <i>new</i> OCaml shell.</p></li>
      <li><p>Load your homework code via <tt>#use "homework1.ml";;</tt></p></li>
      <li><p>If there are any error, do not submit. I can't test what I
	can't <tt>#use</tt>.</p></li>
      <li><p>When you're ready to submit, send an email with your file <tt>homework1.ml</tt> as an attachment to <tt>olin.submissions@gmail.com</tt> with subject <i>Homework 1 submission</i>.</p></li>
    </ul>

<!--
    <hr>

    <p class="subtitle">Updates</p>
    <ul class="simple">
      <li>Jan 21: changed sample outputs for <tt>nth</tt> to match type of the functon.</li>
      <li>Jan 23: changed last sample output for <tt>multM</tt> to a more meaningful one.</li>
      <li>Jan 24: fixed incorrect outer product outputs.</li>
    </ul>
-->
	

    <hr>

    <ol class="question">
      <li> <p><b>Numerical functions</b></p>

	<p>The functions below are all recursive over the integers. Most of these functions are only defined when some of their arguments are positive. I don't care what you do when the arguments are outside the domain of definition. You can either raise an exception using <tt>failwith "message"</tt>, or return a default value.</p>

	<ol class="subquestion">

	  <li> <p>Code a recursive function <tt class="code">expt</tt> of
	      type <tt class="code">int -> int -> int</tt>
	      where <tt>expt <i>a</i> <i>b</i></tt>
	      returns <tt><i>a</i><sup><i>b</i></sup></tt>.</p>

	    <p>The function is
	      defined only when <tt><i>b</i></tt> &geq; 0. Use the
	      fact that <tt><i>a</i><sup><i>b</i></sup></tt>
	      = <tt><i>a</i>&middot;<i>a</i><sup><i>b</i>-1</sup></tt>
	      when <tt><i>b</i></tt> &geq; 1.  </p>
	    
<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre>
# expt 1 0;;
- : int = 1
# expt 1 3;;
- : int = 1
# expt 2 0;;
- : int = 1
# expt 2 1;;
- : int = 2
# expt 2 2;;
- : int = 4
# expt 2 3;;
- : int = 8
# expt 10 3;;
- : int = 1000</pre>
	  </div>
	  </li>



  <li> <p>Code a recursive function <tt class="code">gcd</tt> of
          type <tt class="code">int -> int -> int</tt> which takes two
          non-negative integers and returns the greatest common divisor of those
            integers.</p>
        
<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
        <pre>
# gcd 1 1;;
- : int = 1
# gcd 1 3;;
- : int = 1
# gcd 2 4;;
- : int = 2
# gcd 4 2;;
- : int = 2
# gcd 4 6;;
- : int = 2
# gcd 9 12;;
- : int = 3
# gcd 60 70;;
- : int = 10</pre>
  </div>
	  </li>



  
  <li> <p>Code a recursive function <tt class="code">even</tt> of type
      <tt class="code">int -> bool</tt> where <tt>even n</tt> takes a non-negative integer <tt>n</tt> and returns true exactly when <tt>n</tt> is even. I know you can write <tt>even</tt> using a simple modulus test, but please use the fact that a non-negative integer <tt>n</tt> is even exactly when <tt>n</tt>-1 is not even. (When do you stop?)</p>
  
<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre>
# even 0;;
- : bool = true
# even 1;;
- : bool = false
# even 10;;
- : bool = true
# even 25;;
- : bool = false
</pre>	    
</div>
	  </li>


  

	  <li> <p>The <a href="https://en.wikipedia.org/wiki/Collatz_conjecture">Collatz conjecture</a> says that if you start with any positive integer <tt>n</tt> and iterate the following transformation: when <tt>n</tt> is even return <tt>n/2</tt> and when <tt>n</tt> is odd return <tt>3n+1</tt>, then the process eventually yields <tt>1</tt> after a finite number of steps.</p>

	    <p>Code a recursive function <tt class="code">collatz</tt> of type
	      <tt class="code">int -> int list</tt> where <tt>collatz n</tt> takes a positive integer <tt>n</tt> greater than zero and returns the sequence of integers obtained by the process described above, ending in 1. </p>
  
<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre>
# collatz 1;;
- : int list = [1]
# collatz 2;;
- : int list = [2; 1]
# collatz 3;;
- : int list = [3; 10; 5; 16; 8; 4; 2; 1]
# collatz 4;;
- : int list = [4; 2; 1]
# collatz 12;;
- : int list = [12; 6; 3; 10; 5; 16; 8; 4; 2; 1]
# collatz 19;;
- : int list =
[19; 58; 29; 88; 44; 22; 11; 34; 17; 52; 26; 13; 40; 20; 10; 5; 16; 8; 4; 2;
 1]
# collatz 27;;
- : int list =
[27; 82; 41; 124; 62; 31; 94; 47; 142; 71; 214; 107; 322; 161; 484; 242; 121;
 364; 182; 91; 274; 137; 412; 206; 103; 310; 155; 466; 233; 700; 350; 175;
 526; 263; 790; 395; 1186; 593; 1780; 890; 445; 1336; 668; 334; 167; 502;
 251; 754; 377; 1132; 566; 283; 850; 425; 1276; 638; 319; 958; 479; 1438;
 719; 2158; 1079; 3238; 1619; 4858; 2429; 7288; 3644; 1822; 911; 2734; 1367;
 4102; 2051; 6154; 3077; 9232; 4616; 2308; 1154; 577; 1732; 866; 433; 1300;
 650; 325; 976; 488; 244; 122; 61; 184; 92; 46; 23; 70; 35; 106; 53; 160; 80;
 40; 20; 10; 5; 16; 8; 4; 2; 1]
</pre>	    
</div>
	    <p><i><b>Warning:</b> the Collatz conjecture has been known to be a massive rabbit hole for a certain personality type. Consider yourself warned.</i>
	  </li>



  <li> <p>Code a recursive function <tt class="code">range</tt> of type
      <tt class="code">int -> int -> int list</tt> where <tt>range i j</tt> takes two integers <tt>i</tt> and <tt>j</tt> and returns the list of all consecutive integers between <tt>i</tt> (inclusive) and <tt>j</tt> (exclusive). The list is empty if no integer is in the specified range.</p>
  
<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre>
# range 0 0;;
- : int list = []
# range 0 1;;
- : int list = [0]
# range 0 10;;
- : int list = [0; 1; 2; 3; 4; 5; 6; 7; 8; 9]
# range 5 25;;
- : int list =
[5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24]
</pre>	    
</div>
	  </li>


  

	</ol>
      </li>

      <li> <p><b>List functions</b></p>

	<p>All of the functions below can be written as recursive
	  functions over lists. They all fit the general pattern of:</p>
<pre>
   let rec f xs ... = match xs with
                        [] -> <i>e1</i>
                      | x::xs' -> <i>e2</i>
</pre>
<p>where <tt><i>e2</i></tt> can use <tt>x</tt>, <tt>xs'</tt>, and the
recusive function itself. For some functions, you may need to do some
additional matching in <tt><i>e2</i></tt>, or you can add additional
patterns to the match to capture some special cases.</p>

	<ol class="subquestion">

	  <li><p>
	    Code a recursive function <tt class="code">dupAndNegate</tt> of
	    type <tt class="code">int list -> int list</tt> which takes
	    a list <i>L</i> and returns a new list where every element of <i>L</i>
	    is duplicated and then negated, so that <tt>dupAndNegate
		[1;2;3]</tt> returns <tt>[1;-1;2;-2;3;-3]</tt>.</p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre>
# dupAndNegate [];;
- : int list = []
# dupAndNegate [99];;
- : int list = [99; -99]
# dupAndNegate [1;2;3];;
- : int list = [1; -1; 2; -2; 3; -3]
# dupAndNegate [10;20;30;40];;
- : int list = [10; -10; 20; -20; 30; -30; 40; -40]
</pre>
</div>
	  </li>


	  <li><p>Code a recursive function <tt class="code">positives</tt> of
	    type <tt class="code">int list -> int list</tt> which
	      takes a list of integers <tt>xs</tt> and returns the list of integers in <tt>xs</tt> that are greater than zero. </p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre>
# positives [];;
- : int list = []
# positives [1];;
- : int list = [1]
# positives [1;2;3];;
- : int list = [1; 2; 3]
# positives [-1;-2;-3];;
- : int list = []
# positives [1;-2;3;-4;5;-6;7];;
- : int list = [1; 3; 5; 7]
</pre>
</div>

	  </li>


	  
	  <li><p>Code a recursive function <tt class="code">nth</tt> of
	    type <tt class="code">int -> 'a list -> 'a</tt> which
	      takes an integer <i>n</i> and a list <i>L</i> and 
	      returns the element at position <i>n</i> in
	      list <i>L</i>, where 0 is the position of the first
	      element. </p>

	    <p>If the index <i>n</i> is out of bounds, you can raise
	      an exception using <tt>failwith "message"</tt>.</p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre>
# nth 0 ["a";"b";"c"];;
- : string = "a"
# nth 1 ["a";"b";"c"];;
- : string = "b"
# nth 2 ["a";"b";"c"];;
- : string = "c"
# nth 0 [10 ; 20; 30];;
- : int = 10
</pre>
</div>

	  </li>


	  <li><p>
	    Code a recursive function <tt class="code">last</tt> of
	    type <tt class="code">'a list -> 'a</tt> which returns the
	    last element of a list.</p>

	    <p>If the list is empty, then there is no last
	      element. You can raise an exception using <tt>failwith "message"</tt>.</p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre>
# last [1];;
- : int = 1
# last [1;2];;
- : int = 2
# last [1;2;3;4;5;6;7;8];;
- : int = 8
# last ["a";"b";"c"];;
- : string = "c"</pre>
	  </div>
	  </li>



	  <li><p>
	    Code a recursive function <tt class="code">evenOdds</tt> of
	      type <tt class="code">int list -> (int list * int list)</tt> which
	    takes a list <i>L</i> and returns a pair of lists, the first component of which consists of all even integers in <i>L</i>, and the second component consists of all the odd integers in <i>L</i>. I don't care if you preserve the order of elements (though my examples below do preserve said order).</p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
	    <pre>
# evenOdds [];;
- : int list * int list = ([], [])
# evenOdds [1];;
- : int list * int list = ([], [1])
# evenOdds [2];;
- : int list * int list = ([2], [])
# evenOdds [1;2;3;4;5;6];;
- : int list * int list = ([2; 4; 6], [1; 3; 5])
# evenOdds [1;3;5;7;9;10;11;12];;
- : int list * int list = ([10; 12], [1; 3; 5; 7; 9; 11])
	    </pre>
</div>
	  </li>

	</ol>
      </li>

      <li> <p><b>Vectors</b></p>

	<p>We can implement vectors as lists of integers. Operations
	on vectors such as addition or scalar multiplication can then
	  be implemented as recursive functions over lists.</p>

	<p>One difference from Question 2
	  is that you will sometimes have to recurse over two lists at
	  the same time, which means matching over two
	  lists. One way to do so is to first match over the first list,
	  and then match over the second list in each case of the first
	  list (if applicable). For example:</p>
<pre>
   let rec f xs ys = match xs with
                       [] -> <i>e1</i>
                     | x::xs' -> (match ys with
                                    [] -> <i>e2</i>
                                  | y::ys' -> <i>e3</i>)
</pre>
<p>
Another possibility is to match on both
	  lists at the same time, by treating them as pairs of
lists. For example:</p>
<pre>
   let rec f xs ys = match (xs,ys) with
                       ([],[]) -> <i>e1</i>
                     | (x::xs',[]) -> <i>e2</i>
                     | ([],y::ys') -> <i>e3</i>
                     | (x::xs',y::ys') -> <i>e2</i>
</pre>

	<p>These functions only make sense if their vector arguments have the
	same length. You can assume that your code will be given vectors of the same
	length. I'm only going to test your code with vectors of the
	same length. Still, you should probably make sure that your
	code does return a value in case vectors do not have the same
	length (I don't care what that 
	  value is), or raises an exception using <tt>failwith "message"</tt>. 

	<ol class="subquestion">

	  <li><p>
	    Code a recursive function <tt class="code">scaleV</tt> of
	      type <tt class="code">int -> int list -> int list</tt>
	    which takes an integer <i>a</i> and a vector <i>v</i> and
	    computes the scalar multiplication <i>a v</i> (multiplying
	    every component of <i>v</i> by <i>a</i>).</p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre>
# scaleV 10 [];;
- : int list = []
# scaleV 0 [1;2;3];;
- : int list = [0; 0; 0]
# scaleV 1 [1;2;3];;
- : int list = [1; 2; 3]
# scaleV 2 [1;2;3];;
- : int list = [2; 4; 6]
# scaleV 10 [1;2;3];;
- : int list = [10; 20; 30]</pre>
	  </div>
	  </li>

	  <li><p>
	    Code a recursive function <tt class="code">addV</tt> of
	      type <tt class="code">int list -> int list -> int list</tt>
	    which takes two vectors <i>v<sub>1</sub></i>
	    and <i>v<sub>2</sub></i> and returns the vector
	    sum <i>v<sub>1</sub>+v<sub>2</sub></i>.</p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre>
# addV [] [];;
- : int list = []
# addV [10] [20];;
- : int list = [30]
# addV [10;20;30] [20;40;60];;
- : int list = [30; 60; 90]</pre>
	  </div>
	  </li>



	  <li><p>
	    Code a recursive function <tt class="code">inner</tt> of
	      type <tt class="code">int list -> int list -> int</tt>
	    which takes two vectors <i>v<sub>1</sub></i>
	    and <i>v<sub>2</sub></i> and returns the <a href="https://en.wikipedia.org/wiki/Dot_product">inner product</a>
	    <i>v<sub>1</sub> &middot; v<sub>2</sub></i>.</p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre>
# inner [] [];;
- : int = 0
# inner [10] [20];;
- : int = 200
# inner [1;2;3] [4;5;6];;
- : int = 32
# inner [1;2;3] [8;10;12];;
- : int = 64</pre>
	  </div>
	  </li>


	  <li><p>
	    Code a recursive function <tt class="code">outer</tt> of
	      type <tt class="code">int list -> int list -> int list list</tt>
	    which takes two vectors <i>v<sub>1</sub></i>
	    and <i>v<sub>2</sub></i> and returns the <a href="https://en.wikipedia.org/wiki/Outer_product">outer product</a>
	    <i>v<sub>1</sub> &otimes; v<sub>2</sub></i>.</p>

<p>Note that outer product of two vectors is a matrix. We represent a
  matrix by a list of lists, where each list is a row in the matrix,
  from top to bottom. For example,  <tt>[[1;0];[0;1]]</tt> is the
  identity 2x2 matrix. </p>


<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre>
# outer [] [];;
- : int list list = []
# outer [10] [20];;
- : int list list = [[200]]
# outer [1;2;3] [4;5;6];;
- : int list list = [[4; 5; 6]; [8; 10; 12]; [12; 15; 18]]
# outer [1;2;3] [10; 100; 1000];;
- : int list list = [[10; 100; 1000]; [20; 200; 2000]; [30; 300; 3000]]</pre>
	  </div>
	  </li>

	</ol>
      </li>


    </ol>
	
    

  </body>
</html>

<!DOCTYPE html>
<html>

  <head>
    
    <meta charset="utf-8">
    <title>Homework 8</title>

    <link rel="stylesheet" href="../alt.css" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,800,700' rel='stylesheet' type='text/css'>

    <script src="autoscroll.js"></script>
    
    <style>

      hr { margin-top: 50px; }

        code,tt,pre {
          font-size: 110%;
        }
	
        div.lect {
	  padding-top: 0;
       	  padding-left: 3em;
	  margin-top:0;
        }
    	p.ann { 
    	  padding-left: 3em;
    	  text-indent: -3em; 
    	}
	p.ann_ctd{
	  padding-left: 3em;
        }
    	span.hdr {
   	  padding-right: 1em
    	}

	.hidden {
	  visibility: hidden;
        }

        tt.code {
           font-weight: bold;
        }

      div.code {
      border: 1px solid #c6c6c6;
      border-radius: 5px;
      padding: 0px;
      margin-bottom: 20px;
      }
      
      div.code p {
      margin:0px;
      padding:5px 10px;
      background:#eeeeee;
      font-style: italic;
      cursor:pointer;
      }

      div.code p:hover {
      background:#cccccc;
      }

      div.code pre { 
      display:none;
      padding: 10px;
      font-size:100%;
      }

      div.code.visible pre  {
      display:block;
      }

ol.question {
    padding-top:1em;
    list-style-type: decimal;
}

ol.subquestion {
    list-style-type: upper-alpha;
}

      ol.question > li {
      font-weight: bold;
      }

      ol.question > li > * {
      font-weight: normal;
      }
      
ol > li {
    padding:4px 8px; /* Add some spacing around the content */
}

li ol,
li ul {margin-top:6px;}

      li > p { margin-top:0;}


      table.diagram {
      border-collapse: collapse;
      }

      table.diagram td, table.diagram th {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: center;
      }

      table.diagram th {
    text-align: center;
    background-color: #666;
    color: white;
      }

      
    </style>

    <script>
      function toggleShowHide (p) { 
      var div = p.parentNode;
        if (div.className && div.className.startsWith("visible")) {
          div.className = "code";
      } else {
        div.className = "visible code";
      }
      }
    </script>


  </head>


  <body>

    <div class="navbar">

      <div class="home">
	<a href="../../../index.html"><img src="../../../home.png" style="height: 1.6em;"></a>
      </div>

      <ul>
	<li><a href="../index.html"><b>Foundations of Computer Science FA18</b></a></li> 
	<li class="hidden"><a class="scrollto" href="#announcements">Announcements</a></li>
	<li class="hidden"><a class="scrollto" href="#info">Course Info</a></li>
	<li class="hidden"><a class="scrollto" href="#lectures">Lectures</a></li>
	<li class="hidden"><a class="scrollto" href="#homeworks">Homeworks</a></li>
      </ul>
    </div>


    <!-- padding -->
    <div id="top" style="height: 5em;"></div>
    
    <h1 class="clear">Homework 8</h1>
    
    <p class="subtitle">Due date: Friday, November 16 (23h59)</p>

    <ul>
      <li><p>This homework is to be done
    individually. You may discuss problems with fellow students, but
    all submitted work must be entirely your own, and should not be from any
    other course, present, past, or future. If you use a solution from
    another source you must cite it &mdash; this includes when that source
	is someone else helping you.</p></li>
      <li><p><b>Please do not post your solutions on a public website or a public repository like GitHub.</b></p></li>

      <li><p>All programming is to be done in OCaml v4.</p></li>

      <li><p>Code your answers by modifying the
      file <a href="homework8.ml"><tt>homework8.ml</tt></a> provided. Add your
      <span style="text-decoration:underline;">name</span>, your <span style="text-decoration:underline;">email address</span>, and any <span style="text-decoration:underline;">remarks</span> that you
      wish to make to the instructor to the block comment at the head of the file.</p></li>

      <li><p><b>Please do not change the types in the signature of the
	function stubs I provide</b>. Doing so will make it
	impossible to load your code into the testing infrastructure,
	and make me unhappy.</p></li>

      <li><p>Feel free to define helper functions if you need them.</p></li>
    </ul>


    <hr>

    
    <p class="subtitle">Electronic submission instructions:</p>

    <ul>
      <li><p>Start a <i>new</i> OCaml shell.</p></li>
      <li><p>Load your homework code via <tt>#use "homework8.ml";;</tt></p></li>
      <li><p>If there are any error, do not submit. I can't test what I
	can't <tt>#use</tt>.</p></li>
      <li><p>When you're ready to submit, send an email with your file <tt>homework8.ml</tt> as an attachment to <tt>olin.submissions@gmail.com</tt> with subject <i>Homework 8 submission</i>.</p></li>
    </ul>


    <hr>
    
    <p>This homework is about the lambda calculus. I've implemented
    some code for you to enter and simplify lambda-calculus terms using the
    rules we saw in class. The result is not fast, but it
    works.</p>

    <p>A term is just a string in OCaml. The syntax of terms is
      the one we saw in class, adapted to the ASCII character set:
      <ul>
	<li>An identifier can be any sequence of alphanumeric
	  characters (including <tt>_</tt>, and starting with a
	  letter), such as <tt>x</tt> or <tt>arg_2</tt>
	<li>A lambda is written <tt>&lt;identifier -> M></tt>
	  where <tt>M</tt> is a term, such
	  as <tt>&lt;x -> x></tt> or <tt>&lt;arg -> plus arg arg></tt>
	<li>An application is written <tt>M N</tt>, where <tt>M</tt>
	  and <tt>N</tt> are terms</li>
	<li>Terms can be wrapped in parentheses, such
	  as <tt>(&lt;x -> x>)</tt> or <tt>(ident1 &lt;y -> y>)</tt>.
	</li>
      </ul>
    </p>

    <p>Note that OCaml lets you write multi-line strings, which is super convenient if you want to structure a longer term such as :</p>
    <pre>
# let t = "&lt;x -&gt; 
             &lt;y -&gt; 
               &lt;z -&gt; (iszero x)
                       z 
                       y&gt;&gt;&gt;";;
val t : string =
  "&lt;x -&gt; \n           &lt;y -&gt; \n             &lt;z -&gt; (iszero x)\n                   z \n                     y&gt;&gt;&gt;"</pre>
    <p>The extra whitespace won't affect the simplification rules</p>
      
    <p>To simplify a term, I gave you a function <tt>simplify</tt>
    that repeatedly simplifies redexes until the term reaches a normal
    form. (If a normal form is not reached after 5000
    steps, you'll get an error.)</p>

    <pre>
# simplify [] "&lt;x -> x>";;
Term already in normal form
- : string = "&lt;x -> x>"
# simplify [] "&lt;x -> x> z";;
- : string = "z"
# simplify [] "&lt;x -> &lt;y -> y y> x> z";;
- : string = "z z"</pre>

    <p>    A variant of <tt>simplify</tt> called <tt>simplify_verbose</tt>
      reports all intermediate terms that arise during a
      simplification. That can be quite helpful for debugging.</p>

    <pre>
# simplify_verbose [] "&lt;x -> &lt;y -> y y> x> z";;
   &lt;x -> &lt;y -> y y> x> z
 = &lt;y -> y y> z
 = z z
- : string = "z z"</pre>

    <p>The first argument of <tt>simplify</tt>
      and <tt>simplify_verbose</tt> is a list of abbreviations that
      can be used in the term you want to simplify.? Recall that when
      I presented the lambda calculus in class, I started defining
      terms as abbreviations, for terms such as <tt>true</tt>
      and <tt>false</tt>, to help us when writing down more
      interesting terms. The first argument to <tt>simplify</tt>
      and <tt>simplify_verbose</tt> is a sequence of definitions that
      you can use in your term being simplified, each of the
      form <i>(name,def)</i> where <i>name</i> is the name of the term
      being defined, and <i>def</i> is the definition. For example,
      here are some definitions:
    </p>

    <pre>
# let my_defs = [
    ("plus2", "&lt;n -> succ (succ n)>");
    ("plus4", "&lt;n -> plus2 (plus2 n)>")
  ];;
val my_defs : (string * string) list =
  [("plus2", "&lt;n -> succ (succ n)>"); ("plus4", "&lt;n -> plus2 (plus2 n)>")]
# simplify my_defs "plus4 _1";;
- : string = "&lt;f -> &lt;x -> f (f (f (f (f x))))>>"</pre>

    <p>By default, and to make your life easier, <tt>simplify</tt> and <tt>simplify_verbose</tt> 
always add the definitions of stuff we did in class (including natural number
      arithmetic, complete with a predecessor function) to whatever definitions you provide, so that they are available to you without you need do do anything special:</p>

<pre>
let default_defs = [ 
   ("true", "&lt;x -> &lt;y -> x>>");
   ("false", "&lt;x -> &lt;y -> y>>");
   ("if", "&lt;c -> &lt;x -> &lt;y -> c x y>>>");

   ("_0", "&lt;f -> &lt;x -> x>>");
   ("_1", "&lt;f -> &lt;x -> f x>>");
   ("_2", "&lt;f -> &lt;x -> f (f x)>>");
   ("_3", "&lt;f -> &lt;x -> f (f (f x))>>");
   ("_4", "&lt;f -> &lt;x -> f (f (f (f x)))>>");
   ("_5", "&lt;f -> &lt;x -> f (f (f (f (f x))))>>");
   ("succ", "&lt;n -> &lt;f -> &lt;x -> (n f) (f x)>>>");
   ("plus", "&lt;m -> &lt;n -> &lt;f -> &lt;x -> (m f) (n f x)>>>>");
   ("times", "&lt;m -> &lt;n -> &lt;f -> &lt;x -> m (n f) x>>>>");
   ("iszero", "&lt;n -> n &lt;x -> false> true>");
   ("pred", "&lt;n -> &lt;f -> &lt;x -> n &lt;g -> &lt;h -> h (g f)>> &lt;u -> x> &lt;u -> u>>>>");

   ("pair", "&lt;x -> &lt;y -> &lt;s -> s x y>>>");
   ("empty", "&lt;ife -> &lt;ifc -> ife>>");
   ("cons", "&lt;x -> &lt;y -> &lt;ife -> &lt;ifc -> ifc x y>>>>");

   ("Y", "&lt;f -> &lt;x -> f (x x)> &lt;x -> f (x x)>>");
   ("sumto", "Y &lt;f -> &lt;n -> (iszero n) _0 (plus n (f (pred n)))>>")
 ]</pre>

    <p><b>Please do not modify <tt>default_defs</tt>. I will be testing your code with my own definition of <tt>default_defs</tt>, and I will not see the changes you've made. This will probably make my tests fail on your code.</b></p>
    
    <p>You'll note that you have only the first 6 natural numbers defined
      as literals. This means that if you want to use natural number 8 somewhere, for instance, you will either
      have to create it by hand, or use the arithmetic operations:
    </p>

    <pre>
# simplify_verbose [] "plus _4 _4";;
   &lt;m -> &lt;n -> &lt;f -> &lt;x -> m f (n f x)>>>> &lt;f -> &lt;x -> f (f (f (f x)))>> &lt;f -> &lt;x -> f (f (f (f x)))>>
 = &lt;n -> &lt;f -> &lt;x -> &lt;f -> &lt;x -> f (f (f (f x)))>> f (n f x)>>> &lt;f -> &lt;x -> f (f (f (f x)))>>
 = &lt;f -> &lt;x -> &lt;f -> &lt;x -> f (f (f (f x)))>> f (&lt;f -> &lt;x -> f (f (f (f x)))>> f x)>>
 = &lt;f -> &lt;x -> &lt;x -> f (f (f (f x)))> (&lt;f -> &lt;x -> f (f (f (f x)))>> f x)>>
 = &lt;f -> &lt;x -> f (f (f (f (&lt;f -> &lt;x -> f (f (f (f x)))>> f x))))>>
 = &lt;f -> &lt;x -> f (f (f (f (&lt;x -> f (f (f (f x)))> x))))>>
 = &lt;f -> &lt;x -> f (f (f (f (f (f (f (f x)))))))>>
- : string = "&lt;f -> &lt;x -> f (f (f (f (f (f (f (f x)))))))>>"</pre>

    <p>When you simplify a term, all definitions are expanded out
    before simplification occurs. This means that when you get 
       the simplified term back, it will be expressed in
    terms of the expanded out definitions. Thus, if you want to check
      that the number 8 you create above is zero or not, you'll get
      the resulting <tt>false</tt> in terms of how it is defined:</p>

    <pre>
# simplify_verbose [] "iszero (plus _4 _4)";;
   &lt;n -> n &lt;x -> &lt;x -> &lt;y -> y>>> &lt;x -> &lt;y -> x>>> (&lt;m -> &lt;n -> &lt;f -> &lt;x -> m f (n f x)>>>> &lt;f -> &lt;x -> f (f (f (f x)))>> &lt;f -> &lt;x -> f (f (f (f x)))>>)
 = &lt;m -> &lt;n -> &lt;f -> &lt;x -> m f (n f x)>>>> &lt;f -> &lt;x -> f (f (f (f x)))>> &lt;f -> &lt;x -> f (f (f (f x)))>> &lt;x -> &lt;x -> &lt;y -> y>>> &lt;x -> &lt;y -> x>>
 = &lt;n -> &lt;f -> &lt;x -> &lt;f -> &lt;x -> f (f (f (f x)))>> f (n f x)>>> &lt;f -> &lt;x -> f (f (f (f x)))>> &lt;x -> &lt;x -> &lt;y -> y>>> &lt;x -> &lt;y -> x>>
 = &lt;f -> &lt;x -> &lt;f -> &lt;x -> f (f (f (f x)))>> f (&lt;f -> &lt;x -> f (f (f (f x)))>> f x)>> &lt;x -> &lt;x -> &lt;y -> y>>> &lt;x -> &lt;y -> x>>
 = &lt;x -> &lt;f -> &lt;x -> f (f (f (f x)))>> &lt;x -> &lt;x -> &lt;y -> y>>> (&lt;f -> &lt;x -> f (f (f (f x)))>> &lt;x -> &lt;x -> &lt;y -> y>>> x)> &lt;x -> &lt;y -> x>>
 = &lt;f -> &lt;x -> f (f (f (f x)))>> &lt;x -> &lt;x -> &lt;y -> y>>> (&lt;f -> &lt;x -> f (f (f (f x)))>> &lt;x -> &lt;x -> &lt;y -> y>>> &lt;x -> &lt;y -> x>>)
 = &lt;x -> &lt;x -> &lt;x -> &lt;y -> y>>> (&lt;x -> &lt;x -> &lt;y -> y>>> (&lt;x -> &lt;x -> &lt;y -> y>>> (&lt;x -> &lt;x -> &lt;y -> y>>> x)))> (&lt;f -> &lt;x -> f (f (f (f x)))>> &lt;x -> &lt;x -> &lt;y -> y>>> &lt;x -> &lt;y -> x>>)
 = &lt;x -> &lt;x -> &lt;y -> y>>> (&lt;x -> &lt;x -> &lt;y -> y>>> (&lt;x -> &lt;x -> &lt;y -> y>>> (&lt;x -> &lt;x -> &lt;y -> y>>> (&lt;f -> &lt;x -> f (f (f (f x)))>> &lt;x -> &lt;x -> &lt;y -> y>>> &lt;x -> &lt;y -> x>>))))
 = &lt;x -> &lt;y -> y>>
- : string = "&lt;x -> &lt;y -> y>>"  </pre>

    <p>Don't worry, by the time you're done with this homework, your brain will be rewired so that you'll read <tt>&lt;x -> &lt;y -> y>></tt> as <tt>false</tt> and <tt>&lt;x -> &lt;y -> x>></tt> as <tt>true</tt>. You're welcome.</p> 


    <p>A tricky point about definitions: every definition in the list of
    definitions can only refer to previously defined terms. This means two things. First, that you can't write recursive definitions.
      If you want recursion, you need to use the <tt>Y</tt> combinator &mdash; see <tt>sumto</tt> in the default definitions for an example. It also means that the order
    of definitions is important, just like in OCaml. What's tricky is that
    if you mess it up, the simplification process will not complain. An undefined identifier
    is just that, an identifier, and it is passed around as an identifier. This makes debugging
      somewhat painful. For instance, suppose you mess up the <tt>plus</tt> in the previous example:</p>

    <pre>
# simplify_verbose [] "iszero (pluss _4 _4)";;
   &lt;n -> n &lt;x -> &lt;x -> &lt;y -> y>>> &lt;x -> &lt;y -> x>>> (pluss &lt;f -> &lt;x -> f (f (f (f x)))>> &lt;f -> &lt;x -> f (f (f (f x)))>>)
 = pluss &lt;f -> &lt;x -> f (f (f (f x)))>> &lt;f -> &lt;x -> f (f (f (f x)))>> &lt;x -> &lt;x -> &lt;y -> y>>> &lt;x -> &lt;y -> x>>
- : string =
"pluss &lt;f -> &lt;x -> f (f (f (f x)))>> &lt;f -> &lt;x -> f (f (f (f x)))>> &lt;x -> &lt;x -> &lt;y -> y>>> &lt;x -> &lt;y -> x>>"   </pre>

    <p>Yeah, that's not great. The clue that something went wrong is the <tt>pluss</tt> there at the beginning.</p>

    <p>You can of course create your own definitions that you can pass to <tt>simplify</tt> or <tt>simplify_verbose</tt>. For instance, you can define <tt>_8</tt> and use it:</p>

    <pre>
# simplify_verbose [("_8","plus _4 _4")] "iszero _8";;
   &lt;n -> n &lt;x -> &lt;x -> &lt;y -> y>>> &lt;x -> &lt;y -> x>>> (&lt;m -> &lt;n -> &lt;f -> &lt;x -> m f (n f x)>>>> &lt;f -> &lt;x -> f (f (f (f x)))>> &lt;f -> &lt;x -> f (f (f (f x)))>>)
 = &lt;m -> &lt;n -> &lt;f -> &lt;x -> m f (n f x)>>>> &lt;f -> &lt;x -> f (f (f (f x)))>> &lt;f -> &lt;x -> f (f (f (f x)))>> &lt;x -> &lt;x -> &lt;y -> y>>> &lt;x -> &lt;y -> x>>
 = &lt;n -> &lt;f -> &lt;x -> &lt;f -> &lt;x -> f (f (f (f x)))>> f (n f x)>>> &lt;f -> &lt;x -> f (f (f (f x)))>> &lt;x -> &lt;x -> &lt;y -> y>>> &lt;x -> &lt;y -> x>>
 = &lt;f -> &lt;x -> &lt;f -> &lt;x -> f (f (f (f x)))>> f (&lt;f -> &lt;x -> f (f (f (f x)))>> f x)>> &lt;x -> &lt;x -> &lt;y -> y>>> &lt;x -> &lt;y -> x>>
 = &lt;x -> &lt;f -> &lt;x -> f (f (f (f x)))>> &lt;x -> &lt;x -> &lt;y -> y>>> (&lt;f -> &lt;x -> f (f (f (f x)))>> &lt;x -> &lt;x -> &lt;y -> y>>> x)> &lt;x -> &lt;y -> x>>
 = &lt;f -> &lt;x -> f (f (f (f x)))>> &lt;x -> &lt;x -> &lt;y -> y>>> (&lt;f -> &lt;x -> f (f (f (f x)))>> &lt;x -> &lt;x -> &lt;y -> y>>> &lt;x -> &lt;y -> x>>)
 = &lt;x -> &lt;x -> &lt;x -> &lt;y -> y>>> (&lt;x -> &lt;x -> &lt;y -> y>>> (&lt;x -> &lt;x -> &lt;y -> y>>> (&lt;x -> &lt;x -> &lt;y -> y>>> x)))> (&lt;f -> &lt;x -> f (f (f (f x)))>> &lt;x -> &lt;x -> &lt;y -> y>>> &lt;x -> &lt;y -> x>>)
 = &lt;x -> &lt;x -> &lt;y -> y>>> (&lt;x -> &lt;x -> &lt;y -> y>>> (&lt;x -> &lt;x -> &lt;y -> y>>> (&lt;x -> &lt;x -> &lt;y -> y>>> (&lt;f -> &lt;x -> f (f (f (f x)))>> &lt;x -> &lt;x -> &lt;y -> y>>> &lt;x -> &lt;y -> x>>))))
 = &lt;x -> &lt;y -> y>>
- : string = "&lt;x -> &lt;y -> y>>"   </pre>

    <p>In fact, all the questions below ask you to create
    definitions. For each question, you should put all your
    definitions into a list of definitions that is self-contained,
    meaning that I can pass it (and only it) to <tt>simplify</tt> to test your
      definitions.</p>

    <p><b>You should feel free to add definitions for helper functions if you need them. </b></p>
                                                                                                                                                        

    
    <hr>


    <ol class="question">

      <li> <p><b>Encodings</b></p>

	<p><i>This question asks you to create definitions of
	    lambda calculus terms with a given name. There are already
	placeholders for those definitions that you should replace
	with your own. Remember that each definition is a name and a
	    term. All these definitions should go into a list of
	definitions <tt>q2_defs</tt>, which is what I'll be
	    testing. Any supporting definitions you need must go in 
	    <tt>q2_defs</tt>.</i></p>
	
	<ol class="subquestion">


      <li><p>Code a term <tt class="code">and</tt> which takes two Boolean arguments <i>a</i> and <i>b</i> and returns <tt>true</tt> when <i>a</i> and <i>b</i> are true, and <tt>false</tt> otherwise.</p>
        
<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
	    <pre class="code">
# simplify q1_defs "and true true";;
- : string = "<x -> <y -> x>>"
# simplify q1_defs "and true false";;
- : string = "<x -> <y -> y>>"
# simplify q1_defs "and false true";;
- : string = "<x -> <y -> y>>"
# simplify q1_defs "and false false";;
- : string = "<x -> <y -> y>>"
</pre>
</div>
      </li>

      <li><p>Code a term <tt class="code">or</tt> which takes two Boolean arguments <i>a</i> and <i>b</i> and returns <tt>true</tt> when either <i>a</i> or <i>b</i> is true, and <tt>false</tt> otherwise.</p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
	    <pre class="code">
# simplify q1_defs "or true true";;
- : string = "<x -> <y -> x>>"
# simplify q1_defs "or true false";;
- : string = "<x -> <y -> x>>"
# simplify q1_defs "or false true";;
- : string = "<x -> <y -> x>>"
# simplify q1_defs "or false false";;
- : string = "<x -> <y -> y>>"
</pre>
</div>

      </li>



      <li><p>Code a term <tt class="code">minus</tt> which takes two Church numeral arguments <i>m</i> and <i>n</i> and returns <i>m-n</i> if <i>m</i> is greater than <i>n</i>, and 0 otherwise.
        </p>
        
<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
	    <pre class="code">
# simplify q1_defs "minus _3 _0";;
- : string = "<f -> <x -> f (f (f x))>>"
# simplify q1_defs "minus _3 _2";;
- : string = "<f -> <x -> f x>>"
# simplify q1_defs "minus _3 _3";;
- : string = "<f -> <x -> x>>"
# simplify q1_defs "minus _3 _4";;
- : string = "<f -> <x -> x>>"
# simplify q1_defs "minus _0 _0";;
- : string = "<f -> <x -> x>>"
# simplify q1_defs "minus _0 _2";;
- : string = "<f -> <x -> x>>"
</pre>
</div>

        <p><b>Hint:</b> Observe that <tt>pred 0</tt> is <tt>0</tt>. </p>
        
      </li>

      
      <li><p>Code a term <tt class="code">geq</tt> which takes two Church numeral arguments <i>m</i> and <i>n</i> and returns <tt>true</tt> when <i>m</i> is greater than or equal to <i>n</i>, and <tt>false</tt> otherwise.
        </p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
	    <pre class="code">
# simplify q1_defs "geq _3 _0";;
- : string = "<x -> <y -> x>>"
# simplify q1_defs "geq _3 _2";;
- : string = "<x -> <y -> x>>"
# simplify q1_defs "geq _3 _3";;
- : string = "<x -> <y -> x>>"
# simplify q1_defs "geq _3 _4";;
- : string = "<x -> <y -> y>>"
# simplify q1_defs "geq _3 _5";;
- : string = "<x -> <y -> y>>"
# simplify q1_defs "geq _0 _0";;
- : string = "<x -> <y -> x>>"
# simplify q1_defs "geq _0 _1";;
- : string = "<x -> <y -> y>>"
</pre>
</div>
        
      </li>
      
	  <li><p>Let's encode pairs. A pair is a package containing two values, <i>(x,y)</i>. Here is a possible encoding for pairs: to build a pair, you pass in two values <i>x</i> and <i>y</i>, and the result is a function that takes a "selector" as an argument and applies that selector to the two values. Here is the corresponding code for function <tt>pair</tt>: <tt>&lt;x -> &lt;y -> &lt;s -> s x y>>></tt>. It is included in your default definitions.</p>

        <p>Code terms <tt class="code">first</tt> and <tt class="code">second</tt> which each take a pair (encoded as above) as an argument, and return the first and second element of the pair, respectively. </p>

	    <p>Your functions should satisfy the following
	      properties:</p>
<pre>
  first (pair a b) = a
  second (pair a b) = b
</pre>

        
<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
	    <pre class="code">
# simplify q1_defs "first (pair a b)";;
- : string = "a"
# simplify q1_defs "second (pair a b)";;
- : string = "b"
</pre>
</div>
	  </li>


	
	</ol>


      </li>







      <li> <p><b>Integers</b></p>

	<p><i>This question asks you to create definitions of
	    lambda calculus terms with a given name. There are already
	placeholders for those definitions that you should replace
	with your own. Remember that each definition is a name and a
	term. All these definitions should go into a list of
	definitions <tt>q2_defs</tt>, which is what I'll be
	    testing. Any helper functions you need must go
	    in <tt>q2_defs</tt> as well.</i></p>  

	<p>We saw in class an encoding of natural numbers
	  0,1,2,3,... In this question, we consider an encoding of
	  intergers, ...,-3,-2,-1,0,1,2,3,... </p>

	<p>The encoding is dead simple. An integer is a pair of a
	sign and a natural number. The sign will be represented by a
	  Boolean value: <tt>true</tt> for positive integers,
	  and <tt>false</tt> for negative integers. Thus,
	  <i>(true,3)</i> is the representation of integer 3,
	  and <i>(false,2)</i> the representation of integer
	  -2. Integer 0 is always represented as (true,0).</p>

        <p>You'll probably want to add your functions <tt>first</tt>
        and <tt>second</tt> from Question 1 as helper functions. I've certainly done so in order to run the sample outputs below.</p>
        


	<ol class="subquestion">

	  <li>
	    <p>Code a term <tt class="code">int</tt> which
	      takes a natural number <i>n</i> and returns a (positive) integer
	      <i>n</i> in the encoding described above. 
	    </p>


<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
	    <pre class="code">
# simplify q2_defs "first (int _0)";;
- : string = "&lt;x -> &lt;y -> x>>"
# simplify q2_defs "first (int _1)";;
- : string = "&lt;x -> &lt;y -> x>>"
# simplify q2_defs "first (int _2)";;
- : string = "&lt;x -> &lt;y -> x>>"
# simplify q2_defs "second (int _0)";;
- : string = "&lt;f -> &lt;x -> x>>"   
# simplify q2_defs "second (int _1)";;
- : string = "&lt;f -> &lt;x -> f x>>"
# simplify q2_defs "second (int _2)";;
- : string = "&lt;f -> &lt;x -> f (f x)>>"   </pre>
</div>
	  </li>	  
	  
	  <li>
	    <p>Code a term <tt class="code">neg_int</tt> which
	      takes an integer <i>n</i> in the encoding described
	      above, and returns its negation. Recall that the negation of 2 is
	      -2, and the negation of -3 is 3. 
	    </p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
	    <pre class="code">
# simplify q2_defs "first (neg_int (int _3))";;
- : string = "&lt;x -> &lt;y -> y>>"
# simplify q2_defs "second (neg_int (int _3))";;
- : string = "&lt;f -> &lt;x -> f (f (f x))>>"
# simplify q2_defs "first (neg_int (neg_int (int _3)))";;
- : string = "&lt;x -> &lt;y -> x>>"
# simplify q2_defs "second (neg_int (neg_int (int _3)))";;
- : string = "&lt;f -> &lt;x -> f (f (f x))>>"	  </pre>
</div>
	  </li>	  



	  <li>
	    <p>Code a term <tt class="code">plus_int</tt> which
	      takes two integers <i>m</i> and <i>n</i> in the encoding
	      described above and returns integer <i>m+n</i>. Of course, <i>m</i> and <i>n</i> may be negative.
	    </p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
	    <pre class="code">
# simplify q2_defs "first (plus_int (int _3) (int _2))";;
- : string = "&lt;x -> &lt;y -> x>>"
# simplify q2_defs "second (plus_int (int _3) (int _2))";;
- : string = "&lt;f -> &lt;x -> f (f (f (f (f x))))>>"
# simplify q2_defs "first (plus_int (int _3) (neg_int (int _2)))";;
- : string = "&lt;x -> &lt;y -> x>>"
# simplify q2_defs "second (plus_int (int _3) (neg_int (int _2)))";;
- : string = "&lt;f -> &lt;x -> f x>>"
# simplify q2_defs "first (plus_int (neg_int (int _3)) (int _2))";;
- : string = "&lt;x -> &lt;y -> y>>"
# simplify q2_defs "second (plus_int (neg_int (int _3)) (int _2))";;
- : string = "&lt;f -> &lt;x -> f x>>"
# simplify q2_defs "first (plus_int (neg_int (int _3)) (neg_int (int _2)))";;
- : string = "&lt;x -> &lt;y -> y>>"
# simplify q2_defs "second (plus_int (neg_int (int _3)) (neg_int (int _2)))";;
- : string = "&lt;f -> &lt;x -> f (f (f (f (f x))))>>"	  </pre>
</div>

	    <p><b>Hint</b>: Just consider all possibilities. You will find functions <tt>geq</tt> and <tt>minus</tt> from Question 1 useful here as helper functions.</p>



	  </li>	  


	  <li>
	    <p>Code a term <tt class="code">times_int</tt> which
	      takes two integers <i>m</i> and <i>n</i> in the encoding
	      described above and returns integer <i>m &times; n</i>. Of course, <i>m</i> and <i>n</i> may be negative.
	    </p>


<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
	    <pre class="code">
# simplify q2_defs "first (times_int (int _3) (int _2))";;
- : string = "&lt;x -> &lt;y -> x>>"
# simplify q2_defs "second (times_int (int _3) (int _2))";;
- : string = "&lt;f -> &lt;x -> f (f (f (f (f (f x)))))>>"
# simplify q2_defs "first (times_int (int _3) (neg_int (int _2)))";;
- : string = "&lt;x -> &lt;y -> y>>"
# simplify q2_defs "second (times_int (int _3) (neg_int (int _2)))";;
- : string = "&lt;f -> &lt;x -> f (f (f (f (f (f x)))))>>"
# simplify q2_defs "first (times_int (neg_int (int _3)) (int _2))";;
- : string = "&lt;x -> &lt;y -> y>>"
# simplify q2_defs "second (times_int (neg_int (int _3)) (int _2))";;
- : string = "&lt;f -> &lt;x -> f (f (f (f (f (f x)))))>>"
# simplify q2_defs "first (times_int (neg_int (int _3)) (neg_int (int _2)))";;
- : string = "&lt;x -> &lt;y -> x>>"
# simplify q2_defs "second (times_int (neg_int (int _3)) (neg_int (int _2)))";;
- : string = "&lt;f -> &lt;x -> f (f (f (f (f (f x)))))>>"	  </pre>
</div>
	  </li>	  


	</ol>

      </li>






      
      


      <li> <p><b>Lists and Recursion</b></p>

	<p><i>This question asks you to create definitions of
	    lambda calculus terms with a given name. There are already
	placeholders for those definitions that you should replace
	with your own. Remember that each definition is a name and a
	    term. All these definitions should go into a list of
	definitions <tt>q3_defs</tt>, which is what I'll be
	    testing. Any supporting definitions you need must go in <tt>q3_defs</tt>.</i></p>


	<ol class="subquestion">

	  <li><p>Let's encode lists. The encoding is a variant of that 
	      for pairs, with a twist. A pair was encoded in Question 1 as a
	      function that took a selector function <i>s</i> as an argument and applied that selector function to the two components of the pair.</p>

        <p>For lists, the twist
	      is that there are two kinds of lists that need to
	be handled differently: empty lists, and non-empty
	      lists. Here is the encoding for an empty list <tt>empty</tt>, and the encoding for a nonempty list <tt>cons x y </tt> with first element <tt>x</tt> and rest <tt>y</tt> (just like <tt>x::y</tt> in OCaml):
        </p>
        <pre>
  empty = &lt;e -> &lt;c -> e>> 
  cons  = &lt;x -> &lt;y -> &lt;e -> &lt;c -> c x y>>>>
</pre>
        
        <p>Your goal is to understand this encoding, and to code a term <tt class="code">match_list</tt>
          which
	      takes a list <i>L</i> (encoded as above) and two other arguments <i>a</i>
	      and <i>f</i> and returns <i>a</i> if <i>L</i> is the
	      empty list, and  otherwise calls <i>f</i> with the head
	      of <i>L</i> and the tail of <i>L</i> as arguments.</p>

	    <p>Roughly speaking, <tt>match_list lst a &lt;h -> &lt;t -> M>></tt>
	      behaves like <tt>match lst with [] -> a | h::t -> M</tt> in OCaml.</p>

	    <p>Your function <tt>match_list</tt> should satisfy the following
	      properties:</p>
<pre>
  match_list empty a f = a
  match_list (cons h t) a f = f h t
</pre>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
	    <pre class="code">
# simplify q3_defs "match_list empty a f";;
- : string = "a"
# simplify q3_defs "match_list (cons h t) a f";;
- : string = "f h t"
# simplify q3_defs "match_list (cons A empty) a &lt;h -> &lt;t -> h>>";;
- : string = "A"
# simplify q3_defs "match_list (cons A (cons B empty)) a &lt;h -> &lt;t -> h>>";;
- : string = "A"
# simplify q3_defs "match_list (cons A (cons B empty)) a &lt;h -> &lt;t -> 
                       match_list t a &lt;h -> &lt;t -> h>>>>";;
- : string = "B"	    </pre>
</div>

	  </li>


	  <li>
	    <p>Code a term <tt class="code">sum</tt> which
	      takes a list of natural numbers in the encoding described above and returns
	      a natural number (in the encoding we saw in class) representing the sum of its elements.
	    </p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
	    <pre class="code">
# simplify q3_defs "sum empty";;
- : string = "&lt;f -> &lt;x -> x>>"
# simplify q3_defs "sum (cons _1 empty)";;
- : string = "&lt;f -> &lt;x -> f x>>"
# simplify q3_defs "sum (cons _1 (cons _3 empty))";;
- : string = "&lt;f -> &lt;x -> f (f (f (f x)))>>"
# simplify q3_defs "sum (cons _1 (cons _3 (cons _5 empty)))";;
- : string = "&lt;f -> &lt;x -> f (f (f (f (f (f (f (f (f x))))))))>>"	  </pre>
</div>

	  </li>	  


	  <li>
	    <p>Code a term <tt class="code">map</tt> which
	      takes a function <i>f</i> and a list <i>L</i> in the
	      encoding described above and returns the list obtained
	      by applying function <i>f</i> to every element of <i>L</i>. 
	    </p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
	    <pre class="code">
# simplify q3_defs "sum (map &lt;x -> plus x x> empty)";;
- : string = "&lt;f -> &lt;x -> x>>"
# simplify q3_defs "sum (map &lt;x -> plus x x> (cons _1 empty))";;
- : string = "&lt;f -> &lt;x -> f (f x)>>"
# simplify q3_defs "sum (map &lt;x -> plus x x> 
                           (cons _1 (cons _2 (cons _3 empty))))";;
- : string = "&lt;f -> &lt;x -> f (f (f (f (f (f (f (f (f (f (f (f x)))))))))))>>"
# simplify q3_defs "match_list (map &lt;x -> plus x x> 
                                  (cons _1 (cons _2 (cons _3 empty)))) 
                        X &lt;h -> &lt;t -> h>>";;
- : string = "&lt;f -> &lt;x -> f (f x)>>"	  </pre>
</div>

	  </li>	  


	  <li>
	    <p><b>(Challenging)</b> Consider the problem of writing a pair of mutually recursive functions <tt>even</tt> and <tt>odd</tt>. Here is how you would define them in OCaml:</p>
          <pre>
  let rec even x = if x = 0 then true else odd (x-1)
  and odd x = if x = 0 then false else even (x-1)
</pre>
        <p>The <tt>and</tt> is how you specify mutual recursion. What happens if you replace the <tt>and</tt> by <tt>let rec</tt>? Why does that happen?</p>

        <p>Intuitively, you need to define <tt>even</tt> and <tt>odd</tt> at the same time, and not separately. It looks like our <tt>Y</tt> combinator is not up to the task. But that's false. Code terms <tt>even</tt> and <tt>odd</tt> which each take a Church numeral and return <tt>true</tt> if the numeral is even (respectively, odd), and false otherwise.
        </p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
	    <pre class="code">
# simplify q3_defs "even _0";;
- : string = "<x -> <y -> x>>"
# simplify q3_defs "even _1";;
- : string = "<x -> <y -> y>>"
# simplify q3_defs "even _2";;
- : string = "<x -> <y -> x>>"
# simplify q3_defs "even _3";;
- : string = "<x -> <y -> y>>"
# simplify q3_defs "even _4";;
- : string = "<x -> <y -> x>>"
# simplify q3_defs "odd _0";;
- : string = "<x -> <y -> y>>"
# simplify q3_defs "odd _1";;
- : string = "<x -> <y -> x>>"
# simplify q3_defs "odd _2";;
- : string = "<x -> <y -> y>>"
# simplify q3_defs "odd _3";;
- : string = "<x -> <y -> x>>"
# simplify q3_defs "odd _4";;
- : string = "<x -> <y -> y>>"
</pre>
</div>

        <p><b>Hint:</b> Write a function to define <tt>even</tt> and <tt>odd</tt> at the same time, taking a <i>pair</i> of functions as arguments and returning a pair of functions as a result, in such a way that the fixed point of that function is the pair of functions <tt>even</tt> and <tt>odd</tt>. </p>
        

	  </li>	  
	</ol>
	
      </li>




    </ol>
    

  </body>
</html>

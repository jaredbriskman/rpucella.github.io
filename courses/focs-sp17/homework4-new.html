<!DOCTYPE html>
<html>

  <head>
    
    <meta charset="utf-8">
    <title>Homework 4</title>

    <link rel="stylesheet" href="alt.css" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,800,700' rel='stylesheet' type='text/css'>

    <script src="autoscroll.js"></script>
    
    <style>

      hr { margin-top: 50px; }

        code,tt,pre {
          font-size: 110%;
        }
	
        div.lect {
	  padding-top: 0;
       	  padding-left: 3em;
	  margin-top:0;
        }
    	p.ann { 
    	  padding-left: 3em;
    	  text-indent: -3em; 
    	}
	p.ann_ctd{
	  padding-left: 3em;
        }
    	span.hdr {
   	  padding-right: 1em
    	}

	.hidden {
	  visibility: hidden;
        }

        tt.code {
           font-weight: bold;
/*           background: #e6e6e6; */
        }

      div.code {
      border: 1px solid #c6c6c6;
      border-radius: 5px;
      padding: 0px;
      margin-bottom: 20px;
      }
      
      div.code p {
      margin:0px;
      padding:5px 10px;
      background:#eeeeee;
      font-style: italic;
      cursor:pointer;
      }

      div.code p:hover {
      background:#cccccc;
      }

      div.code pre { 
      display:none;
      padding: 10px;
      font-size:100%;
      }

      div.code.visible pre  {
      display:block;
      }
      
ol.question {
    padding-top:1em;
    list-style-type: decimal;
}

ol.subquestion {
    list-style-type: upper-alpha;
}

ol > li {
    padding:4px 8px; /* Add some spacing around the content */
}

li ol,
li ul {margin-top:6px;}

li > p { margin-top:0;}


    </style>

    <script>
      function toggleShowHide (p) { 
      var div = p.parentNode;
        if (div.className && div.className.startsWith("visible")) {
          div.className = "code";
      } else {
        div.className = "visible code";
      }
      }
    </script>

  </head>


  <body>

    <div class="navbar">

      <div class="home">
	<a href="../../index.html"><img src="../../home.png" style="height: 1.6em;"></a>
      </div>

      <ul>
	<li><a href="index.html"><b>Foundations of Computer Science SP17</b></a></li> 
	<li class="hidden"><a class="scrollto" href="#announcements">Announcements</a></li>
	<li class="hidden"><a class="scrollto" href="#info">Course Info</a></li>
	<li class="hidden"><a class="scrollto" href="#lectures">Lectures</a></li>
	<li class="hidden"><a class="scrollto" href="#homeworks">Homeworks</a></li>
      </ul>
    </div>


    <!-- padding -->
    <div id="top" style="height: 5em;"></div>
    
    <h1 class="clear">Homework 4</h1>
    
    <p class="subtitle">Due date: Friday, Feb 24 (23:59)</p>

    <p><b>Note on integrity:</b> This homework is meant to be done
    individually. You may discuss problems with fellow students, but
    all work must be entirely your own, and should not be from any
    other course, present, past, or future. If you use a solution from
    another source you must cite it &mdash; this includes when that source
      is someone else helping you.</p>

    <p>Every source file you submit should begin with a block comment
      that lists your <span style="text-decoration:underline;">name</span>, your <span style="text-decoration:underline;">email address</span>, and any <span style="text-decoration:underline;">remarks</span> that you
      wish to make to the instructor.</p>

    <p>All programming is to be done in OCaml v4.</p>

    <p>Feel free to define helper functions if you need them.</p>

    <p>Please code your answers by modifying the
      file <a href="homework4.ml"><tt>homework4.ml</tt></a> provided.</p>


    <p>Please <b>do not change the types in the signature of the
	function stubs I provide</b>. Doing so will make it
	impossible to load your code into the testing infrastructure,
      and make me unhappy.</p>


    <p>Electronic submission instructions:</p>

    <ul>
<!--      <li>Download the --
  --      file <a href="hw3-checker.ml"><tt>hw3-checker.ml</tt></a> --
  --      into the same directory as your homework solution.</li> -->
      <li>Start a <i>new</i> OCaml shell.</li>
      <li>Load your homework code via <tt>#use
      "homework4.ml";;</tt></li>
      <li>If there are any error, do not submit. I can't test what I
	can't <tt>#use</tt>.</li>
<!--      <li>Load the homework checker via <tt>#use "hw3-checker.ml";;</tt></li>
      <li>The homework checker checks that you've implemented all
      functions (or provided stubs for them) and that those functions
      have the type that I asked you to give them. If the checker says
      your types are OK, then you're fine. If the checker gives you an
      error, fix it. If you believe that the checker gives you an
      error wrongly, send me an email.</li> -->
      <li>When you're ready to submit, send an email with your file <tt>homework4.ml</tt> as an attachment to <tt>focs.sp17@gmail.com</tt> with subject <i>Homework 4 submission</i>.</li>
    </ul>

    <hr>

<!--    <p class="subtitle">Updates</p>
    <ul class="simple">
      <li>Feb 9: Added some precision to the acceptance requirement to Question 2(B). And fixed the sample output which did not match either the old requirement, or the new one!</li>
    </ul>
	
    <hr>
-->

    <p>Here is a type for deterministic Turing machines, parameterized
      by the type for states.</p>

<pre>
type symbol = string

type 'a tm = { states : 'a list;
	       input_alphabet : symbol list;
	       tape_alphabet : symbol list;
	       left_marker : symbol;
	       blank : symbol;
	       delta : ('a * symbol) -> ('a * symbol * int);
	       start : 'a;
	       accept : 'a;
	       reject : 'a }
</pre>

    <p>
The definition follows that of Turing machines we've seen in
class. Note that the transition function is given by an OCaml function
taking as input a pair <i>(p,a)</i> of the current state and the
symbol under the tape head and returning a triple <i>(q,b,dir)</i> indicating that
the machine should transition into a state <i>q</i>, writing <i>b</i>
in the 
cell under the tape head, and then moving the 
tape head in direction <i>dir</i>, left when it is 0, and right when
it is 1.
    </p>

<p>
  The one difference from the machines we've seen before is that the
symbols are not characters anymore, but rather strings (though I'm
  using the name <tt>symbol</tt> to refer to them for clarity). That's
because in future homeworks, we will want to mark up elements of the
alphabet, and it's easier to mark up symbols when they are represented
as strings instead of characters. I've given you a function
  <tt>explode</tt> that takes a string and explodes it into a list of
constituent symbols.
</p>

<p>
As a simple example, here is the code implementing a Turing machine
accepting the regular language &lcub;a<sup>m</sup>b<sup>n</sup> |
m,n&ge;0&rcub;:</p>
<pre>
let asbs = { states = ["start"; "q1"; "acc"; "rej"];
             input_alphabet = ["a";"b"];
             tape_alphabet = ["a";"b";"_";">"];
             blank = "_";
             left_marker = ">";
             start = "start";
             accept = "acc";
             reject = "rej";
             delta = (fun inp -> match inp with
                         | ("start", "a") -> ("start", "a", 1)
                         | ("start", "b") -> ("q1", "b", 1)
                         | ("start", ">") -> ("start", ">", 1)
                         | ("start", "_") -> ("acc", "_", 1)
                         | ("q1", "b") -> ("q1", "b", 1)
                         | ("q1", "_") -> ("acc", "_", 1)
                         | ("acc", "a") -> ("acc", "a", 1)
                         | ("acc", "b") -> ("acc", "b", 1)
                         | ("acc", ">") -> ("acc", ">", 1)
                         | ("acc", "_") -> ("acc", "_", 1)
                         | (_,c) -> ("rej",c,1))}
</pre>
<p>
I also provided you with further sample Turing machines <tt>anbn</tt>
and 
<tt>anbncn</tt> accepting &lcub;a<sup>n</sup>b<sup>n</sup> | n &ge;
0&rcub; and &lcub;a<sup>n</sup>b<sup>n</sup>c<sup>n</sup> | n&ge;
0&rcub; respectively.  Note that <tt>anbn</tt> uses different symbols for the left marker and for the blank. 
</p>

<p>
Recall from lecture that a configuration records the current state of
a Turing machine, the content of the tape, and the position of the
tape head. Type <tt> 'a config</tt> is the type of a configuration,
defined as follows:</p>

<pre>
type 'a config = { state : 'a;
                   tape : symbol list;
                   position : int }
</pre>
<p>
Field <tt>state</tt> is the current state, field <tt>tape</tt> is
the content of the tape, and <tt>position</tt> is the position of the
tape head, with 0 as the left-most position on the tape. A
configuration should always include enough symbols in <tt>tape</tt> to
include the given <tt>position</tt>, possibly by padding the end of
the <tt>tape</tt> list with blank symbols (as defined by the machine description).
</p>



    <hr>

    <ol class="question">
      <li> <p><b>Higher-Order Functions</b></p>

	<p>For each function you have to code in this question, full
	  points will be awarded if the 
	  function does not use explicit recursion &mdash; that is, if you use
	  <tt>List.map</tt> or <tt>List.filter</tt>
	  or <tt>List.fold_right</tt>. If you can't get it to 
	  work without recursion, please provide a version with explicit recursion.</p>

	<ol class="subquestion">

	  <li>
	    <p>The OCaml <tt>List</tt> module contains
	  functions <tt>for_all</tt> and <tt>exists</tt> that both
	    take a predicate and a list, and return <tt>true</tt> if all the
	    elements of the list satisfy the predicate (for
	    <tt>for_all</tt>), or at least one element of the list satisfies
	    the predicate (for <tt>exists</tt>).</p>

	    <p>Code a function <tt class="code">count</tt> of
	      type <tt class="code">('a -> bool) -> 'a list -> int</tt>
	      where <tt>count p xs</tt> returns the number of
	      elements in <tt>xs</tt> that satisfy
	      predicate <tt>p</tt>.</p> 

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre>
# count (fun x -> x) [];;
- : int = 0
# count (fun x -> x) [true];;
- : int = 1
# count (fun x -> x) [false];;
- : int = 0
# count (fun x -> x) [false;true;false;true];;
- : int = 2
# count (fun x -> x > 0) [];;
- : int = 0
# count (fun x -> x > 0) [1];;
- : int = 1
# count (fun x -> x > 0) [1;-2];;
- : int = 1
# count (fun x -> x > 0) [1;-2;3;-4;5];;
- : int = 3
</pre>
</div>
	  </li>

	  <li>
	    <p>Code a function <tt class="code">maxp</tt> of
	      type <tt class="code">int list -> int</tt>
	      where <tt>maxp xs</tt> returns the largest
	      positive (&ge; 0) element in list <tt>xs</tt> if one
	      exists, and 0 otherwise.</p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# maxp [];;
- : int = 0
# maxp [4];;
- : int = 4
# maxp [4;5];;
- : int = 5
# maxp [5;4];;
- : int = 5
# maxp [4;6;5];;
- : int = 6
# maxp [4;-6;5];;
- : int = 5
# maxp [-1;-2;-3];;
- : int = 0
</pre>
	  </div>
	  </li>


	  <li>
	    <p>Code a function <tt class="code">mapf</tt> of type
	      <tt class="code">('a -> 'b) list -> 'a list -> 'b
		list</tt> where <tt>mapf fs xs</tt> returns all the results of
	      applying a function in <tt>fs</tt> to a value
	      in <tt>xs</tt>. </p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# let dbl x = "double "^(string_of_int x);;
val dbl : int -> string = <fun>
# let neg x = "negation "^(string_of_int x);;
val neg : int -> string = <fun>

# mapf [] [];;
- : 'a list = []
# mapf [] [1;2;3];;
- : 'a list = []
# mapf [dbl; neg] [];;
- : string list = []
# mapf [dbl] [3];;
- : string list = ["double 3"]
# mapf [dbl] [1;2;3];;
- : string list = ["double 1"; "double 2"; "double 3"]
# mapf [dbl;neg] [3];;
- : string list = ["double 3"; "negation 3"]
# mapf [dbl;neg] [1;2;3];;
- : string list =
["double 1"; "negation 1"; "double 2"; "negation 2"; "double 3"; "negation 3"]
# mapf [(fun x -> "+"^x);(fun x -> "-"^x)] ["hello";"world"];;
- : string list = ["+hello"; "-hello"; "+world"; "-world"]
</pre>
	  </div>
	  </li>


	  <li>
	    <p>Code a function <tt class="code">pairs</tt> of type
	      <tt class="code">'a list -> 'b list -> ('a * 'b)
	      list</tt> where <tt>pairs xs ys</tt> returns all
	      the ways of pairing up an element of <tt>xs</tt> with an
	      element of <tt>ys</tt>.</p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# pairs [] [];;
- : ('a * 'b) list = []
# pairs [1;2] [];;
- : (int * 'a) list = []
# pairs [] ["a";"b";"c"];;
- : ('a * string) list = []
# pairs [1] ["a";"b";"c"];;
- : (int * string) list = [(1, "a"); (1, "b"); (1, "c")]
# pairs [1;2] ["a"];;
- : (int * string) list = [(1, "a"); (2, "a")]
# pairs [1;2] ["a";"b";"c"];;
- : (int * string) list =
[(1, "a"); (1, "b"); (1, "c"); (2, "a"); (2, "b"); (2, "c")]
</pre>
	  </div>
	  </li>


	<li>
	  <p>Code a function <tt class="code">prepend</tt> of
	    type <tt class="code">'a -> 'a list list -> 'a list list</tt>
	    where <tt>preprend x xss</tt> returns the list 
	    obtained by prepending <tt>x</tt> to every list in <tt>xss</tt>.</p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# prepend 1 [];;
- : int list list = []
# prepend 1 [[]];;
- : int list list = [[1]]
# prepend 1 [[66]];;
- : int list list = [[1; 66]]
# prepend 1 [[66];[99]];;
- : int list list = [[1; 66]; [1; 99]]
# prepend 1 [[66];[99];[]];;
- : int list list = [[1; 66]; [1; 99]; [1]]
# prepend 1 [[66];[99];[];[66;99]];;
- : int list list = [[1; 66]; [1; 99]; [1]; [1; 66; 99]]
# prepend "+" [["hello";"world"];["goodbye"]];;
- : string list list = [["+"; "hello"; "world"]; ["+"; "goodbye"]]
</pre>
</div>

	</li>


	<li>
	  <p>Code a function <tt class="code">prefixes</tt> of
	    type <tt class="code">'a list -> 'a list list</tt>
	    where <tt>prefixes xs</tt> returns the list of all
	    prefixes of <tt>xs</tt>: if 
	    <tt>xs</tt> is <tt>[x1; x2; x3]</tt> then the prefixes
	    of <tt>xs</tt> are <tt>[]</tt>, <tt>[x1]</tt>, <tt>[x1;
	    x2]</tt>, and <tt>[x1; x2; x3]</tt>. (Note that the empty 
	    list is a prefix of every list.)</p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# prefixes [];;
- : 'a list list = [[]]
# prefixes [1];;
- : int list list = [[]; [1]]
# prefixes [1;2;3;4];;
- : int list list = [[]; [1]; [1; 2]; [1; 2; 3]; [1; 2; 3; 4]]
# prefixes ["a";"b"];;
- : string list list = [[]; ["a"]; ["a"; "b"]]
</pre>
</div>

	</li>

	<li>
	  <p>Code a function <tt class="code">inject</tt> of
	    type <tt class="code">'a -> 'a list -> 'a list list</tt>
	    where <tt>inject a xs</tt> returns all the ways in which value 
	    <tt>a</tt> can be added to the list <tt>xs</tt>. </p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# inject 99 [];;
- : int list list = [[99]]
# inject 99 [1];;
- : int list list = [[99; 1]; [1; 99]]
# inject 99 [1;2];;
- : int list list = [[99; 1; 2]; [1; 99; 2]; [1; 2; 99]]
# inject 99 [1;2;3;4];;
- : int list list =
[[99; 1; 2; 3; 4]; [1; 99; 2; 3; 4]; [1; 2; 99; 3; 4]; [1; 2; 3; 99; 4]; 
 [1; 2; 3; 4; 99]]
# inject "X" ["a";"b"];;
- : string list list = [["X"; "a"; "b"]; ["a"; "X"; "b"]; ["a"; "b"; "X"]]
</pre>
	  </div>
	  <p><i> This is probably the most difficult question on all
	      the homeworks until now. The easiest way to do it is to
	      use two <tt>fold_right</tt>, one to augment the original list
	      with extra information, and the other to compute the
	      actual result of <tt>inject</tt>.I'll let you figure
	      out what extra information you might need. </i>
	  </p>

	</li>


	  <li><b>(Bonus question if you thought <tt>inject</tt> was
	  too easy &mdash; worth absolutely zero points!)</b>

	  <p>Code a function <tt class="code">permutations</tt> of type
	  <tt class="code">'a list -> 'a list list</tt> where <tt>permutations
	    xs</tt> returns the list of all permutations
	    of <tt>xs</tt>. A permutation of a list is a list
	    containing the exact same elements, but in a different
	  order, treating repeated elements as distinct. <b>Hint:</b> use <tt>inject</tt>.</p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# permutations [];;
- : 'a list list = [[]]
# permutations [1];;
- : int list list = [[1]]
# permutations [1;2];;
- : int list list = [[1; 2]; [2; 1]]
# permutations [1;2;3;4];;
- : int list list =
[[1; 2; 3; 4]; [2; 1; 3; 4]; [2; 3; 1; 4]; [2; 3; 4; 1]; [1; 3; 2; 4];
 [3; 1; 2; 4]; [3; 2; 1; 4]; [3; 2; 4; 1]; [1; 3; 4; 2]; [3; 1; 4; 2];
 [3; 4; 1; 2]; [3; 4; 2; 1]; [1; 2; 4; 3]; [2; 1; 4; 3]; [2; 4; 1; 3];
 [2; 4; 3; 1]; [1; 4; 2; 3]; [4; 1; 2; 3]; [4; 2; 1; 3]; [4; 2; 3; 1];
 [1; 4; 3; 2]; [4; 1; 3; 2]; [4; 3; 1; 2]; [4; 3; 2; 1]]
# permutations ["a";"b"];;
- : string list list = [["a"; "b"]; ["b"; "a"]]
</pre>
	  </div>
	</li>






	</ol>

      </li>


      <li> <p><b>Implementing Turing Machines</b></p>

	<ol class="subquestion">

	  <li> 
	    <p>
	      Code a function <tt class="code">startConfig</tt> with
	      type <tt class="code">'a tm -> string -> 'a config</tt> 
	      where <tt>startConfig m w</tt> returns the starting
	      configuration for Turing machine <tt>m</tt>
	      with <tt>w</tt> as input string.
	    </p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# startConfig asbs "";;
- : string config = {state = "start"; tape = [">"]; position = 0}
# startConfig asbs "ab";;
- : string config = {state = "start"; tape = [">"; "a"; "b"]; position = 0}
# startConfig asbs "aaabbbaa";;
- : string config = {state = "start"; tape = [">"; "a"; "a"; "a"; "b"; "b"; "b"; "a"; "a"];
                     position = 0}
# startConfig anbn "";;
- : string config = {state = "start"; tape = ["|"]; position = 0}
# startConfig anbn "aabb";;
- : string config = {state = "start"; tape = ["|"; "a"; "a"; "b"; "b"]; position = 0}
# startConfig anbn "aabbaa";;;
- : string config = {state = "start"; tape = ["|"; "a"; "a"; "b"; "b"; "a"; "a"];
                     position = 0}
</pre>
</div>
	  </li>

	  <li> 
	    <p>
	      Code
  functions <tt class="code">acceptConfig</tt> and <tt class="code">rejectConfig</tt>
	      each of
	      type <tt class="code">'a tm -> 'a config -> bool</tt>
	      where <tt>acceptConfig m c</tt> 
  returns <tt>true</tt> if and only if <tt>c</tt> is an accepting
	      configuration for Turing machine 
	      <tt>m</tt>,
and
	      <tt>rejectConfig m c</tt> 
  returns <tt>true</tt> if and only if <tt>c</tt> is a rejecting
	      configuration for Turing machine 
	      <tt>m</tt>.
	    </p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# acceptConfig asbs {state="start"; tape=["_"]; position=0};;
- : bool = false
# acceptConfig asbs {state="q1"; tape=[">";"a";"_"]; position=0};;
- : bool = false
# acceptConfig asbs {state="acc"; tape=["b";">";"a";"_"]; position=1};;
- : bool = true
# acceptConfig asbs {state="rej"; tape=["b";">";"a";"_"]; position=1};;
- : bool = false
# rejectConfig asbs {state="start"; tape=["_"]; position=0};;
- : bool = false
# rejectConfig asbs {state="q1"; tape=[">";"a";"_"]; position=0};;
- : bool = false
# rejectConfig asbs {state="acc"; tape=["b";">";"a";"_"]; position=1};;
- : bool = false
# rejectConfig asbs {state="rej"; tape=["b";">";"a";"_"]; position=1};;
- : bool = true
</pre>
</div>
	  </li>

	  <li>
	    <p>Code a function <tt class="code">replace_nth</tt> with
	      type <tt class="code">'a list -> int -> 'a -> 'a list</tt>
	      where <tt>replace_nth xs n x</tt> returns a new
	      list which looks just like <tt>xs</tt> except the
	      element in <tt>n</tt><sup>th</sup> position
	      is <tt>x</tt>. (The first element of the list is at
	      position 0.)</p>

	    <p>If <tt>n</tt> is not a valid position in the list, the list should be returned unchanged.</p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# replace_nth [] 0 "x";;
- : string list = []
# replace_nth ["a";"b";"c";"d"] 0 "x";;
- : string list = ["x"; "b"; "c"; "d"]
# replace_nth ["a";"b";"c";"d"] 1 "x";;
- : string list = ["a"; "x"; "c"; "d"]
# replace_nth ["a";"b";"c";"d"] 2 "x";;
- : string list = ["a"; "b"; "x"; "d"]
# replace_nth ["a";"b";"c";"d"] 3 "x";;
- : string list = ["a"; "b"; "c"; "x"]
# replace_nth [1;2;3;4] 1 99;;
- : int list = [1; 99; 3; 4]
</pre>
</div>
	  </li>

	  <li> 
	    <p>
	      Code a function <tt class="code">step</tt> with type
	      <tt class="code">'a tm -> 'a config -> 'a config</tt>
	      where <tt>step m c</tt> returns the configuration 
	      obtained by taking one step of Turing machine <tt>m</tt> from
	      configuration <tt>c</tt>. 
	      Function <tt>step m</tt> is basically the relation
	      <tt>C &#8594; D</tt> described in lecture.</p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# step asbs {state="start"; tape=["_"]; position=0};;
- : string config = {state = "acc"; tape = ["_"; "_"]; position = 1}
# step asbs {state="start"; tape=[">";"a";"b";"b"]; position=2};;
- : string config = {state = "q1"; tape = [">"; "a"; "b"; "b"]; position = 3}
# step asbs {state="q1"; tape=[">";"a";"a";"b"]; position=2};;
- : string config = {state = "rej"; tape = [">"; "a"; "a"; "b"]; position = 3}
# step asbs {state="q1"; tape=[">";"a";"b";"b"]; position=2};;
- : string config = {state = "q1"; tape = [">"; "a"; "b"; "b"]; position = 3}
# step anbn {state="q1"; tape=["|";"a";"b";"/"]; position=3};;
- : string config = {state = "q2"; tape = ["|"; "a"; "b"; "/"; "/"]; position = 4}
# step anbn {state="q2"; tape=["|";"a";"b";"/"]; position=3};;
- : string config = {state = "q2"; tape = ["|"; "a"; "b"; "/"]; position = 2}
# step anbn {state="q3"; tape=["|";"a";"b"]; position=1};;
- : string config = {state = "q4"; tape = ["|"; "X"; "b"]; position = 2}
# step anbn {state="q4"; tape=["|";"X";"b"]; position=2};;
- : string config = {state = "q2"; tape = ["|"; "X"; "X"; "/"]; position = 3}
</pre>
</div>
	  </li>


	  <li> 
	    <p>
	      Code a function <tt class="code">run</tt> with type
	      <tt class="code">string tm -> string -> bool</tt>
	      where <tt>run m w</tt> returns <tt>true</tt>
	      if <tt>m</tt> (which should be a Turing machine where 
	      states are described using strings) accepts input string
	      <tt>w</tt>, and returns <tt>false</tt> if <tt>m</tt>
	      rejects input string <tt>w</tt>. The 
	      function should, as a side effect, also print the sequence of
	      configurations that Turing machine <tt>m</tt> goes
	      through during its computation. This is going to help you debug your Turing machines in the following questions.
	    </p>

	    <p>
	      I provided you with a function <tt>printConfig</tt> to
	      print a 
	      configuration, which takes the configuration to print
	      and also a value 
	      for <tt>printConfig</tt> to return. Thus,
	      <tt>printConfig c v</tt> will 
	      print configuration <tt>c</tt> and return
	      value <tt>v</tt>.  
	    </p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# run asbs "aab";;
start  [>] a  a  b 
start   > [a] a  b 
start   >  a [a] b 
start   >  a  a [b]
q1      >  a  a  b [_]
acc     >  a  a  b  _ [_]
- : bool = true
# run anbn "aabb";;
start  [|] a  a  b  b 
start   | [a] a  b  b 
start   |  a [a] b  b 
start   |  a  a [b] b 
q1      |  a  a  b [b]
q1      |  a  a  b  b [/]
q2      |  a  a  b  b  / [/]
q2      |  a  a  b  b [/] / 
q2      |  a  a  b [b] /  / 
q2      |  a  a [b] b  /  / 
q2      |  a [a] b  b  /  / 
q2      | [a] a  b  b  /  / 
q2     [|] a  a  b  b  /  / 
q3      | [a] a  b  b  /  / 
q4      |  X [a] b  b  /  / 
q4      |  X  a [b] b  /  / 
q2      |  X  a  X [b] /  / 
q2      |  X  a [X] b  /  / 
q2      |  X [a] X  b  /  / 
q2      | [X] a  X  b  /  / 
q2     [|] X  a  X  b  /  / 
q3      | [X] a  X  b  /  / 
q3      |  X [a] X  b  /  / 
q4      |  X  X [X] b  /  / 
q4      |  X  X  X [b] /  / 
q2      |  X  X  X  X [/] / 
q2      |  X  X  X [X] /  / 
q2      |  X  X [X] X  /  / 
q2      |  X [X] X  X  /  / 
q2      | [X] X  X  X  /  / 
q2     [|] X  X  X  X  /  / 
q3      | [X] X  X  X  /  / 
q3      |  X [X] X  X  /  / 
q3      |  X  X [X] X  /  / 
q3      |  X  X  X [X] /  / 
q3      |  X  X  X  X [/] / 
acc     |  X  X  X  X  / [/]
- : bool = true
# run anbncn "aabbcc";;
start  [>] a  a  b  b  c  c 
start   > [a] a  b  b  c  c 
start   >  a [a] b  b  c  c 
start   >  a  a [b] b  c  c 
q1      >  a  a  b [b] c  c 
q1      >  a  a  b  b [c] c 
q6      >  a  a  b  b  c [c]
q6      >  a  a  b  b  c  c [_]
q2      >  a  a  b  b  c  c  _ [_]
q2      >  a  a  b  b  c  c [_] _ 
q2      >  a  a  b  b  c [c] _  _ 
q2      >  a  a  b  b [c] c  _  _ 
q2      >  a  a  b [b] c  c  _  _ 
q2      >  a  a [b] b  c  c  _  _ 
q2      >  a [a] b  b  c  c  _  _ 
q2      > [a] a  b  b  c  c  _  _ 
q2     [>] a  a  b  b  c  c  _  _ 
q3      > [a] a  b  b  c  c  _  _ 
q4      >  X [a] b  b  c  c  _  _ 
q4      >  X  a [b] b  c  c  _  _ 
q5      >  X  a  X [b] c  c  _  _ 
q5      >  X  a  X  b [c] c  _  _ 
q2      >  X  a  X  b  X [c] _  _ 
q2      >  X  a  X  b [X] c  _  _ 
q2      >  X  a  X [b] X  c  _  _ 
q2      >  X  a [X] b  X  c  _  _ 
q2      >  X [a] X  b  X  c  _  _ 
q2      > [X] a  X  b  X  c  _  _ 
q2     [>] X  a  X  b  X  c  _  _ 
q3      > [X] a  X  b  X  c  _  _ 
q3      >  X [a] X  b  X  c  _  _ 
q4      >  X  X [X] b  X  c  _  _ 
q4      >  X  X  X [b] X  c  _  _ 
q5      >  X  X  X  X [X] c  _  _ 
q5      >  X  X  X  X  X [c] _  _ 
q2      >  X  X  X  X  X  X [_] _ 
q2      >  X  X  X  X  X [X] _  _ 
q2      >  X  X  X  X [X] X  _  _ 
q2      >  X  X  X [X] X  X  _  _ 
q2      >  X  X [X] X  X  X  _  _ 
q2      >  X [X] X  X  X  X  _  _ 
q2      > [X] X  X  X  X  X  _  _ 
q2     [>] X  X  X  X  X  X  _  _ 
q3      > [X] X  X  X  X  X  _  _ 
q3      >  X [X] X  X  X  X  _  _ 
q3      >  X  X [X] X  X  X  _  _ 
q3      >  X  X  X [X] X  X  _  _ 
q3      >  X  X  X  X [X] X  _  _ 
q3      >  X  X  X  X  X [X] _  _ 
q3      >  X  X  X  X  X  X [_] _ 
acc     >  X  X  X  X  X  X  _ [_]
- : bool = true
# run anbn "aabbbb";;
start  [|] a  a  b  b  b  b 
start   | [a] a  b  b  b  b 
start   |  a [a] b  b  b  b 
start   |  a  a [b] b  b  b 
q1      |  a  a  b [b] b  b 
q1      |  a  a  b  b [b] b 
q1      |  a  a  b  b  b [b]
q1      |  a  a  b  b  b  b [/]
q2      |  a  a  b  b  b  b  / [/]
q2      |  a  a  b  b  b  b [/] / 
q2      |  a  a  b  b  b [b] /  / 
q2      |  a  a  b  b [b] b  /  / 
q2      |  a  a  b [b] b  b  /  / 
q2      |  a  a [b] b  b  b  /  / 
q2      |  a [a] b  b  b  b  /  / 
q2      | [a] a  b  b  b  b  /  / 
q2     [|] a  a  b  b  b  b  /  / 
q3      | [a] a  b  b  b  b  /  / 
q4      |  X [a] b  b  b  b  /  / 
q4      |  X  a [b] b  b  b  /  / 
q2      |  X  a  X [b] b  b  /  / 
q2      |  X  a [X] b  b  b  /  / 
q2      |  X [a] X  b  b  b  /  / 
q2      | [X] a  X  b  b  b  /  / 
q2     [|] X  a  X  b  b  b  /  / 
q3      | [X] a  X  b  b  b  /  / 
q3      |  X [a] X  b  b  b  /  / 
q4      |  X  X [X] b  b  b  /  / 
q4      |  X  X  X [b] b  b  /  / 
q2      |  X  X  X  X [b] b  /  / 
q2      |  X  X  X [X] b  b  /  / 
q2      |  X  X [X] X  b  b  /  / 
q2      |  X [X] X  X  b  b  /  / 
q2      | [X] X  X  X  b  b  /  / 
q2     [|] X  X  X  X  b  b  /  / 
q3      | [X] X  X  X  b  b  /  / 
q3      |  X [X] X  X  b  b  /  / 
q3      |  X  X [X] X  b  b  /  / 
q3      |  X  X  X [X] b  b  /  / 
q3      |  X  X  X  X [b] b  /  / 
rej     |  X  X  X  X  b [b] /  / 
- : bool = false
</pre>
</div>
	  </li>

	</ol>

      </li>




      <li> <p><b>Designing Turing Machines</b></p>

        <p>In this question and the next, I will ask you to design Turing
	  machines. You can test your Turing machines
	  with the code you wrote in Question 2. Because of the type
	  of <tt>run</tt> requires Turing machines with states as
	  strings (so that they can be printed out during execution
	  for ease of debugging!), the machines in this question and
	  the next should be of type <tt>string tm</tt> </p>

	<p>For submission purposes, I ask you to define those Turing
	  machines as constants using <tt>let</tt> with a fixed
	  name given below in each question. There is already a
	  placeholder in <tt>homework4.ml</tt> for those answers. Just
	  replace the placeholder with your definition.</p>

	<ol class="subquestion">

	  <li><p>
	      Design a Turing machine
	      <tt class="code">tm_q3_a</tt> that decides
	      the language consisting of all strings over the
	      alphabet <tt>{c,d}</tt> of the
	      form <tt>c<sup>n</sup>d<sup>2n</sup></tt> for any n&ge;0.
	    </p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
(* This sample output does not show traces *)

# run tm_q3_a "";;
start  [>]
- : bool = true
# run tm_q3_a "cdd";;
start  [>] c  d  d
- : bool = true
# run tm_q3_a "ccdddd";;
start  [>] c  c  d  d  d  d
- : bool = true
# run tm_q3_a "cccdddddd";;
start  [>] c  c  c  d  d  d  d  d  d
- : bool = true
# run tm_q3_a "c";;
start  [>] c 
- : bool = false
# run tm_q3_a "cd";;
start  [>] c  d 
- : bool = false
# run tm_q3_a "cddd";;
start  [>] c  d  d d
- : bool = false
# run tm_q3_a "ccddddd";;
start  [>] c  c  d  d  d  d  d
- : bool = false
# run tm_q3_a "dd";;
start  [>] d  d 
- : bool = false
# run tm_q3_a "dcc";;
start  [>] d  c  c
- : bool = false
</pre>
</div>
	  </li>

	  <li>

	    <p>
	      Design a Turing machine <tt class="code">tm_q3_b</tt>
	      that decides
	      the language over alphabet <tt>{c,d}</tt> consisting of
	      all strings of 
	      even length with the property that the two middle
	      symbols of the string are the same (i.e., for all
	      strings <i>w</i>=<i>a<sub>1</sub>a<sub>2</sub>...a<sub>2n</sub></i> of length <i>2n</i> we
	      have <i>a<sub>n</sub></i> = <i>a<sub>n+1</sub></i>).
	    </p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
  <pre class="code">
(* This sample output does not show traces *)

# run tm_q3_b "cc";;
start  [>] c  c
- : bool = true
# run tm_q3_b "dd";;
start  [>] d  d
- : bool = true
# run tm_q3_b "cccd";;
start  [>] c  c  c  d 
- : bool = true
# run tm_q3_b "cdddcd";;
start  [>] c  d  d  d  c  d
- : bool = true
# run tm_q3_b "cccccddd";;
start  [>] c  c  c  c  c  d  d  d 
- : bool = true
# run tm_q3_b "dcdcdddccc";;
start  [>] d  c  d  c  d  d  d  c  c  c
- : bool = true
# run tm_q3_b "";;
start  [>] 
- : bool = false
# run tm_q3_b "c";;
start  [>] c 
- : bool = false
# run tm_q3_b "dcd";;
start  [>] d  c  d
- : bool = false
# run tm_q3_b "dcdd";;
start  [>] d  c  d  d
- : bool = false
# run tm_q3_b "cdcddcd";;
start  [>] c  d  c  d  d  c  d
- : bool = false
# run tm_q3_b "cdcdcdcd";;
start  [>] c  d  c  d  c  d  c  d
- : bool = false
</pre>
</div>	      
	  </li>

	</ol>


      </li>

      <li> <p><b>Boolean Operations</b></p>

	<ol class="subquestion">

	  <li>
	    <p>
	      Consider the language <i>NOT</i> of all strings over
	      an alphabet {0,1,#} of the
	      form <tt><i>u</i>#<i>v</i></tt>, where 
	      <i>u</i> and <i>v</i> are nonempty strings over {0,1}
	      all of the same length such that <i>v</i> is the
	      pointwise <i>not</i> of <i>u:</i> if
	      the <i>i<sup>th</sup></i> bit of <i>u</i> is <i>b</i> then the
	      <i>i<sup>th</sup></i> bit of <i>v</i> is <i>&not;b</i>,
	      where &not;0 is 1 and &not;1 is 0.</p>

	  <p>Design a Turing machine <tt class="code">tm_q4_not</tt>
	    deciding language <i>NOT</i>. </p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
(* This sample output does not show traces *)

# run tm_q4_not "0#1";;
start  [>] 0  #  1
- : bool = true
# run tm_q4_not "000#111";;
start  [>] 0  0  0  #  1  1  1
- : bool = true
# run tm_q4_not "010#101";;
start  [>] 0  1  0  #  1  0  1
- : bool = true
# run tm_q4_not "010101#101010";;
start  [>] 0  1  0  1  0  1  #  1  0  1  0  1  0
- : bool = true
# run tm_q4_not "000111000#111000111";;
start  [>] 0  0  0  1  1  1  0  0  0  #  1  1  1  0  0  0  1  1  1
- : bool = true
# run tm_q4_not "0#1#01";;
start  [>] 0  #  1  #  0
- : bool = false
# run tm_q4_not "0#11";;
start  [>] 0  #  1  1
- : bool = false
# run tm_q4_not "00#1";;
start  [>] 0  0  #  1
- : bool = false
# run tm_q4_not "1#1";;
start  [>] 1  #  1
- : bool = false
# run tm_q4_not "0#0";;
start  [>] 0  #  0
- : bool = false
# run tm_q4_not "010#100";;
start  [>] 0  1  0  #  1  0  0
- : bool = false
# run tm_q4_not "010#001";;
start  [>] 0  1  0  #  0  0  1
- : bool = false
</pre>
</div>
	  </li>


	  <li>
	    <p>
	      Consider the language <i>AND</i> of all strings over
	      an alphabet {0,1,#} of the
	      form <tt><i>u</i>#<i>v</i>#<i>w</i></tt>, where 
	      <i>u</i>, <i>v</i>, and <i>w</i> are nonempty strings over {0,1}
	      all of the same length such that <i>w</i> is the
	      pointwise <i>and</i> of <i>u</i> and <i>v:</i> if
	      the <i>i<sup>th</sup></i> bit of <i>u</i>
	      is <i>b<sub>1</sub></i> and
	      the <i>i<sup>th</sup></i> bit of <i>v</i>
	      is <i>b<sub>2</sub></i> then the
	      <i>i<sup>th</sup></i> bit of <i>w</i>
	      is <i>b<sub>1</sub></i> &and; <i>b<sub>2</sub></i>,
	      where <i>x</i> &and; <i>y</i> is 1 when both <i>x</i>
	      and <i>y</i> are 1, and 0 otherwise.</p>

	  <p>Design a Turing machine <tt class="code">tm_q4_and</tt>
	    deciding language <i>AND</i>. </p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
(* This sample output does not show traces *)

# run tm_q4_and "0#0#0";;
start  [>] 0  #  0  #  0
- : bool = true
# run tm_q4_and "0#1#0";;
start  [>] 0  #  1  #  0
- : bool = true
# run tm_q4_and "1#0#0";;
start  [>] 1  #  0  #  0
- : bool = true
# run tm_q4_and "1#1#1";;
start  [>] 1  #  1  #  1
- : bool = true
# run tm_q4_and "101#010#000";;
start  [>] 1  0  1  #  0  1  0  #  0  0  0
- : bool = true
# run tm_q4_and "1110#0111#0110";;
start  [>] 1  1  1  0  #  0  1  1  1  #  0  1  1  0
- : bool = true
# run tm_q4_and "0#0"
start  [>] 0  #  0
- : bool = false
# run tm_q4_and "0#01#1"
start  [>] 0  #  0  1  #  1
- : bool = false
# run tm_q4_and "00#11#11"
start  [>] 0  0  #  1  1  #  1  1
- : bool = false
# run tm_q4_and "001#001#000"
start  [>] 0  0  1  #  0  0  1  #  0  0  0
- : bool = false
# run tm_q4_and "001#001#011"
start  [>] 0  0  1  #  0  0  1  #  0  1  1
- : bool = false
</pre>
</div>
	  </li>

	</ol>


      </li>

    </ol>
	
    

  </body>
</html>

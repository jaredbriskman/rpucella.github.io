<html>

<body>
<pre>

(* Question 1 *)

let rec expt a b = 
  if b &lt; 0 then failwith "expt: incorrect arguments"
  else if b = 0 then 1
  else a * (expt a (b -1))

let rec fastexpt a b = 
  if b &lt; 0 then failwith "fastexpt: incorrect arguments"
  else if b = 0 then 1
  else if b mod 2 = 0 then let x = fastexpt a (b/2) in x * x
  else a * fastexpt a (b-1)

(* cf: https://en.wikipedia.org/wiki/Tetration *)
let rec tetra a b =
  if b &lt; 0 then failwith "tetra: incorrect arguments"
  else if b = 0 then 1
  else expt a (tetra a (b-1))
  
let rec choose n k =
  (* how to choose k distinct elements out of n *)
  if k &lt; 0 || k > n || n &lt; 0 then failwith "choose: incorrect arguments"
  else if k = 0 || k = n then 1
  else choose (n-1) (k-1) + choose (n-1) k 



(* Question 2 *)

let rec doubleUp xs =
  match xs with
  | [] -> []
  | x::xs' -> x::(x::(doubleUp xs'))

let rec everyOther xs =
  match xs with
  | [] -> []
  | [x] -> [x]
  | x1::x2::xs' -> x1::(everyOther xs')

let rec concatenate xs ys =
   match xs with
   | [] -> ys
   | x::xs' -> x::(concatenate xs' ys)

let rec concatenateAll xss =
   match xss with
   | [] -> []
   | xs::xss' -> concatenate xs (concatenateAll xss')

let rec nth n xs =
   match xs with
   | [] -> failwith "nth: incorrect arguments"
   | x::xs' -> if n = 0 then x else nth (n-1) xs'

let rec last xs = 
  match xs with
  | [] -> failwith "last: incorrect arguments"
  | [x] -> x
  | x::xs' -> last xs'


(* QUESTION 3 *)

let rec addV v w =
  match v with
  | [] -> []
  | x::xs -> (match w with
              | [] -> []
	      | y::ys -> (x+y)::(addV xs ys))

let rec scaleV a v =
  match v with
  | [] -> []
  | x::xs -> (a*x)::(scaleV a xs)

let rec inner v w =
  match v with
  | [] -> 0
  | x::xs -> (match w with
    	      | [] -> 0
	      | y::ys -> (x*y)+(inner xs ys))

let rec outer v w =
  match v with
  | [] -> []
  | x::xs -> (scaleV x w)::(outer xs w)


(* QUESTION 4 *)

let rec addM m n =
  match m with
  | [] -> []
  | x::xs -> (match n with
              | [] -> []
	      | y::ys -> (addV x y)::(addM xs ys))

let rec scaleM a m =
  match m with
  | [] -> []
  | x::xs -> (scaleV a x)::(scaleM a xs)


let rec mult1M v m = 
  match v with
  | [] -> []
  | x::xs -> (match m with
              | [] -> []   (* shouldn't happen *)
              | [ys] -> scaleV x ys
              | ys::yss -> addV (scaleV x ys) (mult1M xs yss))


let rec multM m n = 
  match m with 
  | [] -> []
  | xs::xss -> (mult1M xs n)::(multM xss n)



</pre>
</body>

</html>

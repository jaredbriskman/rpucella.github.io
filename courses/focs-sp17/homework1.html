<!DOCTYPE html>
<html>

  <head>
    
    <meta charset="utf-8">
    <title>Homework 1</title>

    <link rel="stylesheet" href="alt.css" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,800,700' rel='stylesheet' type='text/css'>

    <script src="autoscroll.js"></script>
    
    <style>

      hr { margin-top: 50px; }

        code,tt,pre {
          font-size: 110%;
        }
	
        div.lect {
	  padding-top: 0;
       	  padding-left: 3em;
	  margin-top:0;
        }
    	p.ann { 
    	  padding-left: 3em;
    	  text-indent: -3em; 
    	}
	p.ann_ctd{
	  padding-left: 3em;
        }
    	span.hdr {
   	  padding-right: 1em
    	}

	.hidden {
	  visibility: hidden;
        }

        tt.code {
           background: #e6e6e6;
        }

	pre.code {
	   border: 1px solid #c6c6c6;
	border-radius: 5px;
	padding: 10px;
	font-size:100%;
	}

ol.question {
    padding-top:1em;
    list-style-type: decimal;
}

ol.subquestion {
    list-style-type: upper-alpha;
}


ol > li {
    padding:4px 8px; /* Add some spacing around the content */
}

li ol,
li ul {margin-top:6px;}

li > p { margin-top:0;}

    </style>

  </head>


  <body>

    <div class="navbar">

      <div class="home">
	<a href="../../index.html"><img src="../../home.png" style="height: 1.6em;"></a>
      </div>

      <ul>
	<li><a href="index.html"><b>Foundations of Computer Science SP17</b></a></li> 
	<li class="hidden"><a class="scrollto" href="#announcements">Announcements</a></li>
	<li class="hidden"><a class="scrollto" href="#info">Course Info</a></li>
	<li class="hidden"><a class="scrollto" href="#lectures">Lectures</a></li>
	<li class="hidden"><a class="scrollto" href="#homeworks">Homeworks</a></li>
      </ul>
    </div>


    <!-- padding -->
    <div id="top" style="height: 5em;"></div>
    
    <h1 class="clear">Homework 1</h1>
    
    <p class="subtitle">Due date: Thursday, Jan 26 (23:59)</p>

    <p><b>Note on integrity:</b> This homework is meant to be done
    individually. You may discuss problems with fellow students, but
    all work must be entirely your own, and should not be from any
    other course, present, past, or future. If you use a solution from
    another source you must cite it &mdash; this includes when that source
      is someone else helping you.</p>

    <p>Every source file you submit should begin with a block comment
      that lists your <span style="text-decoration:underline;">name</span>, your <span style="text-decoration:underline;">email address</span>, and any <span style="text-decoration:underline;">remarks</span> that you
      wish to make to the instructor.</p>

    <p>All programming is to be done in OCaml v4.</p>

    <p>Feel free to define helper functions if you need them.</p>

    <p>Please code your answers by modifying the
      file <a href="homework1.ml"><tt>homework1.ml</tt></a> provided.</p>

    <p>Electronic submission instructions:</p>

    <ul>
      <li>Download the file <a href="hw1-checker.ml"><tt>hw1-checker.ml</tt></a> into the same directory as your homework solution.</li>
      <li>Start a <i>new</i> OCaml shell.</li>
      <li>Load your homework code via <tt>#use "homework1.ml";;</tt></li>
      <li>Load the homework checker via <tt>#use "hw1-checker.ml";;</tt></li>
      <li>The homework checker checks that you've implemented all functions (or provided stubs for them) and that those functions have the type that I asked you to give them. If the checker says your types are OK, then you're fine. If the checker gives you an error, fix it. If you believe that the checker gives you an error wrongly, send me an email.</li>
      <li>When you're ready to submit, send an email with your file <tt>homework1.ml</tt> as an attachment to <tt>focs.sp17@gmail.com</tt> with subject <i>Homework 1 submission</i>.</li>
    </ul>

    <hr>
    
    <ol class="question">
      <li> <p><b>Numerical functions</b></p>

	<p>The functions below are all recursive over the integers. Most of these functions are only defined when some of their arguments are positive. I don't care what you do when the arguments are outside the domain of definition. You can either raise an exception (via <tt>failwith <i>string</i></tt>) or return a default value.</p>


	<ol class="subquestion">

	  <li> <p>Code a recursive function <tt class="code">expt</tt> of
	      type <tt class="code">int -> int -> int</tt>
	      where <tt>expt <i>a</i> <i>b</i></tt>
	      returns <tt><i>a</i><sup><i>b</i></sup></tt>.</p>

	    <p>The function is
	      defined only when <tt><i>b</i></tt> &geq; 0. Use the
	      fact that <tt><i>a</i><sup><i>b</i></sup></tt>
	      = <tt><i>a</i>&middot;<i>a</i><sup><i>b</i>-1</sup></tt>
	      when <tt><i>b</i></tt> &geq; 1.  </p>
	    
	    <pre class="code">
# expt 1 0;;
- : int = 1
# expt 1 3;;
- : int = 1
# expt 2 0;;
- : int = 1
# expt 2 1;;
- : int = 2
# expt 2 2;;
- : int = 4
# expt 2 3;;
- : int = 8
# expt 10 3;;
- : int = 1000</pre>
	  </li>

	  <li> <p>An alternative and faster way to compute an
	      exponential is to use the fact that
	      when <tt><i>b</i></tt> is even,
	      then <tt><i>a</i><sup><i>b</i></sup></tt> = <tt><i>X</i>&middot;<i>X</i></tt>
	      where <tt><i>X</i></tt>
	      = <tt><i>a</i><sup><i>b</i>/2</sup></tt>, and to use
	      <tt><i>a</i><sup><i>b</i></sup></tt>
	      = <tt><i>a</i>&middot;<i>a</i><sup><i>b</i>-1</sup></tt>
	      when <tt><i>b</i></tt> is odd.</p>

	    <p>Code a recursive function <tt class="code">fastexpt</tt> of
	      type <tt class="code">int -> int -> int</tt>
	      where <tt>fastexpt <i>a</i> <i>b</i></tt>
	      returns <tt><i>a</i><sup><i>b</i></sup></tt>, using the
	      speed-up above.</p>

<pre class="code">
# fastexpt 1 0;;
- : int = 1
# fastexpt 1 3;;
- : int = 1
# fastexpt 2 0;;
- : int = 1
# fastexpt 2 1;;
- : int = 2
# fastexpt 2 2;;
- : int = 4
# fastexpt 2 3;;
- : int = 8
# fastexpt 12 10;;
- : int = 61917364224</pre>

	  </li>

	  <li><p>Code a recursive function <tt class="code">tetra</tt> of type
	    <tt class="code">int -> int -> int</tt>
	    where <tt>tetra <i>a</i> <i>b</i></tt>
	    returns <tt><sup><i>b</i></sup><i>a</i></tt>,
	    the <a href="https://en.wikipedia.org/wiki/Tetration">tetration</a>
	    of <tt><i>a</i></tt> by <tt><i>b</i></tt>.</p>

<pre class="code">
# tetra 1 3;;
- : int = 1
# tetra 2 0;;
- : int = 1
# tetra 2 1;;
- : int = 2
# tetra 2 2;;
- : int = 4
# tetra 2 3;;
- : int = 16
# tetra 2 4;;
- : int = 65536
# tetra 3 1;;
- : int = 3
# tetra 3 2;;
- : int = 27
# tetra 3 3;;
- : int = 7625597484987</pre>	    

	  </li>


	  <li> <p>Code a recursive function <tt class="code">choose</tt> of type
	      <tt class="code">int -> int -> int</tt>
	      where <tt>choose <i>n</i> <i>k</i></tt>
	      returns <img src="binomial.svg" style="vertical-align:
	      -0.5em;">,
	      the <a href="https://en.wikipedia.org/wiki/Binomial_coefficient">binomial
		coefficient</a>. Recall that <tt>choose <i>n</i> <i>k</i></tt>
	      represents the number of ways one can
	      choose <tt><i>k</i></tt> distinct elements from a collection
	      of <tt><i>n</i></tt> elements.</p>

<pre class="code">
# choose 1 1;;
- : int = 1
# choose 2 1;;
- : int = 2
# choose 3 1;;
- : int = 3
# choose 10 2;;
- : int = 45
# choose 10 3;;
- : int = 120
# choose 10 4;;
- : int = 210
# choose 10 5;;
- : int = 252
# choose 10 6;;
- : int = 210</pre>

	  </li>
	</ol>
      </li>

      <li> <p><b>List functions</b></p>

	<p>All of the functions below can be written as recursive
	functions over lists. They all fit the general pattern of:
<pre>
   let rec f xs ... = match xs with
                        [] -> <i>e1</i>
                      | x::xs' -> <i>e2</i>
</pre>
where <tt><i>e2</i></tt> can use <tt>x</tt>, <tt>xs'</tt>, and the
recusive function itself. For some functions, you may need to do some
additional matching in <tt><i>e2</i></tt>, or you can add additional
patterns to the match to capture some special cases.</p>

	<ol class="subquestion">

	  <li><p>
	    Code a recursive function <tt class="code">doubleUp</tt> of
	    type <tt class="code">'a list -> 'a list</tt> which takes
	    a list <i>L</i> and returns a new list where every element <i>L</i>
	    is duplicated, so that <tt>doubleUp
		[1;2;3]</tt> returns <tt>[1;1;2;2;3;3]</tt>.</p>

<pre class="code">
# doubleUp [];;
- : 'a list = []
# doubleUp [1];;
- : int list = [1; 1]
# doubleUp [1;2];;
- : int list = [1; 1; 2; 2]
# doubleUp ["hello";"world";"greetings"];;
- : string list =
["hello"; "hello"; "world"; "world"; "greetings"; "greetings"]</pre>

	  </li>

	  <li><p>
	    Code a recursive function <tt class="code">everyOther</tt> of
	      type <tt class="code">'a list -> 'a list</tt> which
	    takes a list <i>L</i> and returns a list of every other
	    element of <i>L</i>, so that <tt>everyOther [1;2;3;4;5]</tt>
	    returns <tt>[1;3;5]</tt>. </p>

<pre class="code">
# everyOther [];;
- : 'a list = []
# everyOther [1];;
- : int list = [1]
# everyOther [1;2];;
- : int list = [1]
# everyOther [1;2;3];;
- : int list = [1; 3]
# everyOther [1;2;3;4];;
- : int list = [1; 3]
# everyOther [1;2;3;4;5];;
- : int list = [1; 3; 5]
# everyOther ["hello";"world";"greetings"];;
- : string list = ["hello"; "greetings"]</pre>
	  </li>


	  <li><p>
	    Code a recursive function <tt class="code">concatenate</tt> of
	      type <tt class="code">'a list -> 'a list -> 'a list</tt> which
	    takes two lists <i>L</i> and <i>M</i> and returns list
	    made up of all the element of <i>L</i> followed by all the
	    elements of <i>M</i>.</p>

<pre class="code">
# concatenate [] [];;
- : 'a list = []
# concatenate [] [1;2;3];;
- : int list = [1; 2; 3]
# concatenate [1;2;3] [];;
- : int list = [1; 2; 3]
# concatenate [1;2;3] [4;5;6];;
- : int list = [1; 2; 3; 4; 5; 6]</pre>
	  </li>


	  <li><p>
	    Code a recursive function <tt class="code">concatenateAll</tt> of
	      type <tt class="code">'a list list -> 'a list</tt> which
	    takes a list of lists <i>LL</i> and returns a list made up
	    of all the elements of all the lists in <i>LL</i>, in
	    the order in which they appear in <i>LL</i>.</p>

<pre class="code">
# concatenateAll [];;
- : 'a list = []
# concatenateAll [[]];;
- : 'a list = []
# concatenateAll [[1;2]];;
- : int list = [1; 2]
# concatenateAll [[1;2];[]];;
- : int list = [1; 2]
# concatenateAll [[1;2];[3;4]];;
- : int list = [1; 2; 3; 4]
# concatenateAll [[1;2];[3;4];[5;6;7]];;
- : int list = [1; 2; 3; 4; 5; 6; 7]
# concatenateAll [["hello"];[];["world";"greetings"]];;
- : string list = ["hello"; "world"; "greetings"]</pre>
	  </li>

	  <li><p>Code a recursive function <tt class="code">nth</tt> of
	    type <tt class="code">int -> 'a list -> 'a</tt> which
	      takes an integer <i>n</i> and a list <i>L</i> and 
	      returns the element at position <i>n</i> in
	      list <i>L</i>, where 0 is the position of the first
	      element. </p>

	    <p>If the index <i>n</i> is out of bounds, you can raise
	      an exception using <tt>failwith <i>string</i></tt>.</p>

<pre class="code">
# nth 0 ["a";"b";"c"];;
- : string = "a"
# nth 1 ["a";"b";"c"];;
- : string = "b"
# nth 2 ["a";"b";"c"];;
- : string = "c"
# nth 0 ["a";"b";"c"];;
- : string = "a"
</pre>

	  </li>


	  <li><p>
	    Code a function <tt class="code">last</tt> of
	    type <tt class="code">'a list -> 'a</tt> which returns the
	    last element of a list.</p>

	    <p>If the list is empty, then there is no last
	      element. You can raise an exception using <tt>failwith <i>string</i></tt>.</p>
<pre class="code">
# last [1];;
- : int = 1
# last [1;2];;
- : int = 2
# last [1;2;3;4;5;6;7;8];;
- : int = 8
# last ["a";"b";"c"];;
- : string = "c"</pre>
	  </li>



	</ol>
      </li>

      <li> <p><b>Vectors</b></p>

	<p>We can implement vectors as lists of integers. Operations
	on vectors such as addition or scalar multiplication can then
	  be implemented as recursive functions over lists.</p>

	<p>One difference from Question 2
	  is that you will sometimes have to recurse over two lists at
	  the same time, which means match over two
	  lists. One way to do so is to first match over the first list,
	  and then match over the second list in each case of the first
	  list (if applicable). For example:
<pre>
   let rec f xs ys = match xs with
                       [] -> <i>e1</i>
                     | x::xs' -> (match ys with
                                    [] -> <i>e2</i>
                                  | y::ys' -> <i>e3</i>)
</pre>
Another possibility is to match on both
	  lists at the same time, by treating them as pairs of
	  lists. For example:
<pre>
   let rec f xs ys = match (xs,ys) with
                       ([],[]) -> <i>e1</i>
                     | (x::xs',[]) -> <i>e2</i>
                     | ([],y::ys') -> <i>e3</i>
                     | (x::xs',y::ys') -> <i>e2</i>
</pre>
	</p>

	<p>Many of these functions only make sense if vector arguments have the
	same length. You can assume that your code will be given vectors of the same
	length. I'm only going to test your code with vectors of the
	same length. Still, you should probably make sure that your
	code does return a value in case vectors do not have the same
	length (I don't care what that 
	  value is), or raises an exception using <tt>failwith</tt>. 

	<ol class="subquestion">

	  <li><p>
	    Code a recursive function <tt class="code">addV</tt> of
	      type <tt class="code">int list -> int list -> int list</tt>
	    which takes two vectors <i>v<sub>1</sub></i>
	    and <i>v<sub>2</sub></i> and returns the vector
	    sum <i>v<sub>1</sub>+v<sub>2</sub></i>.</p>

<pre class="code">
# addV [] [];;
- : int list = []
# addV [10] [20];;
- : int list = [30]
# addV [10;20;30] [20;40;60];;
- : int list = [30; 60; 90]</pre>
	  </li>

	  <li><p>
	    Code a recursive function <tt class="code">scaleV</tt> of
	      type <tt class="code">int -> int list -> int list</tt>
	    which takes an integer <i>a</i> and a vector <i>v</i> and
	    computes the scalar multiplication <i>a v</i> (multiplying
	    every component of <i>v</i> by <i>a</i>).</p>

<pre class="code">
# scaleV 10 [];;
- : int list = []
# scaleV 0 [1;2;3];;
- : int list = [0; 0; 0]
# scaleV 1 [1;2;3];;
- : int list = [1; 2; 3]
# scaleV 2 [1;2;3];;
- : int list = [2; 4; 6]
# scaleV 10 [1;2;3];;
- : int list = [10; 20; 30]</pre>
	  </li>


	  <li><p>
	    Code a recursive function <tt class="code">inner</tt> of
	      type <tt class="code">int list -> int list -> int</tt>
	    which takes two vectors <i>v<sub>1</sub></i>
	    and <i>v<sub>2</sub></i> and returns the <a href="https://en.wikipedia.org/wiki/Dot_product">inner product</a>
	    <i>v<sub>1</sub> &middot; v<sub>2</sub></i>.</p>

<pre class="code">
# inner [] [];;
- : int = 0
# inner [10] [20];;
- : int = 200
# inner [1;2;3] [4;5;6];;
- : int = 32
# inner [1;2;3] [8;10;12];;
- : int = 64</pre>
	  </li>


	  <li><p>
	    Code a recursive function <tt class="code">outer</tt> of
	      type <tt class="code">int list -> int list -> int list list</tt>
	    which takes two vectors <i>v<sub>1</sub></i>
	    and <i>v<sub>2</sub></i> and returns the <a href="https://en.wikipedia.org/wiki/Outer_product">outer product</a>
	    <i>v<sub>1</sub> &otimes; v<sub>2</sub></i>.</p>

<p>Note that outer product of two vectors is a matrix. We represent a
  matrix by a list of lists, where each list is a row in the matrix,
  from top to bottom. For example,  <tt>[[1;0];[0;1]]</tt> is the
  identity 2x2 matrix. </p>


<pre class="code">
# outer [] [];;
- : int list list = []
# outer [10] [20];;
- : int list list = [[200]]
# outer [1;2;3] [4;5;6];;
- : int list list = [[4; 8; 12]; [5; 10; 15]; [6; 12; 18]]
# outer [1;2;3] [10; 100; 1000];;
- : int list list = [[10; 20; 30]; [100; 200; 300]; [1000; 2000; 3000]]</pre>
	  </li>

	</ol>
      </li>



      <li> <p><b>Matrices</b></p>

	<p>We can implement matrices as lists of lists of integers:
	one list per row, from top to bottom.  Operations
	on matrices such as addition or scalar multiplication can then
	  be implemented as recursive functions over lists, just like
	for vectors.</p>

	<p>Many of these functions only make sense if matrices have
	well-formed, meaning the same number of columns and the same
	number of rows. (Or compatible number of columns and rows in
	the case of matrix multiplication.) You can assume that your code will be given
	  well-formed matrices. I'm only going to test your code
	with well-formed matrices. Still, you should probably make
	sure that 
	your code does return a value if that's not the case (I don't
	care what that value is), or raises an exception
	using <tt>failwith</tt>.  


	<ol class="subquestion">

	  <li><p>
	    Code a recursive function <tt class="code">addM</tt> of
	      type <tt class="code">int list list -> int list list ->
	    int list list</tt>
	    which takes two matrices <i>M<sub>1</sub></i>
	    and <i>M<sub>2</sub></i> and returns the matrix
	    sum <i>M<sub>1</sub>+M<sub>2</sub></i>.</p>

<pre class="code">
# addM [] [];;
- : int list list = []
# addM [[1;2]] [[3;4]];;
- : int list list = [[4; 6]]
# addM [[1;2];[3;4]] [[10;20];[30;40]];;
- : int list list = [[11; 22]; [33; 44]]
# addM [[1;2];[3;4];[5;6]] [[10;20];[30;40];[50;60]];;
- : int list list = [[11; 22]; [33; 44]; [55; 66]]</pre>
	  </li>

	  <li><p>
	    Code a recursive function <tt class="code">scaleM</tt> of
	      type <tt class="code">int -> int list list -> int list list</tt>
	    which takes an integer <i>a</i> and a matrix <i>M</i> and
	    computes the scalar multiplication <i>a M</i> (multiplying
	    every component of <i>M</i> by <i>a</i>).</p>

<pre class="code">
# scaleM 10 [];;
- : int list list = []
# scaleM 10 [[1]];;
- : int list list = [[10]]
# scaleM 10 [[1;2];[3;4];[5;6]];;
- : int list list = [[10; 20]; [30; 40]; [50; 60]]</pre>
	  </li>


	  <li><p>
	    Code a recursive function <tt class="code">multM</tt> of
	      type <tt class="code">int list list -> int list list ->
	    int list list</tt>
	    which takes two matrices <i>M<sub>1</sub></i>
	    and <i>M<sub>2</sub></i> and returns the matrix
	    product <i>M<sub>1</sub> M<sub>2</sub></i>.</p>

	    <p>I trust you remember how to perform <a href="https://en.wikipedia.org/wiki/Matrix_multiplication">matrix
		multiplication</a>.</p>

	    <p><b>HINT:</b> The easiest way I know how to write this
	      function is to first define a helper
	      function <tt class="code">mult1M</tt> of
	      type <tt class="code">int list -> int list list -> int
		list</tt> that takes a <i>row</i> vector <i>v</i> and
	      a matrix <i>M</i> and computes the row vector <i>v M</i>.</p>

<pre class="code">
# multM [] [];;
- : int list list = []
# multM [[10]] [[20]];;
- : int list list = [[200]]
# multM [[1;0];[0;1]] [[1;2];[3;4]];;
- : int list list = [[1; 2]; [3; 4]]
# multM [[1;2];[3;4]] [[10;20];[30;40]];;
- : int list list = [[70; 100]; [150; 220]]
# multM [[1;2];[3;4];[5;6]] [[10;20];[30;40];[50;60]];;
- : int list list = [[]; []; []]</pre>
	  </li>

	</ol>
      </li>


    </ol>
	
    

  </body>
</html>

<!DOCTYPE html>
<html>

  <head>
    
    <meta charset="utf-8">
    <title>Homework 3</title>

    <link rel="stylesheet" href="alt.css" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,800,700' rel='stylesheet' type='text/css'>

    <script src="autoscroll.js"></script>
    
    <style>

      hr { margin-top: 50px; }

        code,tt,pre {
          font-size: 110%;
        }
	
        div.lect {
	  padding-top: 0;
       	  padding-left: 3em;
	  margin-top:0;
        }
    	p.ann { 
    	  padding-left: 3em;
    	  text-indent: -3em; 
    	}
	p.ann_ctd{
	  padding-left: 3em;
        }
    	span.hdr {
   	  padding-right: 1em
    	}

	.hidden {
	  visibility: hidden;
        }

        tt.code {
           font-weight: bold;
        }

      div.code {
      border: 1px solid #c6c6c6;
      border-radius: 5px;
      padding: 0px;
      margin-bottom: 20px;
      }
      
      div.code p {
      margin:0px;
      padding:5px 10px;
      background:#eeeeee;
      font-style: italic;
      cursor:pointer;
      }

      div.code p:hover {
      background:#cccccc;
      }

      div.code pre { 
      display:none;
      padding: 10px;
      font-size:100%;
      }

      div.code.visible pre  {
      display:block;
      }

ol.question {
    padding-top:1em;
    list-style-type: decimal;
}

ol.subquestion {
    list-style-type: upper-alpha;
}

      ol.question > li {
      font-weight: bold;
      }

      ol.question > li > * {
      font-weight: normal;
      }
      
ol > li {
    padding:4px 8px; /* Add some spacing around the content */
}

li ol,
li ul {margin-top:6px;}

li > p { margin-top:0;}
    </style>

    <script>
      function toggleShowHide (p) { 
      var div = p.parentNode;
        if (div.className && div.className.startsWith("visible")) {
          div.className = "code";
      } else {
        div.className = "visible code";
      }
      }
    </script>


  </head>


  <body>

    <div class="navbar">

      <div class="home">
	<a href="../../index.html"><img src="../../home.png" style="height: 1.6em;"></a>
      </div>

      <ul>
	<li><a href="index.html"><b>Programming Languages SP18</b></a></li> 
	<li class="hidden"><a class="scrollto" href="#announcements">Announcements</a></li>
	<li class="hidden"><a class="scrollto" href="#info">Course Info</a></li>
	<li class="hidden"><a class="scrollto" href="#lectures">Lectures</a></li>
	<li class="hidden"><a class="scrollto" href="#homeworks">Homeworks</a></li>
      </ul>
    </div>


    <!-- padding -->
    <div id="top" style="height: 5em;"></div>
    
    <h1 class="clear">Homework 3</h1>
    
    <p class="subtitle">Due date: Sunday, Feb 11 (23h59)</p>

    <p><b>Note on integrity:</b> This homework is meant to be done in
      <b>teams of 2</b>. You may discuss problems with fellow students, but all
    work must be entirely that of your team, and should not be from
    any other course, present, past, or future. If you use a solution
    from another source you must cite it &mdash; this includes when
    that source is someone else helping you. <b>Please do not post
    your code on a public website or a public repository like
    GitHub.</b>
   </p>

    <p>All programming is to be done in Scala v2.12.</p>

    <p>Code your answers by modifying the
      file <a href="homework3.scala"><tt>homework3.scala</tt></a> provided. Add the
      <span style="text-decoration:underline;">names of your team members</span>, your <span style="text-decoration:underline;">email addresses</span>, and any <span style="text-decoration:underline;">remarks</span> that you
      wish to make to the instructor to the block comment at the head of the file.</p>

    <p><b>Please do not change the types in the signature of the
	function and class stubs I provide</b>. Doing so will make it difficult to test your code.</p>

    <p>Feel free to define helper functions or helper classes if you need them.</p>

    <p>Electronic submission instructions:</p>

    <ul>
      <li>Run your homework code via <tt>scala homework3.scala</tt></li>
      <li>If there are any error, do not submit. I can't test what will not load correctly.</li>
      <li>When you're ready to submit, send an email with your file <tt>homework3.scala</tt> as an attachment to <tt>olin.submissions@gmail.com</tt> with subject <i>Homework 3 submission</i>.</li>
    </ul>

<!--
    <hr>

    <p class="subtitle">Updates</p>
    <ul class="simple">
    </ul>
-->
	

    <hr>






    <ol class="question">

      <p>The sample code I have supplied you comes with an abstract
      representation that supports integers, booleans, and vectors, as
      well as addition and multiplication of integers and vectors, as
      well as conjunction, conditionals, and both singular let
      bindings and simultaneous let bindings (of the kind we saw in
	homework 2). </p>

      <p>The code also includes a parser
      written using
      the <a href="https://github.com/scala/scala-parser-combinators">Scala
      Standard Parser Combinator Library</a> which implements the
      following grammar:
<pre>
  atomic ::=  <b>integer</b>
              <b>identifier</b>
              <b>true</b>
              <b>false</b>
  
  expr ::= atomic
           <b>(</b> <b>+</b> expr expr <b>)</b>
           <b>(</b> <b>*</b> expr expr <b>)</b>
           <b>(</b> <b>if</b> expr expr expr <b>)</b>
           <b>(</b> <b>let</b> <b>(</b> <b>(</b> <b>identifier</b> expr <b>)</b> <b>)</b> expr <b>)</b>
</pre>
As I did in class, tokens are in <b>bold</b>. The parser is implemented by
class <tt>SExpParser</tt>, and can be invoked by calling function <tt>parse</tt>.</p>



      <!-- ------------------------------------------------------------ -->


      <li> <p><b>Extending the S-expressions parser</b></p>

	<ol class="subquestion">

	  <!-- ------------------------------ -->

	  <li><p>Extend the parser so that it can parse the following
	  addition to the grammar above:
<pre>
  expr ::= ...
           <b>(</b> <b>and</b> expr expr <b>)</b>
</pre>
          An expression of
	  the form <tt>(and <i>e1</i> <i>e2</i>)</tt> should produce
	  an abstract
	  representation <tt>EAnd(<i>t1</i>,<i>t2</i>)</tt>,
	  where <tt><i>t1</i></tt> is the abstract representation
	      of <tt><i>e1</i></tt> and <tt><i>t2</i></tt> is the
	  abstract representation of <tt><i>e2</i></tt>. 
	    </p>
	  </li>


	  <li><p>Extend the parser so that it can parse the following
	  addition to the grammar above:
<pre>
  expr ::= ...
           <b>(</b> <b>vector</b> exprs <b>)</b>

  exprs ::= expr exprs
            expr
</pre>
          An expression of
	  the form <tt>(vector <i>e1</i> ... <i>en</i>)</tt> should produce
	  an abstract
	  representation <tt>EVector(List(<i>t1</i>,...,<i>tn</i>)</tt>,
	  where <tt><i>t1</i></tt> is the abstract representation
	      of <tt><i>e1</i></tt>, ..., and <tt><i>tn</i></tt> is the
	  abstract representation of <tt><i>en</i></tt>. 
	    </p>
	  </li>



	  <li><p>The Expression node <tt>ELetSim</tt>
	  in <tt>homework3.scala</tt> supports simultaneous bindings
	  as we saw in homework 2, but the parser right now can only handle a single binding, as in <tt>(let ((x 10)) <i>expr</i>)</tt>. </p>

	    <p>Extend the parser so that it can parse the following
	      version of <tt>let</tt> instead of the existing one:
<pre>
   expr ::= ... 
   <b>(</b> let <b>(</b> bindings <b>)</b> expr <b>)</b>

   bindings ::= <b>(</b> <b>identifier</b> expr <b>)</b> bindings
                <b>(</b> <b>identifier</b> expr <b>)</b>
</pre>
An expression of the form <tt>(let (<i>bindings</i>) <i>expr</i>)</tt>
should produce an abstract
representation <tt>ELetSim(<i>tbindings</i>,<i>t</i>)</tt>,
where <tt><i>tbindings</i></tt> is a list of pairs of identifiers and
abstract representations corresponding to the bindings
in <tt><i>bindings</i></tt>, and <tt><i>t</i></tt> is the abstract
representation of the body <tt><i>expr</i></tt>. </p>


	  <li><p> <b>(Optional)</b> As it stands, the current language only
	    supports passing exactly two integers to <tt>+</tt>
	    and <tt>*</tt>. It's easy enough to modify the primitive
	    operations for <tt>+</tt> and <tt>*</tt>
	    (functions <tt>oper_plus</tt> and <tt>oper_times</tt>
	    in <tt>homework3.py</tt>) to support more than 2
	      arguments. But there's another approach we can use.</p>

	    <p>Intuitively, we can express addition with more than two
	      arguments as a nested sequence of additions with only
	      two arguments. For instance, <tt>(+ 1 2 3 4)</tt> is
	      equivalent to <tt>(+ 1 (+ 2 (+ 3 4)))</tt>. So one way
	      to support addition with more than two arguments is to
	      parse it into an abstract representation that uses nested
	      additions with two arguments.</p>

	    <p>Modify the parser in function <tt>parse</tt> so
	      that it can parse expressions of the
	      form <tt>(+ <i>e<sub>1</sub></i>
	      ... <i>e<sub>k</sub></i>)</tt>, and for those returns
	      the same abstract representation as if we had written
	      <tt>(+ <i>e<sub>1</sub></i> (+ <i>e<sub>2</sub></i> (+
		... (+ <i>e<sub>k-1</sub></i> <i>e<sub>k</sub></i>)
		...)))</tt>, or something equivalent. </p>

	    <p>Do the same for <tt>*</tt>.</p>

	  </li>


	</ol>
      </li>


      <!-- ------------------------------------------------------------ -->


      <li> <p><b>Infix expressions</b></p>

	<p>As I mentioned in class, the reason why we'll be using S-expressions as our surface syntax
	  is for simplicity. It'll be easy to add features to our language without having to fight with the parser too too much. </p>
	
	<p>To get a sense of the challenges that a more natural syntax poses, we'll develop an alternate surface syntax for our calculator language, based on more standard
	  mathematical notation. </p>

	<p>Here is the base grammar I have in mind:

<pre>
  &lt;expr&gt; ::= &lt;integer&gt;
             true
             false
             &lt;identifier&gt;
             ( expr )
             &lt;expr&gt; ? &lt;expr&gt; : &lt;expr&gt;
             let ( &lt;bindings&gt; ) &lt;expr&gt;
             &lt;expr&gt; + &lt;expr&gt;
             &lt;expr&gt; * &lt;expr&gt;
             &lt;expr&gt; - &lt;expr&gt;
             &lt;name&gt; ( &lt;expr-seq&gt; )

  &lt;bindings&gt; ::= &lt;name&gt; = &lt;expr&gt; , &lt;bindings&gt;
                 &lt;name&gt; = &lt;expr&gt;

  &lt;expr-seq&gt; ::= &lt;expr&gt; , &lt;expr-seq&gt;
                 &lt;expr&gt;
</pre>
	</p>

	<p>Write a function <tt>parse_natural</tt> that does
	what <tt>parse</tt> does, but parsing according to the above
	grammar instead of S-expressions. It should return an abstract
	  representation of the parsed expression.</p>

	<p>In order to be able to use Pyparsing and parser
	combinators, you will need to modify the above grammar so that
	it is, at the very least, not left recursive. You may need to
	make other modifications to the grammar as well. Just make
	sure that the parser you write in the end accepts the same
	  inputs as the grammar above.</p>

	<p>The
	resulting abstract representation should represent the input
	expression subject to the usual rules of operator
	precedence: <tt>*</tt> groups more tightly than
	either <tt>+</tt> or <tt>-</tt>. Treat <tt>*</tt>, <tt>+</tt>,
	and <tt>-</tt> as associative operations. (They are, in fact,
	except for <tt>-</tt>. If you feel adventurous,
	make <tt>-</tt> right associative).  That is, <tt>10 * 20 +
	30</tt> should parse as though you had written <tt>(10 * 20) +
	30</tt>, and <tt>10 + 20 + 30</tt> can parse as either <tt>(10
	+ 20) + 30</tt> or <tt>10 + (20 + 30)</tt> and I don't care
	which.  
	</p>

	<p>Write a function <tt>shell_natural</tt> that does
	  what <tt>shell</tt> does except it
	  uses <tt>parse_natural</tt> instead of <tt>parse</tt>. 
	</p>

<pre class="code">
<i># sample outputs using the Calc shell
# note that it gives the parsed abstract representation, which is what I'll be checking
# I've sometimes indented the abstract representation for ease of reading</i>

>>> shell_natural()
Homework 3 - Calc Language (Natural syntax)
calc/nat> let (x = 10) x + 1
Abstract representation: ELet([(x,EInteger(10))],
                              ECall(+,[EId(x),EInteger(1)]))
11
calc/nat> let (x = 10 , y = 20) x + y * y
Abstract representation: ELet([(x,EInteger(10)),
                               (y,EInteger(20))],
                              ECall(+,[EId(x),ECall(*,[EId(y),EId(y)])]))
410
calc/nat> zero? (1)
Abstract representation: ECall(zero?,[EInteger(1)])
false
calc/nat> zero? (10 - 10)
Abstract representation: ECall(zero?,[ECall(-,[EInteger(10),EInteger(10)])])
true
calc/nat> zero? (0) ? 1 : 2
Abstract representation: EIf(ECall(zero?,[EInteger(0)]),EInteger(1),EInteger(2))
1
calc/nat> (zero? (0) ? 1 : 2) + 55
Abstract representation: ECall(+,[EIf(ECall(zero?,[EInteger(0)]),EInteger(1),EInteger(2)),
                                  EInteger(55)])
56
calc/nat> (zero? (1) ? 1 : 2) + 55
Abstract representation: ECall(+,[EIf(ECall(zero?,[EInteger(1)]),EInteger(1),EInteger(2)),
                                  EInteger(55)])
57
calc/nat> let (x = 4 + 5 * 6) let (y = x * 2) square(y)
Abstract representation: ELet([(x,ECall(+,[EInteger(4),ECall(*,[EInteger(5),EInteger(6)])]))],
                              ELet([(y,ECall(*,[EId(x),EInteger(2)]))],
                                   ECall(square,[EId(y)])))
4624
<i># double-checking...</i>
calc/nat> (34 * 2) * (34 * 2)
Abstract representation: ECall(*,[ECall(*,[EInteger(34),EInteger(2)]),
                                  ECall(*,[EInteger(34),EInteger(2)])])
4624
</pre>

<i>Note: if you hit a wall and cannot make any progress with the
  surface syntax I'm asking you to implement, you can make changes to
  the surface syntax to make it easier to parse. Document your
  changes, and explains why you had to do things that way. Try
  to keep it as close as possible to a natural syntax.</i>

	  </li>

	  <li><p><b>Extra:</b> Come up with a reasonable natural
	      syntax for function definitions, and redo Question 2(a)
	      above except with <tt>parse_natural</tt> and your syntax
	      for function definitions.


<pre class="code">
<i># sample outputs using the Calc shell
# note that it gives the parsed abstract representation, which is what I'll be checking
# I've sometimes indented the abstract representation for ease of reading</i>

calc/nat> function decrement (x) x - 1
Function decrement added to functions dictionary
calc/nat> decrement(10)
Abstract representation: ECall(decrement,[EInteger(10)])
9
calc/nat> function sum_of_squares (x,y) square(x) + square(y)
Function sum_of_squares added to functions dictionary
calc/nat> sum_of_squares(10,5)
Abstract representation: ECall(sum_of_squares,[EInteger(10),EInteger(5)])
125
</pre>


      </li>

      
    </ol>

  </body>
</html>

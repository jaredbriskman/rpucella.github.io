<!DOCTYPE html>
<html>

  <head>
    
    <meta charset="utf-8">
    <title>Homework 1</title>

    <link rel="stylesheet" href="alt.css" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,800,700' rel='stylesheet' type='text/css'>

    <script src="autoscroll.js"></script>
    
    <style>

      hr { margin-top: 50px; }

        code,tt,pre {
          font-size: 110%;
        }
	
        div.lect {
	  padding-top: 0;
       	  padding-left: 3em;
	  margin-top:0;
        }
    	p.ann { 
    	  padding-left: 3em;
    	  text-indent: -3em; 
    	}
	p.ann_ctd{
	  padding-left: 3em;
        }
    	span.hdr {
   	  padding-right: 1em
    	}

	.hidden {
	  visibility: hidden;
        }

        tt.code {
           font-weight: bold;
        }

      div.code {
      border: 1px solid #c6c6c6;
      border-radius: 5px;
      padding: 0px;
      margin-bottom: 20px;
      }
      
      div.code p {
      margin:0px;
      padding:5px 10px;
      background:#eeeeee;
      font-style: italic;
      cursor:pointer;
      }

      div.code p:hover {
      background:#cccccc;
      }

      div.code pre { 
      display:none;
      padding: 10px;
      font-size:100%;
      }

      div.code.visible pre  {
      display:block;
      }

ol.question {
    padding-top:1em;
    list-style-type: decimal;
}

ol.subquestion {
    list-style-type: upper-alpha;
}

      ol.question > li {
      font-weight: bold;
      }

      ol.question > li > * {
      font-weight: normal;
      }
      
ol > li {
    padding:4px 8px; /* Add some spacing around the content */
}

li ol,
li ul {margin-top:6px;}

li > p { margin-top:0;}
    </style>

    <script>
      function toggleShowHide (p) { 
      var div = p.parentNode;
        if (div.className && div.className.startsWith("visible")) {
          div.className = "code";
      } else {
        div.className = "visible code";
      }
      }
    </script>


  </head>


  <body>

    <div class="navbar">

      <div class="home">
	<a href="../../index.html"><img src="../../home.png" style="height: 1.6em;"></a>
      </div>

      <ul>
	<li><a href="index.html"><b>Foundations of Computer Science FA17</b></a></li> 
	<li class="hidden"><a class="scrollto" href="#announcements">Announcements</a></li>
	<li class="hidden"><a class="scrollto" href="#info">Course Info</a></li>
	<li class="hidden"><a class="scrollto" href="#lectures">Lectures</a></li>
	<li class="hidden"><a class="scrollto" href="#homeworks">Homeworks</a></li>
      </ul>
    </div>


    <!-- padding -->
    <div id="top" style="height: 5em;"></div>
    
    <h1 class="clear">Homework 1</h1>
    
    <p class="subtitle">Due date: Sunday, Sep 10 (23h59)</p>

    <p><b>Note on integrity:</b> This homework is meant to be done
    individually. You may discuss problems with fellow students, but
    all work must be entirely your own, and should not be from any
    other course, present, past, or future. If you use a solution from
    another source you must cite it &mdash; this includes when that source
      is someone else helping you. <b>Please do not post your solutions on a public website or a public repository like GitHub.</b>
   </p>

    <p>All programming is to be done in OCaml v4.</p>

    <p>Code your answers by modifying the
      file <a href="homework1.ml"><tt>homework1.ml</tt></a> provided. Add your
      <span style="text-decoration:underline;">name</span>, your <span style="text-decoration:underline;">email address</span>, and any <span style="text-decoration:underline;">remarks</span> that you
      wish to make to the instructor to the block comment at the head of the file.</p>

    <p><b>Please do not change the types in the signature of the
	function stubs I provide</b>. Doing so will make it
	impossible to load your code into the testing infrastructure,
      and make me unhappy.</p>

    <p>Feel free to define helper functions if you need them.</p>

    <p>Electronic submission instructions:</p>

    <ul>
      <li>Start a <i>new</i> OCaml shell.</li>
      <li>Load your homework code via <tt>#use "homework1.ml";;</tt></li>
      <li>If there are any error, do not submit. I can't test what I
	can't <tt>#use</tt>.</li>
      <li>When you're ready to submit, send an email with your file <tt>homework1.ml</tt> as an attachment to <tt>focs.fa17@gmail.com</tt> with subject <i>Homework 1 submission</i>.</li>
    </ul>

<!--
    <hr>

    <p class="subtitle">Updates</p>
    <ul class="simple">
      <li>Jan 21: changed sample outputs for <tt>nth</tt> to match type of the functon.</li>
      <li>Jan 23: changed last sample output for <tt>multM</tt> to a more meaningful one.</li>
      <li>Jan 24: fixed incorrect outer product outputs.</li>
    </ul>
-->
	

    <hr>

    <ol class="question">
      <li> <p><b>Numerical functions</b></p>

	<p>The functions below are all recursive over the integers. Most of these functions are only defined when some of their arguments are positive. I don't care what you do when the arguments are outside the domain of definition. You can either raise an exception using <tt>failwith <i>string</i></tt>, or return a default value.</p>

	<ol class="subquestion">

	  <li> <p>Code a recursive function <tt class="code">expt</tt> of
	      type <tt class="code">int -> int -> int</tt>
	      where <tt>expt <i>a</i> <i>b</i></tt>
	      returns <tt><i>a</i><sup><i>b</i></sup></tt>.</p>

	    <p>The function is
	      defined only when <tt><i>b</i></tt> &geq; 0. Use the
	      fact that <tt><i>a</i><sup><i>b</i></sup></tt>
	      = <tt><i>a</i>&middot;<i>a</i><sup><i>b</i>-1</sup></tt>
	      when <tt><i>b</i></tt> &geq; 1.  </p>
	    
<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre>
# expt 1 0;;
- : int = 1
# expt 1 3;;
- : int = 1
# expt 2 0;;
- : int = 1
# expt 2 1;;
- : int = 2
# expt 2 2;;
- : int = 4
# expt 2 3;;
- : int = 8
# expt 10 3;;
- : int = 1000</pre>
	  </div>
	  </li>


	  <li> <p>Code a recursive function <tt class="code">choose</tt> of type
	      <tt class="code">int -> int -> int</tt>
	      where <tt>choose <i>n</i> <i>k</i></tt>
	      returns <img src="binomial.svg" style="vertical-align:
	      -0.5em;">,
	      the <a href="https://en.wikipedia.org/wiki/Binomial_coefficient">binomial
		coefficient</a>. Recall that <tt>choose <i>n</i> <i>k</i></tt>
	      represents the number of ways one can
	      choose <tt><i>k</i></tt> distinct elements from a collection
	      of <tt><i>n</i></tt> elements.</p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre>
# choose 1 1;;
- : int = 1
# choose 2 1;;
- : int = 2
# choose 3 1;;
- : int = 3
# choose 10 2;;
- : int = 45
# choose 10 3;;
- : int = 120
# choose 10 4;;
- : int = 210
# choose 10 5;;
- : int = 252
# choose 10 6;;
- : int = 210</pre>
</div>
	  </li>


  <li> <p>Code a recursive function <tt class="code">gcd</tt> of
          type <tt class="code">int -> int -> int</tt> which takes two
          non-negative integers and returns the greatest common divisor of those
            integers.</p>
        
<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
        <pre>
# gcd 1 1;;
- : int = 1
# gcd 1 3;;
- : int = 1
# gcd 2 4;;
- : int = 2
# gcd 4 2;;
- : int = 2
# gcd 4 6;;
- : int = 2
# gcd 9 12;;
- : int = 3
# gcd 60 70;;
- : int = 10</pre>
  </div>
	  </li>

  <li> <p>Two integers are coprime if they have only the trivial
          divisor in common &mdash; that is, if their greatest
            common divisor is 1. </p>

    <p>Code a recursive function <tt class="code">coprimes</tt> of type
      <tt class="code">int -> int list</tt> where <tt>coprimes n</tt>
      returns the list of all integers between 1 and <tt>n</tt> (inclusive)
      that are coprime with <tt>n</tt>.</p>
  
<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre>
# coprimes 1;;
- : int list = [1]
# coprimes 2;;
- : int list = [1]
# coprimes 3;;
- : int list = [1; 2]
# coprimes 4;;
- : int list = [1; 3]
# coprimes 10;;
- : int list = [1; 3; 7; 9]
# coprimes 20;;
- : int list = [1; 3; 7; 9; 11; 13; 17; 19]
# coprimes 5555;;
- : int list =
[1; 2; 3; 4; 6; 7; 8; 9; 12; 13; 14; 16; 17; 18; 19; 21; 23; 24; 26; 27; 28;
 29; 31; 32; 34; 36; 37; 38; 39; 41; 42; 43; 46; 47; 48; 49; 51; 52; 53; 54;
 56; 57; 58; 59; 61; 62; 63; 64; 67; 68; 69; 71; 72; 73; 74; 76; 78; 79; 81;
 82; 83; 84; 86; 87; 89; 91; 92; 93; 94; 96; 97; 98; 102; 103; 104; 106; 107;
 108; 109; 111; 112; 113; 114; 116; 117; 118; 119; 122; 123; 124; 126; 127;
 128; 129; 131; 133; 134; 136; 137; 138; 139; 141; 142; 144; 146; 147; 148;
 149; 151; 152; 153; 156; 157; 158; 159; 161; 162; 163; 164; 166; 167; 168;
 169; 171; 172; 173; 174; 177; 178; 179; 181; 182; 183; 184; 186; 188; 189;
 191; 192; 193; 194; 196; 197; 199; 201; 203; 204; 206; 207; 208; 211; 212;
 213; 214; 216; 217; 218; 219; 221; 222; 223; 224; 226; 227; 228; 229; 232;
 233; 234; 236; 237; 238; 239; 241; 243; 244; 246; 247; 248; 249; 251; 252;
 254; 256; 257; 258; 259; 261; 262; 263; 266; 267; 268; 269; 271; 272; 273;
 274; 276; 277; 278; 279; 281; 282; 283; 284; 287; 288; 289; 291; 292; 293;
 294; 296; 298; 299; 301; 302; 304; 306; 307; 309; 311; 312; 313; 314; 316;
 317; 318; 321; 322; 323; 324; 326; 327; 328; 329; 331; 332; 333; 334; 336;
 337; 338; 339; 342; 343; 344; 346; 347; 348; 349; 351; 353; 354; 356; 357;
 358; 359; 361; 362; 364; 366; 367; 368; 369; 371; 372; 373; 376; 377; 378;
 379; 381; 382; 383; 384; 386; 387; 388; 389; 391; 392; 393; 394; 397; 398;
399; 401; 402; 403; 406; 408; 409; 411; 412; 413; 414; 416; ...]
</pre>	    
</div>
	  </li>


	</ol>
      </li>

      <li> <p><b>List functions</b></p>

	<p>All of the functions below can be written as recursive
	  functions over lists. They all fit the general pattern of:</p>
<pre>
   let rec f xs ... = match xs with
                        [] -> <i>e1</i>
                      | x::xs' -> <i>e2</i>
</pre>
<p>where <tt><i>e2</i></tt> can use <tt>x</tt>, <tt>xs'</tt>, and the
recusive function itself. For some functions, you may need to do some
additional matching in <tt><i>e2</i></tt>, or you can add additional
patterns to the match to capture some special cases.</p>

	<ol class="subquestion">

	  <li><p>
	    Code a recursive function <tt class="code">tripleUp</tt> of
	    type <tt class="code">'a list -> 'a list</tt> which takes
	    a list <i>L</i> and returns a new list where every element <i>L</i>
	    is triplicated, so that <tt>tripleUp
		[1;2;3]</tt> returns <tt>[1;1;1;2;2;2;3;3;3]</tt>.</p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre>
# tripleUp [];;
- : 'a list = []
# tripleUp [1];;
- : int list = [1; 1; 1]
# tripleUp [1;2];;
- : int list = [1; 1; 1; 2; 2; 2]
# tripleUp ["hello";"world";"greetings"];;
- : string list =
["hello"; "hello"; "hello"; "world"; "world"; "world";
 "greetings"; "greetings"; "greetings"]</pre>
</div>
	  </li>


	  <li><p>Code a recursive function <tt class="code">nth</tt> of
	    type <tt class="code">int -> 'a list -> 'a</tt> which
	      takes an integer <i>n</i> and a list <i>L</i> and 
	      returns the element at position <i>n</i> in
	      list <i>L</i>, where 0 is the position of the first
	      element. </p>

	    <p>If the index <i>n</i> is out of bounds, you can raise
	      an exception using <tt>failwith <i>string</i></tt>.</p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre>
# nth 0 ["a";"b";"c"];;
- : string = "a"
# nth 1 ["a";"b";"c"];;
- : string = "b"
# nth 2 ["a";"b";"c"];;
- : string = "c"
# nth 0 [10 ; 20; 30];;
- : int = 10
</pre>
</div>

	  </li>


	  <li><p>
	    Code a recursive function <tt class="code">last</tt> of
	    type <tt class="code">'a list -> 'a</tt> which returns the
	    last element of a list.</p>

	    <p>If the list is empty, then there is no last
	      element. You can raise an exception using <tt>failwith <i>string</i></tt>.</p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre>
# last [1];;
- : int = 1
# last [1;2];;
- : int = 2
# last [1;2;3;4;5;6;7;8];;
- : int = 8
# last ["a";"b";"c"];;
- : string = "c"</pre>
	  </div>
	  </li>


	  <li><p>
	    Code a recursive function <tt class="code">appendAll</tt> of
	      type <tt class="code">'a list list -> 'a list</tt> which
	    takes a list of lists <i>LL</i> and returns a list made up
	    of all the elements of all the lists in <i>LL</i>, in
	    the order in which they appear in <i>LL</i>.</p>

	    <p>Note that operation <tt>@</tt> can be used to append two lists together, so that
	      <tt>[1;2;3] @ [4;5]</tt> yields list <tt>[1;2;3;4;5]</tt></p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre>
# appendAll [];;
- : 'a list = []
# appendAll [[]];;
- : 'a list = []
# appendAll [[1;2]];;
- : int list = [1; 2]
# appendAll [[1;2];[]];;
- : int list = [1; 2]
# appendAll [[1;2];[3;4]];;
- : int list = [1; 2; 3; 4]
# appendAll [[1;2];[3;4];[5;6;7]];;
- : int list = [1; 2; 3; 4; 5; 6; 7]
# appendAll [["hello"];[];["world";"greetings"]];;
- : string list = ["hello"; "world"; "greetings"]</pre>
	  </div>
	  </li>

	  <li><p>
	    Code a recursive function <tt class="code">split</tt> of
	      type <tt class="code">'a list -> ('a list * 'a list)</tt> which
	    takes a list <i>L</i> and returns a pair of lists, each holding half the elements of the original list.</p>

	    <p>I don't care which elements go into which of the two resulting lists, and in which order. The only requirements is that <tt>split L</tt> returns two lists <tt>(M,N)</tt> where every element of <tt>L</tt> appears in exactly one of <tt>M</tt> and <tt>N</tt>, and the length of <tt>M</tt> and <tt>N</tt> differ by at most 1.</p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
	    <pre>
# split [];;
- : 'a list * 'a list = ([], [])
# split [1];;
- : int list * int list = ([1], [])
# split [1;2];;
- : int list * int list = ([1], [2])
# split [1;2;3];;
- : int list * int list = ([1; 3], [2])
# split [1;2;3;4];;
- : int list * int list = ([1; 3], [2; 4])
# split [1;2;3;4;5;6;7;8;9;10];;
- : int list * int list = ([1; 3; 5; 7; 9], [2; 4; 6; 8; 10])
# split ["hello";"world";"greetings"];;
- : string list * string list = (["hello"; "greetings"], ["world"]) </pre>
	  </div>
	  </li>

	</ol>
      </li>

      <li> <p><b>Vectors</b></p>

	<p>We can implement vectors as lists of integers. Operations
	on vectors such as addition or scalar multiplication can then
	  be implemented as recursive functions over lists.</p>

	<p>One difference from Question 2
	  is that you will sometimes have to recurse over two lists at
	  the same time, which means matching over two
	  lists. One way to do so is to first match over the first list,
	  and then match over the second list in each case of the first
	  list (if applicable). For example:</p>
<pre>
   let rec f xs ys = match xs with
                       [] -> <i>e1</i>
                     | x::xs' -> (match ys with
                                    [] -> <i>e2</i>
                                  | y::ys' -> <i>e3</i>)
</pre>
<p>
Another possibility is to match on both
	  lists at the same time, by treating them as pairs of
lists. For example:</p>
<pre>
   let rec f xs ys = match (xs,ys) with
                       ([],[]) -> <i>e1</i>
                     | (x::xs',[]) -> <i>e2</i>
                     | ([],y::ys') -> <i>e3</i>
                     | (x::xs',y::ys') -> <i>e2</i>
</pre>

	<p>These functions only make sense if their vector arguments have the
	same length. You can assume that your code will be given vectors of the same
	length. I'm only going to test your code with vectors of the
	same length. Still, you should probably make sure that your
	code does return a value in case vectors do not have the same
	length (I don't care what that 
	  value is), or raises an exception using <tt>failwith</tt>. 

	<ol class="subquestion">

	  <li><p>
	    Code a recursive function <tt class="code">addV</tt> of
	      type <tt class="code">int list -> int list -> int list</tt>
	    which takes two vectors <i>v<sub>1</sub></i>
	    and <i>v<sub>2</sub></i> and returns the vector
	    sum <i>v<sub>1</sub>+v<sub>2</sub></i>.</p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre>
# addV [] [];;
- : int list = []
# addV [10] [20];;
- : int list = [30]
# addV [10;20;30] [20;40;60];;
- : int list = [30; 60; 90]</pre>
	  </div>
	  </li>

	  <li><p>
	    Code a recursive function <tt class="code">scaleV</tt> of
	      type <tt class="code">int -> int list -> int list</tt>
	    which takes an integer <i>a</i> and a vector <i>v</i> and
	    computes the scalar multiplication <i>a v</i> (multiplying
	    every component of <i>v</i> by <i>a</i>).</p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre>
# scaleV 10 [];;
- : int list = []
# scaleV 0 [1;2;3];;
- : int list = [0; 0; 0]
# scaleV 1 [1;2;3];;
- : int list = [1; 2; 3]
# scaleV 2 [1;2;3];;
- : int list = [2; 4; 6]
# scaleV 10 [1;2;3];;
- : int list = [10; 20; 30]</pre>
	  </div>
	  </li>


	  <li><p>
	    Code a recursive function <tt class="code">inner</tt> of
	      type <tt class="code">int list -> int list -> int</tt>
	    which takes two vectors <i>v<sub>1</sub></i>
	    and <i>v<sub>2</sub></i> and returns the <a href="https://en.wikipedia.org/wiki/Dot_product">inner product</a>
	    <i>v<sub>1</sub> &middot; v<sub>2</sub></i>.</p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre>
# inner [] [];;
- : int = 0
# inner [10] [20];;
- : int = 200
# inner [1;2;3] [4;5;6];;
- : int = 32
# inner [1;2;3] [8;10;12];;
- : int = 64</pre>
	  </div>
	  </li>


	  <li><p>
	    Code a recursive function <tt class="code">outer</tt> of
	      type <tt class="code">int list -> int list -> int list list</tt>
	    which takes two vectors <i>v<sub>1</sub></i>
	    and <i>v<sub>2</sub></i> and returns the <a href="https://en.wikipedia.org/wiki/Outer_product">outer product</a>
	    <i>v<sub>1</sub> &otimes; v<sub>2</sub></i>.</p>

<p>Note that outer product of two vectors is a matrix. We represent a
  matrix by a list of lists, where each list is a row in the matrix,
  from top to bottom. For example,  <tt>[[1;0];[0;1]]</tt> is the
  identity 2x2 matrix. </p>


<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre>
# outer [] [];;
- : int list list = []
# outer [10] [20];;
- : int list list = [[200]]
# outer [1;2;3] [4;5;6];;
- : int list list = [[4; 5; 6]; [8; 10; 12]; [12; 15; 18]]
# outer [1;2;3] [10; 100; 1000];;
- : int list list = [[10; 100; 1000]; [20; 200; 2000]; [30; 300; 3000]]</pre>
	  </div>
	  </li>

	</ol>
      </li>


    </ol>
	
    

  </body>
</html>

<!DOCTYPE html>
<html>

  <head>
    
    <meta charset="utf-8">
    <title>Homework 9</title>

    <link rel="stylesheet" href="alt.css" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,800,700' rel='stylesheet' type='text/css'>

    <script src="autoscroll.js"></script>
    
    <style>

      hr { margin-top: 50px; }

        code,tt,pre {
          font-size: 110%;
        }
	
        div.lect {
	  padding-top: 0;
       	  padding-left: 3em;
	  margin-top:0;
        }
    	p.ann { 
    	  padding-left: 3em;
    	  text-indent: -3em; 
    	}
	p.ann_ctd{
	  padding-left: 3em;
        }
    	span.hdr {
   	  padding-right: 1em
    	}

	.hidden {
	  visibility: hidden;
        }

        tt.code {
           font-weight: bold;
/*           background: #e6e6e6; */
        }

      div.code {
      border: 1px solid #c6c6c6;
      border-radius: 5px;
      padding: 0px;
      margin-bottom: 20px;
      }
      
      div.code p {
      margin:0px;
      padding:5px 10px;
      background:#eeeeee;
      font-style: italic;
      cursor:pointer;
      }

      div.code p:hover {
      background:#cccccc;
      }

      div.code pre { 
      display:none;
      padding: 10px;
      font-size:100%;
      }

      div.code.visible pre  {
      display:block;
      }
      
ol.question {
    padding-top:1em;
    list-style-type: decimal;
}

ol.subquestion {
    list-style-type: upper-alpha;
}

ol > li {
    padding:4px 8px; /* Add some spacing around the content */
}

li ol,
li ul {margin-top:6px;}

li > p { margin-top:0;}


    </style>

    <script>
      function toggleShowHide (p) { 
      var div = p.parentNode;
        if (div.className && div.className.startsWith("visible")) {
          div.className = "code";
      } else {
        div.className = "visible code";
      }
      }
    </script>

  </head>


  <body>

    <div class="navbar">

      <div class="home">
	<a href="../../index.html"><img src="../../home.png" style="height: 1.6em;"></a>
      </div>

      <ul>
	<li><a href="index.html"><b>Foundations of Computer Science SP17</b></a></li> 
	<li class="hidden"><a class="scrollto" href="#announcements">Announcements</a></li>
	<li class="hidden"><a class="scrollto" href="#info">Course Info</a></li>
	<li class="hidden"><a class="scrollto" href="#lectures">Lectures</a></li>
	<li class="hidden"><a class="scrollto" href="#homeworks">Homeworks</a></li>
      </ul>
    </div>


    <!-- padding -->
    <div id="top" style="height: 5em;"></div>
    
    <h1 class="clear">Homework 9</h1>
    
    <p class="subtitle">Due date: Sunday, Dec 10 (23h59)</p>

    <p><b>Note on integrity:</b> This homework is meant to be done
    individually. You may discuss problems with fellow students, but
    all work must be entirely your own, and should not be from any
    other course, present, past, or future. If you use a solution from
    another source you must cite it &mdash; this includes when that source
      is someone else helping you. <b>Please do not post your solutions on a public website or a public repository like GitHub.</b>
   </p>

    <p>All programming is to be done in OCaml v4.</p>

    <p>Code your answers by modifying the
      file <a href="homework9.ml"><tt>homework9.ml</tt></a> provided. Add your
      <span style="text-decoration:underline;">name</span>, your <span style="text-decoration:underline;">email address</span>, and any <span style="text-decoration:underline;">remarks</span> that you
      wish to make to the instructor to the block comment at the head of the file.</p>

    <p><b>Please do not change the types in the signature of the
	function stubs I provide</b>. Doing so will make it
	impossible to load your code into the testing infrastructure,
      and make me unhappy. It is perfectly okay to add a <tt>rec</tt> keyword, though. That does not change the type of the function.</p>

    <p>Feel free to define helper functions if you need them.</p>

    <p>Electronic submission instructions:</p>

    <ul>
      <li>Start a <i>new</i> OCaml shell.</li>
      <li>Load your homework code via <tt>#use "homework9.ml";;</tt></li>
      <li>If there are any error, do not submit. I can't test what I
	can't <tt>#use</tt>.</li>
      <li>When you're ready to submit, send an email with your file <tt>homework9.ml</tt> as an attachment to <tt>focs.fa17@gmail.com</tt> with subject <i>Homework 9 submission</i>.</li>
    </ul>

    <hr>



    <ol class="question">


      <li> <p><b>Binary Trees</b></p>

	<p>A <i>binary tree</i> is a tree in which every node has at most
  two children (a left child and a right child). A binary tree may be
  empty. We will consider binary trees in which every node stores a
  value:</p> 
	
	<p><center><img src="bintree.png"></center></p>

      
<p>
  Here is an OCaml type for binary trees that can store values of
  type <tt>'a</tt> at the nodes:
</p>
<pre>
type 'a bintree = 
  | Empty
  | Node of 'a * 'a bintree * 'a bintree
</pre>

<p>
The sample tree above can be constructed using
<pre>
let sample = 
  Node(10, Node(3, Node(7, Empty, Empty),
                   Node(5, Empty, Empty)),
           Node(6, Node(99, Empty, 
                            Node(66, Empty, Empty)),
                   Empty))
</pre>
<p>
  A function <tt>pbt</tt> (for <i>print binary tree</i>) has been provided to
  print an <i>integer</i> binary tree. (If you have other kinds of
  binary trees, then you're going to have to define your own printing
  function.)
</p>
<pre>
# pbt sample;;
    6
            66
        99
10
        5
    3
        7
- : unit = ()
</pre>
<p>It will probably take you a bit of time before you can read this
  output easily, but it's basically the tree rotated counter-clockwise
  90 degrees: the root is on the left (10), and the tree grows down to the
  right. Create a few trees, and print them out to see what they look
  like. </p>

<p>Function over trees, just like functions over lists, are naturally
  recursive. That follows directly from the recursive nature of trees.
</p>

	<ol class="subquestion">

	  <li> <p>Code functions <tt class="code">size</tt>
	      and <tt class="code">height</tt> of
	      type <tt class="code">'a bintree -> int</tt>
	      and a function <tt class="code">sum</tt> of type 
	      <tt class="code">int bintree -> int</tt> that
	      respectively return the
	      number of nodes, the height, and the sum of the values
	      at the nodes in a binary tree. (Recall that the height of a tree is the number of nodes in its longest branch.)
	    </p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# size Empty;;
- : int = 0
# size (Node(1,Empty,Empty));;
- : int = 1
# size sample;;
- : int = 7
# height Empty;;
- : int = 0
# height (Node(1,Empty,Empty));;
- : int = 1
# height sample;;
- : int = 4
# sum Empty;;
- : int = 0
# sum (Node(1,Empty,Empty));;
- : int = 1
# sum sample;;
- : int = 196</pre>
</div>
	  </li>


	  <li>
	    <p>The <i>fringe</i> of a tree is the list of all the leaves of
	      the tree (all the nodes that have no subtrees), from
	      left to right.</p>

	    <p>
	      Code a function <tt class="code">fringe</tt> of
	      type <tt class="code">'a bintree -> 'a list</tt> that
	      returns the fringe of a tree.
	    </p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# fringe Empty;;
- : 'a list = []
# fringe (Node(1,Empty,Empty));;
- : int list = [1]
# fringe (Node(1,Node(2,Empty,Empty),Node(3,Empty,Empty)));;
- : int list = [2; 3]
# fringe sample;;
- : int list = [7; 5; 66]</pre>
</div>
	  </li>

	  <li> 
	    <p>Code a function <tt class="code">map</tt> of
	      type <tt class="code">('a -> 'b) -> 'a bintree -> 'b
		bintree</tt> where <tt>map f t</tt> returns a new tree
	      with the same shape as <tt>t</tt> but where the value of
	      every node has been transformed via function <tt>f</tt>.
	    </p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# map (fun x -> x * x) Empty;;
- : int bintree = Empty
# map (fun x -> x * x) (Node(2,Empty,Empty));;
- : int bintree = Node(4, Empty, Empty)
# pbt (map (fun x -> x * x) (Node(2,Node(3,Empty,Empty),Node(4,Empty,Empty))));;
    16
4
    9
- : unit = ()
# pbt (map (fun x -> x * x) sample);;
    36
            4356
        9801
100
        25
    9
        49
- : unit = ()</pre>
</div>
	  </li>

	  <li> <p>Code a function <tt class="code">fold</tt> of
	      type <tt class="code">('a -> 'b -> 'b -> 'b) -> 'a bintree ->
		'b -> 'b</tt> that does for binary trees
	      what <tt>fold_right</tt> does for lists. In
	      particular, <tt>fold f t b</tt> should apply
	      function <tt>f</tt> to the root of tree <tt>t</tt>, being
	      passed the value at the root and the result of recursively
	      folding each of the left and right subtrees. Folding an
	      empty tree should return value <tt>b</tt>. 
	    </p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# fold (fun v l r -> v+l+r) Empty 0;;
- : int = 0
# fold (fun v l r -> v+l+r) (Node(1,Empty,Empty)) 0;;
- : int = 1
# fold (fun v l r -> v+l+r) (Node(1,Empty,Empty)) 10;;
- : int = 21
# fold (fun v l r -> v+l+r) (Node(1,Node(2,Empty,Empty),Node(3,Empty,Empty))) 0;;
- : int = 6
# fold (fun v l r -> v+l+r) sample 0;;
- : int = 196</pre>
</div>

	  </li>

	  <li>
	    <p>A <i>traversal</i> for a tree is a listing of the
	      values in the tree in some specific order. 
	      A <i>preorder</i> traversal lists the value of a node
	      <i>before</i> the values of the nodes of its subtrees; a
	      <i>postorder</i> traversal lists the values of a node
	      after the values of its subtrees; and an <i>inorder</i>
	      traversal lists the value of a node before the values of
	      its right subtree but after the values of its left
	      subtree.</p>

	    <p>Code
	    function <tt class="code">preorder</tt>, <tt class="code">postorder</tt>,
	      and <tt class="code">inorder</tt>, each of
	      type <tt class="code">'a bintree -> 'a list</tt>, which
	    return the list of values in a binary tree according to
	    the given type of traversal. For full marks, implement
	      these functions using <tt>fold</tt>. 

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# preorder Empty;;
- : 'a list = []
# preorder (Node(1,Empty,Empty));;
- : int list = [1]
# preorder (Node(1,Node(2,Empty,Empty),Node(3,Empty,Empty)));;
- : int list = [1; 2; 3]
# preorder sample;;
- : int list = [10; 3; 7; 5; 6; 99; 66]
# postorder Empty;;
- : 'a list = []
# postorder (Node(1,Empty,Empty));;
- : int list = [1]
# postorder (Node(1,Node(2,Empty,Empty),Node(3,Empty,Empty)));;
- : int list = [2; 3; 1]
# postorder sample;;
- : int list = [7; 5; 3; 66; 99; 6; 10]
# inorder Empty;;
- : 'a list = []
# inorder (Node(1,Empty,Empty));;
- : int list = [1]
# inorder (Node(1,Node(2,Empty,Empty),Node(3,Empty,Empty)));;
- : int list = [2; 1; 3]
# inorder sample;;
- : int list = [7; 3; 5; 10; 99; 66; 6]</pre>
</div>
	  </li>


	</ol>

      </li>



      <li> <p><b>AVL Trees</b></p>

	<p>A <i>binary search tree</i> is a binary tree with
	  the BST property: for every  node N,
	  every node in the left subtree of N has value
	  less than (or equal to) the value at N, and every node in
	  the right subtree of N has value greater
	  than the value at N.</p>
	
	<ol class="subquestion">
	  
	  <li> 
	    
	    <p>Code a function <tt class="code">bst_insert</tt> of
	      type <tt class="code">'a bintree -> 'a -> 'a
		bintree</tt> where <tt>bst_insert t v</tt> returns a
	      new binary search tree obtained by inserting 
	      value <tt>v</tt> into binary search tree <tt>t</tt>.</p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# bst_insert Empty 10;;
- : int bintree = Node(10, Empty, Empty)
# pbt (bst_insert (Node(5,Empty,Empty)) 2);;
5
    2
- : unit = ()
# pbt (bst_insert (Node(5,Empty,Empty)) 8);;
    8
5
- : unit = ()
# pbt (bst_insert (Node(5,Node(2,Empty,Empty),Node(8,Empty,Empty))) 10);;
        10
    8
5
    2
- : unit = ()
# pbt (bst_insert (Node(5,Node(2,Empty,Empty),Node(8,Empty,Empty))) 4);;
    8
5
        4
    2
- : unit = ()
# pbt (bst_insert (Node(5,Node(2,Empty,Empty),Node(8,Empty,Empty))) 1);;
    8
5
    2
        1
- : unit = ()
# pbt (bst_insert (Node(5,Node(2,Empty,Empty),Node(8,Empty,Empty))) 6);;
    8
        6
5
    2
- : unit = ()
</pre>
</div>
	  </li>

	  <li>
	    <p>Code a function <tt class="code">bst_lookup</tt> of
	      type <tt class="code">'a bintree -> 'a -> bool</tt>
	      which checks if a value is in a binary search tree. For
	      full marks, your code should take advantage of the BST
	      property, and not look at every single node
	      of the tree.
	    </p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# bst_lookup Empty 1;;
- : bool = false
# bst_lookup (Node(5,Empty,Empty)) 1;;
- : bool = false
# bst_lookup (Node(5,Empty,Empty)) 5;;
- : bool = true
# bst_lookup (Node(5,Node(2,Empty,Empty),Node(8,Empty,Empty))) 1;;
- : bool = false
# bst_lookup (Node(5,Node(2,Empty,Empty),Node(8,Empty,Empty))) 2;;
- : bool = true
# bst_lookup (Node(5,Node(2,Empty,Empty),Node(8,Empty,Empty))) 8;;
- : bool = true</pre>
</div>
	  </li>

	  <li>
	    <p>Code a function <tt class="code">bstify</tt> of type
	      <tt class="code">'a bintree -> 'a bintree</tt> that
	      takes a generic binary tree and returns a
	      binary <i>search</i> tree containing the same
	      nodes. Your resulting
	      tree need not be balanced. 
	    </p>

	    <p>(Note that because there are <i>so</i> many ways of
	    doing this, your results may not match mine below. As long as
	    your result is a binary search tree with the same nodes as
	      the original, it's all good.)</p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# bstify Empty;;
- : 'a bintree = Empty
# bstify (Node(1,Empty,Empty));;
- : int bintree = Node (1, Empty, Empty)
# pbt (bstify (Node(4,Node(7,Empty,Empty),Node(5,Empty,Empty))));;
    7
        5
4
- : unit = ()
# pbt (bstify sample);;
    99
        66
10
        7
                6
            5
    3
- : unit = ()</pre>
</div>

	  </li>

	  <li>

	    <p>An <a href="https://en.wikipedia.org/wiki/AVL_tree">AVL tree</a> is a binary search tree that further
	      satisfies the <i>height balance</i> (or AVL) property:
	      every node N, the difference in height of the left
	      subtree of N and the right subtree of N is at most
	      1.</p>

	    <p>Code functions <tt class="code">rotate_left</tt> and 
	      <tt class="code">rotate_right</tt> each of
	      type <tt class="code">'a bintree -> 'a bintree</tt>
	      implementing the tree rotations used in AVL tree
	      implementations:
	      <center><img src="https://upload.wikimedia.org/wikipedia/commons/2/23/Tree_rotation.png"></center></p>
	    
	    <p>
	      Rotations should be performed at the
	      root.</p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# let leaf v = Node(v,Empty,Empty);;               
val leaf : 'a -> 'a bintree = &lt;fun>
# let t1 = Node(99,Node(66,leaf(13),leaf(73)),leaf(113));;                   
val t1 : int bintree =                                                       
  Node (99, Node (66, Node (13, Empty, Empty), Node (73, Empty, Empty)),     
   Node (113, Empty, Empty))                                                 
# let t2 = Node(3,Node(2,leaf(1),Empty),
                  Node(5,leaf(4),leaf(6)));;
val t2 : int bintree =
  Node (3, Node (2, Node (1, Empty, Empty), Empty),
   Node (5, Node (4, Empty, Empty), Node (6, Empty, Empty)))

# pbt t1;;                                                                   
    113                                                                      
99                                                                           
        73                                                                   
    66                                                                       
        13                                                                   
- : unit = ()                                                                
# pbt (rotate_right t1);;                                                    
        113                                                                  
    99                                                                       
        73                                                                   
66                                                                           
    13                                                                       
- : unit = ()                                                                
# pbt (rotate_left (rotate_right t1));;                                      
    113                                                                      
99                                                                           
        73                                                                   
    66                                                                       
        13                                                                   
- : unit = ()

# pbt t2;;
        6
    5
        4
3
    2
        1
- : unit = ()
# pbt (rotate_left t2);;
    6
5
        4
    3
        2
            1
- : unit = ()
# pbt (rotate_right (rotate_left t2));;
        6
    5
        4
3
    2
        1
- : unit = ()
</pre>	    
</div>

	    <p>Code a function <tt class="code">avl_insert</tt> of type
	      <tt class="code">'a bintree -> 'a -> 'a bintree</tt>
	      which takes an AVL tree and a value,
	      and returns a new AVL tree with the value inserted. 
	    </p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
  <pre class="code">
# let insert_all l = List.fold_right (fun x t -> avl_insert t x) l Empty;;  
val insert_all : 'a list -> 'a bintree = &lt;fun>

# pbt (insert_all [1]);;                    
1                                           
- : unit = ()                               
# pbt (insert_all [1;2]);;                  
2                                           
    1                                       
- : unit = ()                               
# pbt (insert_all [1;2;3]);;                
    3                                       
2                                           
    1                                       
- : unit = ()                               
# pbt (insert_all [1;2;3;4]);;              
    4                                       
3                                           
    2                                       
        1                                   
- : unit = ()                               
# pbt (insert_all [1;2;3;4;5]);;            
    5                                       
4                                           
        3                                   
    2                                       
        1                                   
- : unit = ()                               
# pbt (insert_all [1;2;3;4;5;6]);;          
        6                                   
    5                                       
        4                                   
3                                           
    2                                       
        1                                   
- : unit = ()                               
# pbt (insert_all [1;2;3;4;5;6;7]);;        
        7                                   
    6                                       
        5                                   
4                                           
        3                                   
    2                                       
        1                                   
- : unit = ()</pre>
</div>
<p>The challenge here, if there is one, is how to express the fact that in an AVL tree, after you insert, you need to walk back up the insertion path and fix up the tree, as we saw in class. Think recursively: walking up the insertion path is the dual of walking down the insertion path.</p>

	  </li>

	</ol>
      </li>

      <li> <p><b>Arithmetic Expressions</b></p>

	<p>Consider the following type for (the parse tree of) arithmetic expressions:</p>
<pre>
type exp =

  (* PART A *)
  | Num of int                
  | Ident of string
  | Plus of exp * exp
  | Times of exp * exp

  (* PART B *)
  | EQ of exp * exp           
  | GT of exp * exp
  | And of exp * exp
  | Not of exp
  | If of exp * exp * exp

  (* PART C *)
  | Letval of string * exp * exp    

  (* PART D - BONUS *)
  | Letfun of string * string * exp * exp      
  | Letrecfun of string * string * exp * exp
  | App of string * exp
</pre>

	<p>We won't be using all constructors at once.</p>

	<p>We will be writing an <i>evaluation function</i> that takes
	  an expression written as a parse tree as above, and
	  evaluates it down to a value.  To deal with identifiers
	  (variables) appearing in an expression, we supply
	  an <i>environment</i> to the evaluation function which tells
	  the evaluation which integer each identifier is mapped
	  to. An environment is just a function <tt>string -> T</tt>
	  where <tt>T</tt> is the type of values that the environment
	  stores. Mostly, we'll be working with integer environments,
	  where <tt>T</tt> is <tt>int</tt>. I've supplied you with two
	  environment-manipulating functions:</p>
	
	<pre>
let init : int env = (fun x -> 0)

let update (env:'a env) (x:string) (v:'a):'a env =
  (fun y -> if (x=y) then v else env y</pre>
	
	<p>Value <tt>init</tt> is an initial integer environment that
	maps every identifier to 0. Function <tt>update</tt> takes an
	environment <tt>env</tt>, an identifier <tt>x</tt> and a
	value <tt>v</tt>, and returns a new environment which
	maps <tt>x</tt> to <tt>v</tt> and maps every other identifier
	to whatever the original environment <tt>env</tt> maps it
	to. Thus, <tt>update init x 10</tt> is an environment that
	maps <tt>x</tt> to 10 and every other identifier to 0.</p>
					  
	<ol class="subquestion">

	  <li><p> Code a function <tt class="code">eval</tt> of
	  type <tt class="code">exp -> int env -> int</tt>
	      where <tt>eval exp env</tt> takes an
	  expression <tt>exp</tt> using only
	  constructors <tt>Num</tt>, <tt>Ident</tt>, <tt>Plus</tt>,
	  and <tt>Times</tt> and an environment <tt>env</tt> and
	  returns the result of evaluating <tt>exp</tt> with
	  environment <tt>env</tt> to resolve identifiers. You can
	  use <tt>failwith</tt> to return an error if you encounter another
	  constructor.</p>

	    <p>Intuitively, a <tt>Num</tt> evaluates to the number
	    itself, an idenfitier <tt>Ident</tt> evaluates to whatever
	    the environment says it maps to, and <tt>Plus</tt>
	    and <tt>Times</tt> evaluate to the result of adding or
	    multiplying the values to which the subexpressions
	    evaluate to. </p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
  <pre class="code">
# eval (Num 10) init;;
- : int = 10
# eval (Ident "x") init;;
- : int = 0
# eval (Plus(Num 10, Num 20)) init;;
- : int = 30
# eval (Plus(Num 10, Ident "x")) (update init "x" 2);;
- : int = 12
# eval (Times(Num 10, Ident "x")) (update init "x" 2);;
- : int = 20
# eval (Times(Plus(Num 10, Ident "y"), Ident "x")) (update init "x" 2);;
- : int = 20
# eval (Times(Plus(Num 10, Ident "x"), Ident "x")) (update init "x" 2);;
- : int = 24
# eval (Plus (Ident "x", Ident "y")) (update (update init "x" 42) "y" 10);;
- : int = 52
</pre>
</div>
	  </li>
      
	  <li><p> If we interpret integer 0 as <i>false</i> and an
	  integer different from 0 as <i>true</i>, we can handle
	      Boolean operations and conditional evaluation in our
	      expressions.</p>

	    <p>Intuitively, <tt>EQ</tt> evaluates to true (that is,
	    any integer different from 0) if its two
	      arguments evaluate to the same value, while <tt>GT</tt>
	    evaluates to true (that is, any integer different from 0)
	    if its first argument evaluates to a 
	      value greater than the second
	      argument. They evaluate to false (0) otherwise.
	    </p>

	    <p>Expression <tt>And</tt> evaluates to true (that is,
	      any integer different from 0) if both its arguments
	    evaluate to true, and evaluates to false (0) otherwise,
	    while expression <tt>Not</tt> evaluates to true
	    when its argument evaluates to false, and evaluates to
	      false otherwise.</p>

	    <p>Expression <tt>If</tt> is more interesting. It first
	    evaluates its first argument. If it is true, then it
	    evaluates its second argument and uses that as the result
	      of the overall evaluation of <tt>If</tt>. Otherwise, it
	    evaluates its 
	    third argument, and uses that as the result of the overall
	      evaluation of <tt>If</tt>. </p>
	      
	    <p>Extend your function <tt class="code">eval</tt> from
	    part A so that you can also evaluate expressions using
	      constructors <tt>EQ</tt>, <tt>GT</tt>, <tt>And</tt>, <tt>Or</tt>,
	      and <tt>If</tt>. 

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# eval (EQ (Num 10,Num 10)) init;;                                             
- : int = 1                                                                    
# eval (EQ (Num 10,Num 0)) init;;                                              
- : int = 0                                                                    
# eval (EQ (Plus (Num 1,Num 2), Num 2)) init;;                                 
- : int = 0                                                                    
# eval (GT (Num 10,Num 10)) init;;                                             
- : int = 0                                                                    
# eval (GT (Num 10,Num 0)) init;;                                              
- : int = 1                                                                    
# eval (GT (Plus (Num 1,Num 2), Num 2)) init;;                                 
- : int = 1                                                                    
# eval (And (Num 1,Num 1)) init;;                                              
- : int = 1                                                                    
# eval (And (Num 1,Num 0)) init;;                                              
- : int = 0                                                                    
# eval (Not (Num 1)) init;;                                                    
- : int = 0                                                                    
# eval (Not (Num 0)) init;;                                                    
- : int = 1                                                                    
# eval (And (Num 1, Not (Num 1))) init;;                                       
- : int = 0                                                                    
# eval (And (Num 0, Not (Num 0))) init;;                                       
- : int = 0                                                                    
# eval (If (EQ (Ident "x", Num 42), Num 100, Num 200)) init;;                  
- : int = 200                                                                  
# eval (If (EQ (Ident "x", Num 42), Num 100, Num 200)) (update init "x" 42);;  
- : int = 100                                                                  
</pre>
</div>
	    
	  </li>


	  
	  <li>

	    <p>We haven't really manipulated the environment during
	  evaluation. We can easily define names for values during
	      evaluation using constructor <tt>Letval</tt>.</p>

	    <p>Intuitively, expression <tt>Letval (x,e1,e2)</tt>
	      evaluates <tt>e1</tt> to an integer <i>n</i>, and then
	      evaluates <tt>e2</tt> in the environment updated to map
	      identifier <tt>x</tt> to <i>n</i>.
	    </p>

	    <p>Extend your function <tt class="code">eval</tt> from
	    part A and B so that you can also evaluate expressions using
	      constructor <tt>Letval</tt>.
	    <p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# eval (Letval ("x",Num 42, Plus (Ident "x",Num 1))) init;;
- : int = 43
# eval (Letval ("x",Num 42, Letval ("y",Num 10, Plus (Ident "x",Ident "y")))) init;;
- : int = 52
# eval (Letval ("x",Num 42, Letval ("y",Plus(Ident "x", Num 10),
                Times (Ident "y", Num 2)))) init;;
- : int = 104  
# eval (Letval ("x",Letval("y",Num 1,Plus(Ident "y",Num 2)),
                Times(Ident "x",Num 4))) init;;
- : int = 12 
</pre>
</div>
	      
	  </li>

	  
	  <li> <p><B>(BONUS for no advantage except impressing me)</B></p>

	    <p>Using <tt>Letval</tt> to create names for values is
	      nice enough,  but it would be really great if we could
	      write <i>functions</i> in our expressions language that
	      simplify the writing of complex
	      expressions. Constructors <tt>Letfun</tt>
	      and <tt>App</tt> let us do just that.</p>

	    <p>Intuitively, <tt>Letfun (f,x,e1,e2)</tt> defines a
	      (nonrecursive) function called <tt>f</tt> that takes a single
	      parameter <tt>x</tt> and has body <tt>e1</tt>. 
	      Calling <tt>f</tt> with an integer  <i>n</i> amounts to
	      evaluating <tt>e1</tt> in an environment extended so
	      that parameter <tt>x</tt> maps to <i>n</i>. The function
	      definition is available during the evaluation
	      of <tt>e2</tt>, whose result is the result of the
	      overall evaluation
	      of <tt>Letfun</tt>. Expression <tt>App</tt> is used
	      to <i>apply</i> a function. It takes a function name (a
	      string) and an expression, evaluates the expression to a
	      value, and calls the function with that value to get the
	      final result.</p>

	    <p>We can't store functions in the environment, because
	      the environment can only store values of
	      type <tt>int</tt>. So we are going to use a second
	      environment, a function environment, to store values of
	      type <tt>int -> int</tt>, and pass that function
	      environment around along with the normal
	      environment. </p>

	    <p>I have provided you with an initial function environment <tt>initF</tt>
	      that assigns an undefined function to every
	      function name.</p>


	  <p> Code a function <tt class="code">evalF</tt> of
	  type <tt class="code">exp -> int env -> (int -> int) env ->
		int</tt> where <tt>evalF exp env fenv</tt> takes an
	      expression <tt>exp</tt> using all the constructors
	      in <tt>exp</tt> (except <tt>Letfunrec</tt>), an
	  environment <tt>env</tt>, a function
	      environment <tt>fenv</tt>, and 
	      returns the result of evaluating <tt>exp</tt> with
	  environment <tt>env</tt> to resolve identifiers and function
	      environment <tt>fenv</tt> to resolve function
	      names. (No, you won't get to reuse <tt>eval</tt>. You'll need to rewrite the whole
	  evaluation function from scratch.)</p>

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
  <pre class="code">
# evalF (Letfun ("square","x",Times(Ident "x", Ident "x"),
                 App("square",Num 10))) init initF;;
- : int = 100
# evalF (Letfun ("square","x",Times(Ident "x", Ident "x"),
                 Letfun ("double","y",Times(Num 2, Ident "y"),
                         App ("double", App ("square",Num 42))))) init initF;;
- : int = 3528
</pre>
</div>

	    <p>Additionally, extend <tt class="code">evalF</tt> to handle
	      constructor <tt>Letrecfun</tt> for defining recursive
	      functions.</p>

	    <p>Intuitively, <tt>Letrecfun (f,x,e1,e2)</tt> defines a
	      recursive function called <tt>f</tt> that takes a single
	      parameter <tt>x</tt> and has body <tt>e1</tt>.
	      Calling <tt>f</tt> with an integer <i>n</i> amounts to
	      evaluating <tt>e1</tt> in an environment extended so
	      that parameter <tt>x</tt> maps to <i>n</i>, and in which
	      function name <tt>f</tt> refers to the function being
	      defined itself.  Function <tt>f</tt> is also available
	      during the evaluation of <tt>e2</tt>, whose result is
	      the result of the overall evaluation
	      of <tt>Letrecfun</tt>. </p>


	      

<div class="code">
  <p onClick="toggleShowHide(this)">Show sample output</p>
<pre class="code">
# evalF (Letrecfun ("fact","n",If (GT (Ident "n", Num 0),
                                   Times (Ident "n", App ("fact",
                                                          Plus (Ident "n", Num (-1)))),
                                   Num 1),
                    (App ("fact", Num 7)))) init initF;;
- : int = 5040
</pre>
</div>
  

	    <p>Oh, and congratulations! You're more than halfway through writing
	    an interpreter for OCaml.</p>

	  </li>


	</ol>

      </li>
      
    </ol>

  </body>
</html>

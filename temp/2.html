<pre>

type location = string
type node = int
type action = string
            
type diagram = (node * location * action * node * node) list
type config = (location * int) list

let print_config (nd:node) (cfg:config):unit =
  let _ = Printf.printf "[%i]  " nd  in
  let rec loop cfg = 
    match cfg with
    | [] -> print_newline ()
    | (loc,v)::cfg' -> let _ = Printf.printf "%s %i  " loc v  in loop cfg'  in
  loop cfg

let p_empty : diagram = (* X -> 0 *)
  [ (0,"","",1,1);
    (1,"X","-",1,-1) ]

let p_transfer : diagram = (* X -> Y *)
  [ (0,"","",1,1);
    (1,"X","-",2,-1);
    (2,"Y","+",1,1) ]

  
let p_copy: diagram =  (* X -> X; Y -> X + Y via T1*)
  [ (0,"","",1,1);
    (1,"X","-",2,4);
    (2,"Y","+",3,3);
    (3,"T1","+",1,1);
    (4,"T1","-",5,-1);
    (5,"X","+",4,4) ]

let p_plus : diagram =   (* Z := X + Y via T1 *)
   [(0,"","",1,1);

      (* Z := X *)
    (1,"X","-",2,4);
    (2,"Z","+",3,3);
    (3,"T1","+",1,1);
    (4,"T1","-",5,10);
    (5,"X","+",4,4);

      (* Y -> T1 *)
    (10,"Y","-",11,20);
    (11,"T1","+",10,10);

    (20,"T1","-",21,-1);
    (21,"Y","+",22,22);
      (* Z -> Z + 1 *)
    (22,"Z","+",20,20) ]

let p_times : diagram =   (* Z := X * Y via T1,T2,T3 *)   (* was: T,U,T2 *)
  [ (0,"","",1,1);

    (* Z := 0 *)

    (* Y -> T1 *)
    (1,"Y","-",2,10);
    (2,"T1","+",1,1);

    (10,"T1","-",11,-1);
    (11,"Y","+",12,12);
    (* Z -> T2 *)
    (12,"Z","-",13,20);
    (13,"T2","+",12,12);
    
    (* Z := T2 + X *)   (* p_plus with X -> T2,  Y -> X, Z -> Z, T1 -> T3 *)
    (20,"T2","-",21,23);
    (21,"Z","+",22,22);
    (22,"T3","+",20,20);
    (23,"T3","-",24,30);
    (24,"T2","+",23,23);
    (30,"X","-",31,40);
    (31,"T3","+",30,30);
    (40,"T3","-",41,50);
    (41,"X","+",42,42);
    (42,"Z","+",40,40);

    (* empty T2 *)
    (50,"T2","-",50,10) ]
    

  
                                                              
(* Question 1 *)
            
let rec find (x:node) (p:diagram):(node * location * action * node * node) = 
  match p with
  | [] -> failwith ("cannot find "^(string_of_int x)^" in diagram")
  | row::xs' -> match row with (y,_,_,_,_) -> if y = x then row else find x xs'
                                        
let rec get_loc (cfg:config) (loc:location):int = 
  match cfg with
  | [] -> failwith ("cannot find location "^loc)
  | (y,v)::cfg' -> if y = loc then v else get_loc cfg' loc
                                  
let rec set_loc (cfg:config) (loc:location) (v:int):config =
  match cfg with
  | [] -> failwith ("cannot find location "^loc)
  | (y,w)::cfg' -> if y = loc then (loc,v)::cfg' else (y,w)::(set_loc cfg' loc v)
                                  

let next (prg:diagram) (cfg:config) (nd:node):(node * config) =
  let _ = print_config nd cfg  in
  let p = find nd prg  in
  match p with (_,loc,act,yay,nay) ->
    if loc = "" then (yay,cfg)
    else
      let v = get_loc cfg loc  in
      if act = "+" then
        (yay, set_loc cfg loc (v+1))
      else if act = "-" then
        if v > 0 then (yay, set_loc cfg loc (v-1))
        else (nay, cfg)
      else failwith ("unrecognized action "^act)
  
let run (prg:diagram) (cfg:config):config =
  let rec loop nd cfg =
    if nd = -1 then cfg
    else let result = next prg cfg nd  in
         match result with (new_nd, new_cfg) ->
           loop new_nd new_cfg  in 
  let result = loop 0 cfg  in
  result

  
let calculate (prg:diagram) (inputs:location list) (output:location) (temps:location list) (args:int list):int =
  let start_cfg = (List.map2 (fun x y -> (x,y)) inputs args)@[(output,0)]@(List.map (fun x -> (x,0)) temps)  in
  get_loc (run prg start_cfg) output



(* QUESTION 2 *)

let p_sub : diagram =   (* Z := X - Y via T1, T2 *)
  [ (0,"","",1,1);

      (* copy X to Z via T2 *)
    (1,"X","-",2,4);
    (2,"Z","+",3,3);
    (3,"T2","+",1,1);
    (4,"T2","-",5,11);
    (5,"X","+",4,4);

      (* copy Y to T1 via T2 *)
    (11,"Y","-",12,14);
    (12,"T1","+",13,13);
    (13,"T2","+",11,11);
    (14,"T2","-",15,20);
    (15,"Y","+",14,14);

    (20,"T1","-",21,-1);
    (21,"Z","-",20,30);

      (* empty T1 *)
    (30,"T1","-",30,-1)]



let p_max : diagram =  (* Z := max(X,Y) with T1,T2,T3 *)
  [ (0,"","",1,1);

      (* copy X to T1 *)
    (1,"X","-",2,4);
    (2,"T1","+",3,3);
    (3,"T3","+",1,1);
    (4,"T3","-",5,11);
    (5,"X","+",4,4);

      (* copy Y to T2 *)
    (11,"Y","-",12,14);
    (12,"T2","+",13,13);
    (13,"T3","+",11,11);
    (14,"T3","-",15,20);
    (15,"Y","+",14,14);

      (* actual loops *)
    (20,"T1","-",21,25);
    (21,"T2","-",22,23);    
    (22,"Z","+",20,20);
    (23,"Z","+",24,24);
    (24,"T1","-",23,-1);
    (25,"T2","-",26,-1);
    (26,"Z","+",25,25)

 ]
  

let p_diff : diagram = (* Z := |X-Y| = (X-Y) + (Y-X)  via T1,T2,T3,T4 *)
  [ (0,"","",1,1);

      (* T3 := X-Y via T1,T2 *)
    (1,"X","-",2,4);
    (2,"T3","+",3,3);
    (3,"T2","+",1,1);
    (4,"T2","-",5,11);
    (5,"X","+",4,4);
    (11,"Y","-",12,14);
    (12,"T1","+",13,13);
    (13,"T2","+",11,11);
    (14,"T2","-",15,20);
    (15,"Y","+",14,14);
    (20,"T1","-",21,101);
    (21,"T3","-",20,30);
    (30,"T1","-",30,101);

      (* T4 := Y-X via T1,T2 *)
    (101,"Y","-",102,104);
    (102,"T4","+",103,103);
    (103,"T2","+",101,101);
    (104,"T2","-",105,111);
    (105,"Y","+",104,104);
    (111,"X","-",112,114);
    (112,"T1","+",113,113);
    (113,"T2","+",111,111);
    (114,"T2","-",115,120);
    (115,"X","+",114,114);
    (120,"T1","-",121,201);
    (121,"T4","-",120,130);
    (130,"T1","-",130,201);

      (* Z := T3 + T4 via T1 *)

    (201,"T3","-",202,204);
    (202,"Z","+",203,203);
    (203,"T1","+",201,201);
    (204,"T1","-",205,210);
    (205,"T3","+",204,204);
    (210,"T4","-",211,220);
    (211,"T1","+",210,210);
    (220,"T1","-",221,300);
    (221,"T4","+",222,222);
    (222,"Z","+",220,220);

      (* empty T3,T4 *)
    (300,"T3","-",300,301);
    (301,"T4","-",301,-1) ]





(* QUESTION 3 *)

(* (a) *)

let rec rename (rename_list:(location * location) list) (name:location):location =
  match rename_list with
  | [] -> name
  | (o,n)::rs' -> if o = name then n else rename rs' name
  
let rec incl (diag:diagram) (offset:int) (stop:int) (loc_rename:(location * location) list):diagram =
  match diag with
  | [] -> []
  | (instr,loc,act,yay,nay)::diag' ->
     let new_instr instr = if instr = -1 then stop else instr + offset  in
     (instr+offset,rename loc_rename loc,act,new_instr yay, new_instr nay)::(incl diag' offset stop loc_rename)

                                
     
let p_div_test : diagram =   (* R := Y * ((X+1) - (Z+1) * Y)  via T1-T7*)
  (* T1 := X + 1 *)
  [ (0,"","",1,1);
    (* T1 := X *)
    (1,"","",1000,1000);
    (2,"T1","+",3,3);
    (* T2 := Z + 1 *)      
    (3,"","",2000,2000);
    (4,"T2","+",5 ,5 );
    (* T3 := T2 * Y *)
    (5,"","",3000,3000);
    (* T4 := T1 - T3 *)
    (6,"","",4000,4000);
    (* R := Y * T4 *)
    (7,"","",5000,5000);
    (300,"T1","-",300,301);
    (301,"T2","-",301,302);
    (302,"T3","-",302,303);
    (303,"T4","-",303,-1) ]  @
  (incl p_copy 1000 2 [("X","X");("Y","T1");("T1","T5")]) @
  (incl p_copy 2000 4 [("X","Z");("Y","T2");("T1","T5")]) @
  (incl p_times 3000 6 [("X","T2");("Y","Y");("Z","T3");("T1","T5");("T2","T6");("T3","T7")]) @
  (incl p_sub 4000 7 [("X","T1");("Y","T3");("Z","T4");("T1","T5");("T2","T6")]) @
  (incl p_times 5000 300 [("X","Y");("Y","T4");("Z","R");("T1","T5");("T2","T6");("T3","T7")])

let p_div : diagram =   (* Z := X div Y via T1-T8*)
  [ (0,"","",1,1);
    (* T8 := p_div_test(X,Y,Z) *)
    (1,"","",1000,1000);
    (2,"T8","-",3,-1);
    (3,"T8","-",3,4);
    (4,"Z","+",1,1)] @
    (incl p_div_test 1000 2 [("X","X");("Y","Y");("Z","Z");("R","T8")])


</pre>

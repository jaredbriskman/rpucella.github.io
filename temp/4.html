<pre>
  
(* 
 * String &lt;-> characters utility functions:
 *
 *   explode : string -> char list
 *      returns the list of characters making up a string
 *
 *   implode : char list -> string
 *      concatenates the list of characters into a string
 *
 *)

let explode (str) = 
  let rec acc (index,result) = 
    if (index&lt;0) then
      result
    else
      acc(index-1, (String.get str index)::result)
  in
    acc(String.length(str)-1, [])

let implode cs = 
  List.fold_right (fun a r -> (String.make 1 a)^r) cs ""



(*
 *  The type of a finite automaton
 * 
 *)

type 'a fa = { states: 'a list;
               alphabet: char list;
               delta: ('a * char * 'a) list;
               start : 'a;
               final : 'a list }


(* 
 * Sample FAs
 *
 * The first accepts the language of all strings over {a,b} 
 * with a multiple-of-3 number of a's.
 *
 * The second accepts the language of all strings over {a,b,c} 
 * whose last three symbols are b's.
 *
 * Notes that states can be of any type -- the first example
 * uses strings as states, while the second uses integers.
 *
 *)

let faThreeA = { 
  states = ["start";"one";"two"];
  alphabet = ['a';'b'];
  delta = [ ("start",'a',"one");
        ("one",'a',"two");
        ("two",'a',"start");
        ("start",'b',"start");
        ("one",'b',"one");
        ("two",'b',"two") ];
  start = "start";
  final = ["start"]
} 

let faLastThreeB = {
  states = [0;1;2;3];
  alphabet = ['a';'b';'c'];
  delta = [ (0,'a',0);
        (0,'b',0);
        (0,'c',0);
        (0,'b',1);
        (1,'b',2);
        (2,'b',3); ];
  start = 0;
  final = [3]
} 





(* QUESTION 1 *)


let isFinal m s = 
  List.mem s m.final

let rec hasFinal (m:'a fa) (qs:'a list):bool = 
  match qs with
  | [] -> false
  | q::qs' -> (isFinal m q) || (hasFinal m qs')

let rec reachableStates (m:'a fa) (q:'a) (a:char):'a list = 
  let rec loop (trs) = 
    match trs with 
    | [] -> []
    | (p',a',q')::trs' when p'=q && a=a' -> q'::(loop trs')
    | _::trs' -> loop trs' in
  loop (m.delta)

let rec addStates ps qs = 
  match ps with
  | [] -> qs
  | p::ps' -> if List.mem p qs then addStates ps' qs
          else p::(addStates ps' qs)
    

let rec follow (m:'a fa) (qs:'a list) (a:char):'a list = 
   match qs with
   | [] -> []
   | q::qs' -> addStates (reachableStates m q a)
                     (follow m qs' a)

let rec followAll (m:'a fa) (qs:'a list) (syms:char list):'a list = 
   match syms with
   | [] -> qs
   | sym::syms -> followAll m (follow m qs sym) syms

let accept (m:'a fa) (input:string):bool = 
  let s = explode input in
  hasFinal m (followAll m [m.start] s)





(* QUESTION 2 *)

let fa_q2_a : 'a fa = { states = [1;2;3;4;5];
            alphabet = ['a';'b';'c'];
            delta = [ (1,'a',1);
                  (1,'b',1);
                  (1,'c',1);
                  (1,'c',2);
                  (2,'a',3);
                  (2,'b',3);
                  (2,'c',3);
                  (3,'a',4);
                  (3,'b',4);
                  (3,'c',4);
                  (4,'a',5);
                  (4,'b',5);
                  (4,'c',5)
            ] ;
            start = 1;
            final = [5]}

let fa_q2_b : 'a fa = { states = [1;2;3;4];
            alphabet = ['a';'b';'c'];
            delta = [ (1,'a',2);
                  (1,'b',1);
                  (1,'c',1);
                  (2,'a',3);
                  (2,'b',1);
                  (2,'c',1);
                  (3,'a',4);
                  (3,'b',1);
                  (3,'c',1);
                  (4,'b',1);
                  (4,'c',1)];
            start = 1;
            final = [1;2;3;4]}


let fa_q2_c : 'a fa = { states = [1;2;3];
            alphabet = ['a';'b';'c'];
            delta = [ (1,'a',2);
                  (1,'b',3);
                  (1,'c',1);
                  (2,'b',3);
                  (3,'c',1)];
            start = 1;
            final = [1;2;3]}


let fa_q2_d : 'a fa = { states = ["00";"10";"01";"11"];
            alphabet = ['a';'b';'c'];
            delta = [ ("00",'a',"10");
                  ("00",'b',"01");
                  ("00",'c',"00");
                  ("10",'a',"00");
                  ("10",'b',"11");
                  ("10",'c',"10");
                  ("01",'a',"11");
                  ("01",'b',"00");
                  ("01",'c',"01");
                  ("11",'a',"01");
                  ("11",'b',"10");
                  ("11",'c',"11")];
            start = "00";
            final = ["10"]}


let fa_q2_e : 'a fa = { states = [ "000";"100";"010";"110";
                   "001";"101";"011";"111";
                   "bad" ];
            alphabet = ['a';'b';'c'];
            delta = [ ("000",'a',"100");
                  ("000",'b',"010");
                  ("000",'c',"001");
                  
                  ("100",'a',"000");
                  ("100",'b',"110");
                  ("100",'c',"101");
                  
                  ("010",'a',"110");
                  ("010",'b',"000");
                  ("010",'c',"011");
                  
                  ("110",'a',"010");
                  ("110",'b',"100");
                  ("110",'c',"111");

                  ("001",'a',"101");
                  ("001",'b',"011");
                  ("001",'c',"bad");
                  
                  ("101",'a',"001");
                  ("101",'b',"111");
                  ("101",'c',"bad");
                  
                  ("011",'a',"111");
                  ("011",'b',"001");
                  ("011",'c',"bad");
                  
                  ("111",'a',"011");
                  ("111",'b',"101");
                  ("111",'c',"bad")];
                  
            start = "000";
            final = ["111"]}
    



(* QUESTION 3 *)

let fa1 = { states = ["fa1_1";"fa1_2";"fa1_3"];
        alphabet = ['a';'b';'c'];
        delta = [ ("fa1_1",'a',"fa1_2");
              ("fa1_2",'a',"fa1_3");
              ("fa1_3",'a',"fa1_1") ];
        start = "fa1_1";
        final = ["fa1_1"] }

let fa2 = { states = ["fa2_1";"fa2_2"];
        alphabet = ['a';'b';'c'];
        delta = [ ("fa2_1",'b',"fa2_2");
              ("fa2_2",'c',"fa2_1") ];
        start = "fa2_1";
        final = ["fa2_1"] }


let rec allFollowing nstart state delta = 
  match delta with
  | [] -> []
  | (p,a,q)::delta' -> if p = state 
                         then (nstart,a,q)::(allFollowing nstart state delta')
                       else allFollowing nstart state delta'


let unionM (m1:'a fa) (m2:'a fa):'a fa = 
  (* you can assume same alphabet *)
  (* you can assume the states are different *)
  (* you can assume string states *)

  let new_states = m1.states @ m2.states @ ["new_start"] in
  let alphabet = m1.alphabet in
  let new_delta = m1.delta @ m2.delta @ 
    (allFollowing "new_start" m1.start m1.delta) @
    (allFollowing "new_start" m2.start m2.delta)  in
  let new_start = "new_start" in
  let new_final = if (List.mem m1.start m1.final ||
                List.mem m2.start m2.final) 
                    then m1.final @ m2.final @ ["new_start"] 
                  else m1.final @ m2.final  in
  { states = new_states;
    alphabet = alphabet;
    delta = new_delta;
    start = new_start;
    final = new_final }

      
let rec allFollowingAll nstarts state delta = 
  match nstarts with 
  | [] -> []
  | nstart:: nstarts' -> (allFollowing nstart state delta)@
                           (allFollowingAll nstarts' state delta)  


      
let concatM (m1:string fa) (m2:string fa):'a fa = 
  (* you can assume the same alphabet *)
  (* you can assume the states are different *)
  (* you can assume string states *)

  let new_states = m1.states @ m2.states  in
  let alphabet = m1.alphabet  in
  let new_delta = m1.delta @ m2.delta @
                    (allFollowingAll m1.final m2.start m2.delta)  in
  let new_start = m1.start  in
  let new_final = if List.mem m2.start m2.final 
                     then m1.final @ m2.final
          else m2.final
  in { states = new_states; 
       alphabet = alphabet;
       delta = new_delta;
       start = new_start;
       final = new_final }


      

(* This function is the base function that basically loops through all
 * strings  
 * of length up to n, and prints those that are accepted by the
 * finite automaton.
 *
 * This is being way too clever to try to not blow the stack 
 * while enumerating all strings up to a given length. Basically.
 * we enumerate all integer, convert them to base K (where K is the
 * size of the alphabet) and then replace every digit base K by the
 * letter of the alphabet at the corresponding index in the alphabet. 
 *
 * The key is that we can enumerate integers super easily
 *
 *)

let lang m n = 

  let rec expt a n = if n &lt;= 0 then 1 else a*(expt a (n-1)) in
  
  let rec take n default l = 
    if n &lt;= 0 then []
    else (match l with
          | [] -> default::(take (n-1) default l)
          | x::xs -> x::(take (n-1) default xs)) in
  
  let to_base_n base size n = 
    let rec loop n = 
      if n &lt;= 0 then []
      else if n mod base = 0 then 0::(loop (n / base))
      else (n mod base)::(loop ((n - n mod base) / base))  in
    take size 0 (loop n)  in
  
  let to_string alphabet size n = 
    let base = List.length alphabet in
    let num_base = to_base_n base size n in
    implode (List.map (fun i -> List.nth alphabet i) num_base) in
  
    if n &lt; 0 then ()
    else
      let print_str s = if s = "" then print_string "  &lt;epsilon>\n"
                  else print_string ("  "^s^"\n")  in
      let rec loop i = 
        if i &lt;= n then 
      let ts = to_string m.alphabet i  in
      let bound = expt (List.length m.alphabet) i in
      let rec loop2 j = 
        if j &lt; bound then (if accept m (ts j) 
                                 then print_str (ts j)
                               else ();
                   loop2 (j+1))
        else ()  in
      (loop2 0; loop (i+1))
        else ()  in
      loop 0

</pre>

<pre>
type language = string list


   (* Q1: Language operations *)


let rec lang_in x ys =
  List.mem x ys

let rec lang_size xs = 
  (* return the number of distinct elements! *)
  match xs with 
    [] -> 0
  | x::xs' -> (if lang_in x xs' then lang_size xs'
	       else 1 + lang_size xs')

let rec lang_union xs ys = 
   xs @ ys

let rec concat_string_to_lang x ys = 
   match ys with
     [] -> []
   | y::ys -> let s = x^y in 
              s::concat_string_to_lang x ys

let rec lang_concat xs ys = 
   match xs with
     [] -> []
   | x::xs -> (concat_string_to_lang x ys)@(lang_concat xs ys)

let rec lang_nstar n xs = 
   let rec loop xs iter = 
     if iter = 0 then [""]
     else if iter = 1 then xs
     else let r = loop xs (iter -1 ) in
          let c = lang_concat xs r  in
          lang_union xs c  in
   ""::(loop xs n)



   (* Q2: regular expressions *)

type re = 
    Empty 
  | Unit 
  | Letter of string 
  | Plus of re * re 
  | Times of re * re 
  | Star of re


let lang r n ml = 

  let compute_lang n s = 
    let fromChar c = String.make 1 c in
    let explode s = 
      let rec loop i result = 
        if i &lt; 0 then result
        else loop (i-1) (s.[i]::result) in
      loop (String.length s - 1) []  in
    let isalpha = function 'A'..'Z'|'a'..'z' -> true | _ -> false in
    let expect c cs = 
      match cs with 
        f::cs when f = c -> Some cs
      | _ -> None in
    let expect_alpha cs = 
      match cs with
        f::cs when isalpha f -> Some (f,cs)
      | _ -> None  in
    let rec parse_R cs = 
      match parse_R1 cs with
        None -> None
      | Some (r1,cs) -> 
          (match expect '+' cs with
             None -> Some (r1,cs)
           | Some cs -> 
               (match parse_R cs with
                  None -> None
                | Some (r2,cs) -> Some (Plus(r1,r2),cs)))
    and parse_R1 cs = 
      match parse_R2 cs with
        None -> None
      | Some (r1,cs) -> 
          (match parse_R1 cs with
             None -> Some (r1,cs)
           | Some (r2,cs) -> Some (Times(r1,r2),cs))  
    and parse_R2 cs = 
      match parse_R3 cs with
        None -> None
      | Some (r1,cs) -> 
          (match expect '*' cs with
             None -> Some (r1,cs)
           | Some cs -> Some (Star(r1),cs))
    and parse_R3 cs = 
      match expect_alpha cs with
        Some (a,cs) -> Some (Letter(fromChar(a)),cs)
      | None -> 
          (match expect '1' cs with
             Some cs -> Some (Unit, cs)
           | None -> 
               (match expect '0' cs with
                  Some cs -> Some (Empty,cs)
                | None -> parse_parens cs))
    and parse_parens cs = 
      match expect '(' cs with
        None -> None
      | Some cs -> 
          (match parse_R cs with
             None -> None
           | Some (r,cs) -> 
               (match expect ')' cs with
                  None -> None
                | Some cs -> Some (r,cs)))  in
    let parse s = 
      let cs = explode s in
      match parse_R cs with
        Some (re,[]) -> re
      | _ -> failwith ("Cannot parse "^s)  in
    let rec eval re k = 
      match re with
        Empty -> k []
      | Unit -> k [""]
      | Letter (a) -> k [a]
      | Plus (r1,r2) -> eval r1 (fun l1 -> eval r2 (fun l2 -> k (lang_union l1 l2)))
      | Times (r1,r2) -> eval r1 (fun l1 -> eval r2 (fun l2 -> k (lang_concat l1 l2)))
      | Star r -> eval r (fun l -> k (lang_nstar n l))  in
    eval (parse s) (fun x -> x)   in

  let l = List.filter (fun s -> String.length s &lt;= ml) (compute_lang n r)  in

  let cmp a b = if String.length a &lt; String.length b then -1
                else if String.length b &lt; String.length a then 1
                else String.compare a b   in

  let sl = List.sort cmp l in

  let rec loop l seen = 
    match l with
    | [] -> ()
    | s::rest -> if List.mem s seen 
                   then loop rest seen 
                 else (match s with 
                       | "" -> let _ = print_string "  &lt;epsilon>\n" in loop rest (""::seen)
                       | s -> let _ = print_string ("  "^s^"\n") in loop rest (s::seen)) in
  loop sl []


   
(* QUESTION 2 *)

let regexp_a = "(d+e)(d+e)(d+e)(d+e)"
let regexp_b = "(d+e)((d+e)(d+e))*"
let regexp_c = "e*de*de*"
let regexp_d = "e*de*(de*de*)*"
let regexp_d_alt = "e*e*de*e*(de*e*de*e*)*"
let regexp_e = "e*(deee*)*"

</pre>

<pre>
(* Question 1 *)


let rec expt (a:int) (b:int):int = 
  if b < 0 then failwith "expt: incorrect arguments"
  else if b = 0 then 1
  else a * (expt a (b -1))


let rec gcd (a:int) (b:int):int  = 
  if a <0 || b < 0 then failwith "gcd: incorrect arguments"
  else if a = 0 then b
  else if b = 0 then a
  else if a > b then gcd b (a mod b)
  else gcd a (b mod a)


let rec even (a:int):bool =
  if a = 0 then true
  else not (even (a-1))

let rec collatz (a:int):int list =
  if a = 1 then [1]
  else if even a then a::(collatz (a / 2))
  else a::(collatz (3*a+1))

let rec range (i:int) (j:int):int list =
  if i >= j  then []
  else i::(range (i+1) j)



(* Question 2 *)

let rec dupAndNegate (xs:int list):int list =
  match xs with
  | [] -> []
  | x::xs' -> x::((-x)::(dupAndNegate xs'))


let rec positives (xs:int list):int list =
  match xs with
  | [] -> []
  | x::xs' -> if x > 0 then x :: positives xs' else positives xs'


let rec nth (n:int) (xs:'a list):'a =
  match xs with
  | [] -> failwith "nth: incorrect arguments"
  | x::xs' -> if n = 0 then x else nth (n-1) xs'


let rec last (xs:'a list):'a = 
  match xs with
  | [] -> failwith "last: incorrect arguments"
  | x::xs' -> (match xs' with
               | [] -> x
               | y::ys -> last xs')
     

let rec evenOdds (xs:int list):(int list * int list) =
  match xs with
  | [] -> ([],[])
  | x::xs' -> (let res = evenOdds(xs') in
               match res with (es,os) -> if even x then (x::es,os) else (es,x::os))



(* QUESTION 3 *)


let rec scaleV (a:int) (v:int list):int list =
  match v with
  | [] -> []
  | x::xs -> (a*x)::(scaleV a xs)


let rec addV (v:int list) (w:int list):int list =
  match v with
  | [] -> []
  | x::xs -> (match w with
              | [] -> []
              | y::ys -> (x+y)::(addV xs ys))


let rec inner (v:int list) (w:int list):int =
  match v with
  | [] -> 0
  | x::xs -> (match w with
              | [] -> 0
              | y::ys -> (x*y)+(inner xs ys))


let rec outer (v:int list) (w:int list):int list list =
  match v with
  | [] -> []
  | x::xs -> (scaleV x w)::(outer xs w)

</pre>
